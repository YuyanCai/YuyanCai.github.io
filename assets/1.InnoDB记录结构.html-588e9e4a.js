import{ac as p,F as t,G as i,D as n,R as a,M as e,ad as o,V as c}from"./framework-f12b30cc.js";const r={},l=o('<h1 id="一、innodb记录结构" tabindex="-1"><a class="header-anchor" href="#一、innodb记录结构" aria-hidden="true">#</a> 一、InnoDB记录结构</h1><h2 id="字符集的介绍" tabindex="-1"><a class="header-anchor" href="#字符集的介绍" aria-hidden="true">#</a> 字符集的介绍</h2><h3 id="ascii" tabindex="-1"><a class="header-anchor" href="#ascii" aria-hidden="true">#</a> ASCII</h3>',3),d={href:"https://zh.m.wikipedia.org/zh-hans/ASCII",target:"_blank",rel:"noopener noreferrer"},u=n("strong",null,"使用那些二进制数来表示哪个符号，这就是编码",-1),g={href:"https://zh.m.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E7%B5%84%E7%B9%94",target:"_blank",rel:"noopener noreferrer"},m=o('<p><code>ASCII</code>使用标准的<code>单字节字符编码</code>(<strong>一个字符占用一个字节</strong>)方案，用于基于文本的数据。</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906151127815.png" alt="image-20220906151127815" tabindex="0" loading="lazy"><figcaption>image-20220906151127815</figcaption></figure><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906151136029.png" alt="image-20220906151136029" tabindex="0" loading="lazy"><figcaption>image-20220906151136029</figcaption></figure><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><p>ASCII的局限在于只能显示26个基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语</p><p>现在大多软件系统采用Unicode，特别是与ASCII向下兼容的UTF-8.</p><h3 id="utf-8" tabindex="-1"><a class="header-anchor" href="#utf-8" aria-hidden="true">#</a> UTF-8</h3>',7),k=n("strong",null,"UTF-8",-1),h=n("strong",null,"8-bit Unicode Transformation Format",-1),b={href:"https://zh.m.wikipedia.org/wiki/Unicode",target:"_blank",rel:"noopener noreferrer"},f=n("strong",null,"可变长度",-1),v={href:"https://zh.m.wikipedia.org/wiki/%E5%AD%97%E5%85%83%E7%B7%A8%E7%A2%BC",target:"_blank",rel:"noopener noreferrer"},y={href:"https://zh.m.wikipedia.org/wiki/%E5%89%8D%E7%BC%80%E7%A0%81",target:"_blank",rel:"noopener noreferrer"},_=n("strong",null,"一至四个字节",-1),A={href:"https://zh.m.wikipedia.org/wiki/Unicode",target:"_blank",rel:"noopener noreferrer"},L={href:"https://zh.m.wikipedia.org/wiki/%E5%AD%97%E8%8A%82",target:"_blank",rel:"noopener noreferrer"},R={href:"https://zh.m.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94",target:"_blank",rel:"noopener noreferrer"},w={href:"https://zh.m.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"},C={href:"https://zh.m.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81",target:"_blank",rel:"noopener noreferrer"},x={href:"https://zh.m.wikipedia.org/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE",target:"_blank",rel:"noopener noreferrer"},E=o(`<h2 id="innodb页简介" tabindex="-1"><a class="header-anchor" href="#innodb页简介" aria-hidden="true">#</a> InnoDB页简介</h2><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机重启后数据还是在的。真正处理数据的过程是发生在内存当中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而磁盘的读写速度是很慢的，所以当我们想从表中获取数据时，InnoDB引擎采取的方式是：**将数据划分为若干个页，以页为单位作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB。**也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中16kb内容刷新到磁盘中</p><h2 id="innodb行格式" tabindex="-1"><a class="header-anchor" href="#innodb行格式" aria-hidden="true">#</a> InnoDB行格式</h2><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。 设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 <strong>Compact 、 Redundant 、 Dynamic 和 Compressed 行格式</strong>，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理 上大体都是相同的。</p><h3 id="指定行格式的语法" tabindex="-1"><a class="header-anchor" href="#指定行格式的语法" aria-hidden="true">#</a> 指定行格式的语法</h3><p>我们可以在创建或修改表的语句中指定 行格式 ：</p><p>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</p><p>ALTER TABLE 表名 ROW_FORMAT=行格式名称</p><p>比如我们在 xiaohaizi 数据库里创建一个演示用的表 record_format_demo ，可以这样指定它的 行格式 ：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">USE</span> xiaohaizi<span class="token punctuation">;</span>
<span class="token keyword">Database</span> changed
mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> record_format_demo <span class="token punctuation">(</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c4 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到我们刚刚创建的这个表的 行格式 就是 Compact ，另外，我们还显式指定了这个表的字符集为 ascii ， 因为 ascii 字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这 个表里的。我们现在向这个表中插入两条记录：</p><div class="language-sql\\ line-numbers-mode" data-ext="sql\\"><pre class="language-sql\\"><code>mysql&gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES(&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;),
(&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);
Query OK, 2 rows affected (0.02 sec)
Records: 2 Duplicates: 0 Warnings: 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在表中的记录就是这个样子的：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> record_format_demo<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------+-----+------+------+</span>
<span class="token operator">|</span> c1   <span class="token operator">|</span> c2  <span class="token operator">|</span>  c3  <span class="token operator">|</span>  c4  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+-----+------+------+</span>
<span class="token operator">|</span> aaaa <span class="token operator">|</span> bbb <span class="token operator">|</span> cc   <span class="token operator">|</span>  d   <span class="token operator">|</span>
<span class="token operator">|</span> eeee <span class="token operator">|</span> fff <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+-----+------+------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="compact行格式" tabindex="-1"><a class="header-anchor" href="#compact行格式" aria-hidden="true">#</a> COMPACT行格式</h3><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904142502789.png" alt="image-20220904142502789" tabindex="0" loading="lazy"><figcaption>image-20220904142502789</figcaption></figure><h4 id="记录的额外信息" tabindex="-1"><a class="header-anchor" href="#记录的额外信息" aria-hidden="true">#</a> 记录的额外信息</h4><p>这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段 长度列表 、 NULL值列表 和 记录头信息</p><h5 id="变长字段长度列表" tabindex="-1"><a class="header-anchor" href="#变长字段长度列表" aria-hidden="true">#</a> 变长字段长度列表</h5><p>MySQL 支持一些变长的数据类型，比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类 型，我们也可以把拥有这些数据类型的列称为 变长字段 ，变长字段中存储多少字节的数据是不固定的，所以我 们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 MySQL 服务器搞懵，所以 这些变长字段占用的存储空间分为两部分：</p><ol><li>真正的数据内容</li><li>占用的字节数</li></ol><p>在 Compact 行格式中，<strong>把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放</strong></p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905223901417.png" alt="image-20220905223901417" tabindex="0" loading="lazy"><figcaption>image-20220905223901417</figcaption></figure><h5 id="null值列表" tabindex="-1"><a class="header-anchor" href="#null值列表" aria-hidden="true">#</a> NULL值列表</h5><p>如果把<code>NULL</code>值都放到记录的真实数据中存储会很占用地方，所以Compact行格式把这个些<code>NULL</code>值列统一管理起来，存储到<code>NULL</code>值列表中，它的处理过程是这样的：</p><ol><li>首先统计表中允许存储 NULL 的列有哪些</li></ol><p>我们前边说过，主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列 算进去</p><ol start="2"><li><strong>如果表中没有允许存储NULL值的列，则NULL值列表也不存在了</strong>，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列 <ul><li>二进制位的值为1时，代表该列的值为NULL</li><li>二进制位的值为0时，代表该列的值不位NULL</li></ul></li></ol><p>因为表 record_format_demo 有3个值允许为 NULL 的列，所以这3个列和二进制位的对应关系就是这 样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905225003694.png" alt="image-20220905225003694" tabindex="0" loading="lazy"><figcaption>image-20220905225003694</figcaption></figure><p>二进制位按照列的顺序<strong>逆序</strong>排列，所以第一个列 c1 和最后一个二进制位对应</p><ol start="3"><li>MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节 的高位补 0 。</li></ol><p>表 record_format_demo 只有3个值允许为 NULL 的列，对应3个二进制位，不足一个字节，所以在字节的高 位补 0 ，效果就是这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905225901129.png" alt="image-20220905225901129" tabindex="0" loading="lazy"><figcaption>image-20220905225901129</figcaption></figure><p>以此类推，如果一个表中有9个允许为 NULL ，那这个记录的 NULL 值列表部分就需要2个字节来表示了。</p><p>知道了规则之后，我们再返回头看表 record_format_demo 中的两条记录中的 NULL值列表 应该怎么储存。因为只 有 c1 、 c3 、 c4 这3个列允许存储 NULL 值，所以所有记录的 NULL值列表 只需要一个字节。</p><ul><li>对于第一条记录来说， c1 、 c3 、 c4 这3个列的值都不为 NULL ，所以它们对应的二进制位都是 0 ，画个 图就是这样：</li></ul><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905225940635.png" alt="image-20220905225940635" tabindex="0" loading="lazy"><figcaption>image-20220905225940635</figcaption></figure><p>所以第一条记录的 NULL值列表 用十六进制表示就是： 0x00 。</p><p>对于第二条记录来说， c1 、 c3 、 c4 这3个列中 c3 和 c4 的值都为 NULL ，所以这3个列对应的二进制位的 情况就是：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230019367.png" alt="image-20220905230019367" tabindex="0" loading="lazy"><figcaption>image-20220905230019367</figcaption></figure><p>所以第二条记录的 NULL值列表 用十六进制表示就是： 0x06 。</p><p>所以这两条记录在填充了 NULL值列表 后的示意图就是这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230039541.png" alt="image-20220905230039541" tabindex="0" loading="lazy"><figcaption>image-20220905230039541</figcaption></figure><h5 id="记录头信息" tabindex="-1"><a class="header-anchor" href="#记录头信息" aria-hidden="true">#</a> 记录头信息</h5><p>除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组 成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904153815836.png" alt="image-20220904153815836" tabindex="0" loading="lazy"><figcaption>image-20220904153815836</figcaption></figure><p>这些二进制位代表的详细信息如下表：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230231002.png" alt="image-20220905230231002" tabindex="0" loading="lazy"><figcaption>image-20220905230231002</figcaption></figure><p>我们现在直接看一下 record_format_demo 中的两条记录的 头信息 分别是什么：</p><h6 id="记录的真实数据" tabindex="-1"><a class="header-anchor" href="#记录的真实数据" aria-hidden="true">#</a> 记录的真实数据</h6><p>对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据 以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904160501312.png" alt="image-20220904160501312" tabindex="0" loading="lazy"><figcaption>image-20220904160501312</figcaption></figure><p>因为表 record_format_demo 并没有定义主键，所以 MySQL 服务器会为每条记录增加上述的3个列。现在看一下 加上 记录的真实数据 的两个记录长什么样吧</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230612848.png" alt="image-20220905230612848" tabindex="0" loading="lazy"><figcaption>image-20220905230612848</figcaption></figure><p>看这个图的时候我们需要注意几点：</p><ol><li><p>表 record_format_demo 使用的是 ascii 字符集，所以 0x61616161 就表示字符串 &#39;aaaa&#39; ， 0x626262 就表示字符串 &#39;bbb&#39; ，以此类推。</p></li><li><p>注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是： &#39;cc&#39; ，而 ascii 字符集中的字节表示是 &#39;0x6363&#39; ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用<code>空格字符填充</code>，空格字符在 ascii 字符集的表示就是 0x20 。</p></li><li><p>注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处就不再冗余存储，从而节省存储空间。</p></li></ol><h6 id="char-m-列的存储格式" tabindex="-1"><a class="header-anchor" href="#char-m-列的存储格式" aria-hidden="true">#</a> CHAR(M)列的存储格式</h6><p>record_format_demo 表的 c1 、 c2 、 c4 列的类型是 VARCHAR(10) ，而 c3 列的类型是 CHAR(10) ，我们说在 Compact 行格式下只会把变长类型的列的长度逆序存到 变长字段长度列表 中，就像这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905231151660.png" alt="image-20220905231151660" tabindex="0" loading="lazy"><figcaption>image-20220905231151660</figcaption></figure><p>但是这只是因为我们的<code> record_format_demo</code> 表采用的是 <code>ascii </code>字符集，这个字符集是一个<code>定长字符集</code>，也就是 说<strong>表示一个字符采用固定的一个字节</strong>，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如 gbk 表示一个字符要12个字节、 utf8 表示一个字符要13个字节等）的话， c3 列的长度也会被存储到 变长字段 长度列表 中，比如我们修改一下record_format_demo 表的字符集：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> record_format_demo <span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span>
Records: <span class="token number">2</span> Duplicates: <span class="token number">0</span> <span class="token keyword">Warnings</span>: <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改该列字符集后记录的 变长字段长度列表 也发生了变化，如图：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905232957104.png" alt="image-20220905232957104" tabindex="0" loading="lazy"><figcaption>image-20220905232957104</figcaption></figure><p>这就意味着：<strong>对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字 段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</strong></p><p>另外有一点还需要注意，变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，而 VARCHAR(M) 却没有这个要 求。比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10～30个字节。即 使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节 长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有 的记录空间成为所谓的碎片。</p><h6 id="varchar和char的的区别是什么" tabindex="-1"><a class="header-anchor" href="#varchar和char的的区别是什么" aria-hidden="true">#</a> varchar和char的的区别是什么</h6><p><strong>char的长度是不可变的，而varchar的长度是可变的。</strong></p><p>定义一个char（10）和varchar（10），如果存进去的是三个字节，那么char会用空格填满10个字节</p><p>varchar不会这样做，varchar的话本来是10个字节，那么它就会把长度变为3了</p><p>取数据的时候，cahr类型的要用trim（）去掉多余的空格，而varchar是不需要的。</p><p><code>char的存取速度比varchar快的多</code>，因为它<code>长度固定</code>，方便程序的存储与查找，相当于是以<code>空间换取时间效率</code></p><p><code>varchar</code>是以<code>空间效率为首位</code>。</p><p><strong>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</strong></p><p><strong>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</strong></p><h3 id="redundant行格式" tabindex="-1"><a class="header-anchor" href="#redundant行格式" aria-hidden="true">#</a> Redundant行格式</h3><p>为了知识的系统性，我们也来看下Redundant行格式</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906113020329.png" alt="image-20220906113020329" tabindex="0" loading="lazy"><figcaption>image-20220906113020329</figcaption></figure><p>现在我们把表 record_format_demo 的行格式修改为 Redundant ：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; ALTER TABLE record_format_demo ROW_FORMAT=Redundant;
Query OK, 0 rows affected (0.05 sec)
Records: 0 Duplicates: 0 Warnings: 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>了方便大家理解和节省篇幅，我们直接把表 record_format_demo 在 Redundant 行格式下的两条记录的真实存 储数据提供出来，之后我们着重分析两种行格式的不同即可。</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906113546830.png" alt="image-20220906113546830" tabindex="0" loading="lazy"><figcaption>image-20220906113546830</figcaption></figure><p>下边我们从各个方面看一下 Redundant 行格式有什么不同的地方：</p><ul><li>字段长度偏移列表</li></ul><p>注意 Compact 行格式的开头是 变长字段长度列表 ，而 Redundant 行格式的开头是 字段长度偏移列表 ，与 变长字段长度列表 有两处不同：</p><ul><li>没有了<code>变长</code>两个字，意味着 Redundant 行格式会把该条记录中<code>所有列</code>（包括 隐藏列 ）的长度信息都按 照<code>逆序</code>存储到 字段长度偏移列表 。</li><li>多了个<code>偏移</code>两个字，这意味着计算列值长度的方式不像 Compact 行格式那么直观，它是采用两个相邻数 值的差值来计算各个列值的长度。</li></ul><p>比如第一条记录的 字段长度偏移列表 就是：</p><p>​ 25 24 1A 17 13 0C 06</p><p>因为它是逆序排放的，所以按照列的顺序排列就是：</p><p>​ 06 0C 13 17 1A 24 25</p><p>按照两个相邻数值的差值来计算各个列值的长度的意思就是：</p><p>​ 第一列(<code>row_id</code>)的长度就是 0x06个字节，也就是6个字节。</p><p>​ 第二列(<code>transaction_id</code>)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。</p><p>​ 第三列(<code>roll_pointer</code>)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。</p><p>​ 第四列(<code>c1</code>)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。</p><p>​ 第五列(<code>c2</code>)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。</p><p>​ 第六列(<code>c3</code>)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。</p><p>​ 第七列(<code>c4</code>)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。</p><h3 id="行溢出数据" tabindex="-1"><a class="header-anchor" href="#行溢出数据" aria-hidden="true">#</a> 行溢出数据</h3><h4 id="varchar-m-最多能存储的数据" tabindex="-1"><a class="header-anchor" href="#varchar-m-最多能存储的数据" aria-hidden="true">#</a> VARCHAR（M）最多能存储的数据</h4><p>我们知道对于 VARCHAR(M) 类型的列最多可以占用 65535 个字节。其中的 M 代表该类型最多存储的字符数量，如 果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们看看 VARCHAR(65535) 是否可用：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> varchar_size_demo<span class="token punctuation">(</span>
	c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65535</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
<span class="token keyword">some</span> <span class="token keyword">columns</span> <span class="token keyword">to</span> <span class="token keyword">TEXT</span> <span class="token operator">or</span> BLOBs
<span class="token operator">&gt;</span> 时间: <span class="token number">0.002</span>s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从报错信息里可以看出， MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之 外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。所以 MySQL 服 务器建议我们把存储类型改为 TEXT 或者 BLOB 的类型。这个 65535 个字节除了列本身的数据之外，还包括一些 其他的数据（ storage overhead ），比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间：</p><ul><li>真实数据</li><li>真实数据占用字节的长度</li><li>NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间</li></ul><p>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能 占用2个字节， NULL 值标识需要占用1个字节：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> varchar_size_demo<span class="token punctuation">(</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65532</span><span class="token punctuation">)</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2个字节，不需要 NULL 值标识：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> varchar_size_demo<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> varchar_size_demo<span class="token punctuation">(</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65533</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 VARCHAR(M) 类型的列使用的不是 ascii 字符集，那会怎么样呢？来看一下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> varchar_size_demo<span class="token punctuation">(</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65532</span><span class="token punctuation">)</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>gbk ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
ERROR <span class="token number">1074</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: <span class="token keyword">Column</span> length too big <span class="token keyword">for</span> <span class="token keyword">column</span> <span class="token string">&#39;c&#39;</span> <span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">32767</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">use</span> <span class="token keyword">BLOB</span> <span class="token operator">or</span> <span class="token keyword">TEXT</span> i
nstead

mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> varchar_size_demo<span class="token punctuation">(</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65532</span><span class="token punctuation">)</span>
 <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 ROW_FORMAT<span class="token operator">=</span>Compact<span class="token punctuation">;</span>
ERROR <span class="token number">1074</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: <span class="token keyword">Column</span> length too big <span class="token keyword">for</span> <span class="token keyword">column</span> <span class="token string">&#39;c&#39;</span> <span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">21845</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">use</span> <span class="token keyword">BLOB</span> <span class="token operator">or</span> <span class="token keyword">TEXT</span> i
nstead
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从执行结果中可以看出，如果 VARCHAR(M) 类型的列使用的不是 ascii 字符集，那 M 的最大取值取决于该字符集 表示一个字符最多需要的字节数。在列的值允许为 NULL 的情况下， gbk 字符集表示一个字符最多需要 2 个字 节，那在该字符集下， M 的最大取值就是 32766 （也就是：65532/2），也就是说最多能存储 32766 个字符； utf8 字符集表示一个字符最多需要 3 个字节，那在该字符集下， M 的最大取值就是 21844 ，就是说最多能存 储 21844 （也就是：65532/3）个字符。</p><p><strong>UTF8编码中一个汉字（包括数字）占用3个字节</strong></p><p><strong>GBK编码中一个汉字（包括数字）占用2个字节</strong></p><h4 id="记录中的数据太多产生的溢出" tabindex="-1"><a class="header-anchor" href="#记录中的数据太多产生的溢出" aria-hidden="true">#</a> 记录中的数据太多产生的溢出</h4><p>我们以 ascii 字符集下的 varchar_size_demo 表为例，插入一条记录：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; CREATE TABLE varchar_size_demo(
 -&gt; c VARCHAR(65532)
 -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)
mysql&gt; INSERT INTO varchar_size_demo(c) VALUES(REPEAT(&#39;a&#39;, 65532));
Query OK, 1 row affected (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 REPEAT(&#39;a&#39;, 65532) 是一个函数调用，它表示生成一个把字符 &#39;a&#39; 重复 65532 次的字符串。前边说 过，<code>MySQL</code>中磁盘和内存交互的基本单位是 <code>页 </code>，也就是说 <code>MySQL 是以 页 为基本单位来管理存储空间的</code>，我们 的记录都会被分配到某个 页 中存储。而<code>一个页的大小一般是 16KB</code> ，也就是 16384 字节，而<code>一个 VARCHAR(M) 类 型的列就最多可以存储 65532 个字节</code>，这样就可能造成<code>一个页存放不了一条记录</code>的尴尬情况。</p><p>在 <code>Compact </code>和<code> Reduntant</code> 行格式中，<strong>对于占用存储空间非常大的列，在 记录的真实数据 处只会存储该列的一部 分数据，把剩余的数据分散存储在几个其他的页中，然后 记录的真实数据 处用20个字节存储指向这些页的地址 （当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页</strong>， 如图所示：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906153739582.png" alt="image-20220906153739582" tabindex="0" loading="lazy"><figcaption>image-20220906153739582</figcaption></figure><p>从图中可以看出来，对于 Compact 和 Reduntant 行格式来说，如果某一列中的数据非常多的话，在本记录的真实 数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个 过程也叫做 行溢出 ，存储超出 768 字节的那些页面也被称为 溢出页 。画一个简图就是这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906153751843.png" alt="image-20220906153751843" tabindex="0" loading="lazy"><figcaption>image-20220906153751843</figcaption></figure><p>最后需要注意的是，<strong>不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候 也会发生 行溢出 。</strong></p><h4 id="行溢出的临界点" tabindex="-1"><a class="header-anchor" href="#行溢出的临界点" aria-hidden="true">#</a> 行溢出的临界点</h4><p>在列存储多少字节的数据时会发生行溢出？</p><p>MySQL 中规定<strong>一个页中至少存放两行记录</strong>，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影 响。以上边的 varchar_size_demo 表为例，它只有一个列 c ，我们往这个表中插入两条记录，每条记录最少插入 多少字节的数据才会 行溢出 的现象呢？这得分析一下页中的空间都是如何利用的。</p><ul><li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要 136 个字节 的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li><li>每个记录需要的额外信息是 27 字节。</li></ul><p>这27个字节包括下边这些部分：</p><ul><li>2个字节用于存储真实数据的长度</li><li>1个字节用于存储列是否是NULL值</li><li>5个字节大小的头信息</li><li>6个字节的 row_id 列</li><li>6个字节的 transaction_id 列</li><li>7个字节的 roll_pointer 列</li></ul><p><strong>你不用关注这个临界点是什 么，只要知道如果我们想一个行中存储了很大的数据时，可能发生 行溢出 的现象。</strong></p><h3 id="dynamic和compressed行格式" tabindex="-1"><a class="header-anchor" href="#dynamic和compressed行格式" aria-hidden="true">#</a> Dynamic和Compressed行格式</h3><p>Dynamic 和 Compressed 行格式，我现在使用的 MySQL 版本是 5.7 ，它的默认行格 式就是 Dynamic ，这俩行格式和 Compact 行格式挺像，只不过在处理 行溢出 数据时有点儿分歧，它们不会在记 录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数 据处存储其他页面的地址，就像这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906144330784.png" alt="image-20220906144330784" tabindex="0" loading="lazy"><figcaption>image-20220906144330784</figcaption></figure><p><strong>Compressed 行格式和 Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空 间。</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824202128667.png" alt="image-20220824202128667" tabindex="0" loading="lazy"><figcaption>image-20220824202128667</figcaption></figure><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824202136734.png" alt="image-20220824202136734" tabindex="0" loading="lazy"><figcaption>image-20220824202136734</figcaption></figure><ol start="4"><li>一个页一般是 16KB ，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种 现象称为 行溢出 。</li></ol>`,137);function T(B,U){const s=c("ExternalLinkIcon");return t(),i("div",null,[l,n("p",null,[n("a",d,[a("https://zh.m.wikipedia.org/zh-hans/ASCII"),e(s)])]),n("p",null,[a("在计算机中所有的数据在存储和运算时都要使用二进制数表示。例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常见的符号（*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体"),u,a("。如果不同的计算机想要互相通信不造成混乱，那么每台计算机就必须使用相同的编码规则，于是美国有关的"),n("a",g,[a("标准化组织"),e(s)]),a("就推出了ASCII编码。")]),m,n("p",null,[k,a("（"),h,a("）是一种针对"),n("a",b,[a("Unicode"),e(s)]),a("的"),f,n("a",v,[a("字元编码"),e(s)]),a("，也是一种"),n("a",y,[a("前缀码"),e(s)]),a("。它可以用"),_,a("对Unicode字符集中的所有有效编码点进行编码，属于"),n("a",A,[a("Unicode"),e(s)]),a("标准的一部分")]),n("p",null,[a("由于较小值的编码点一般使用频率较高，直接使用Unicode编码效率低下，大量浪费内存空间。UTF-8就是为了解决向后兼容ASCII码而设计，Unicode中前128个字符，使用与ASCII码相同的二进制值的单个"),n("a",L,[a("字节"),e(s)]),a("进行编码，而且字面与ASCII码的字面一一对应，这使得原来处理ASCII字元的"),n("a",R,[a("软体"),e(s)]),a("无须或只须做少部份修改，即可继续使用。因此，它逐渐成为"),n("a",w,[a("电子邮件"),e(s)]),a("、"),n("a",C,[a("网页"),e(s)]),a("及其他"),n("a",x,[a("储存"),e(s)]),a("或传送文字优先采用的编码方式。")]),E])}const N=p(r,[["render",T],["__file","1.InnoDB记录结构.html.vue"]]);export{N as default};
