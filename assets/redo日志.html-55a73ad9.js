import{ac as e,F as i,G as o,ad as a}from"./framework-f12b30cc.js";const r={},n=a(`<h1 id="十、redo日志" tabindex="-1"><a class="header-anchor" href="#十、redo日志" aria-hidden="true">#</a> 十、redo日志</h1><h2 id="redo日志是个啥" tabindex="-1"><a class="header-anchor" href="#redo日志是个啥" aria-hidden="true">#</a> redo日志是个啥</h2><p>我们知道 <strong>InnoDB 存储引擎</strong>是<strong>以页为单位</strong>来<strong>管理存储空间</strong>的，我们进行的<code>增删改查</code>操作其实<strong>本质上都是在访问页 面</strong>（包括读页面、写页面、创建新页面等操作）。我们前边唠叨 <code>Buffer Pool </code>的时候说过，在真正访问页面之 前，需要<strong>把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问</strong>。但是在唠叨事务的时候又强调过一个称 之为 <code>持久性 </code>的特性，就是说<strong>对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库 中所做的更改也不能丢失。<strong>但是如果我们只在内存的 Buffer Pool 中修改了页面，假设在事务提交后突然发生了 某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这 是我们所不能忍受的（想想ATM机已经提示狗哥转账成功，但之后由于服务器出现故障，重启之后猫爷发现自己 没收到钱，猫爷就被砍死了）。那么如何保证这个 持久性 呢？一个很简单的做法就是</strong>在事务提交完成之前把该 事务所修改的所有页面都刷新到磁盘</strong>，但是这个简单粗暴的做法有些问题：</p><ul><li><strong>刷新一个完整的数据页太浪费了</strong></li></ul><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 InnoDB 中是以页为单位来进行磁盘IO的， 也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是 16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。</p><ul><li><strong>随机IO刷起来比较慢</strong></li></ul><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能 并不相邻，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机IO， 随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说</p><p>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来 系统崩溃，在重启后也能把这种修改恢复出来（持久性）。所以我们其实没有必要在每次事务提交时就把该事务在内存中修 改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，比方说某个事务将系统表空间中的第100 号页面中偏移量为1000处的那个字节的值 1 改成 2 我们只需要记录一下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>将第0号表空间的100号页面的偏移量为1000处的值更新为 2 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的 步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足 持久性 的要 求。</strong></p><p>**因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为 重做日志，英文名为redo_log，我们也可以成为redo日志。**与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下：</p><ul><li><strong>redo日志占用的空间非常小</strong></li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于 redo 日志的格式我们稍后 会详细唠叨，现在只要知道一条 redo 日志占用的空间不是很大就好了。</p><ul><li><strong>redo 日志是顺序写入磁盘的</strong></li></ul><p>在执行事务的过程中，每执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁 盘的，也就是使用顺序IO。</p><h2 id="redo日志格式" tabindex="-1"><a class="header-anchor" href="#redo日志格式" aria-hidden="true">#</a> redo日志格式</h2><p>通过上边的内容我们知道， redo 日志本质上只是<strong>记录了一下事务对数据库做了哪些修改</strong>。 设计 InnoDB 的大叔 们针对事务对数据库的不同修改场景定义了多种类型的 redo 日志，但是绝大部分类型的 redo 日志都有下边这种 通用的结构：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220921192211452.png" alt="image-20220921192211452" tabindex="0" loading="lazy"><figcaption>image-20220921192211452</figcaption></figure><p>各个部分的详细释义如下：</p><ul><li>type ：该条 redo 日志的类型。</li></ul><p>type ：该条 redo 日志的类型。 在 MySQL 5.7.21 这个版本中，设计 InnoDB 的大叔一共为 redo 日志设计了53种不同的类型，稍后会详细介 绍不同类型的 redo 日志。 space ID ：表空间ID。 page number ：页号。 data ：该条 redo 日志的具体内容。</p><ul><li>space ID ：表空间ID。</li><li>page number ：页号。</li><li>data ：该条 redo 日志的具体内容。</li></ul><h3 id="简单的redo日志类型" tabindex="-1"><a class="header-anchor" href="#简单的redo日志类型" aria-hidden="true">#</a> 简单的redo日志类型</h3><p>我们前边介绍 InnoDB 的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义 Unique 键，那么 InnoDB 会自动的为表添加一个称之为 row_id 的隐藏列作为主键。为这个 row_id 隐藏列赋值 的方式如下：</p><ul><li>服务器会在内存中维护一个全局变量，每当向某个包含隐藏的 row_id 列的表中插入一条记录时，就会把该 变量的值当作新记录的 row_id 列的值，并且把该变量自增1。</li><li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为 7 的页面中一个称之为 Max Row ID 的属性处。</li><li>当系统启动时，会将上边提到的 Max Row ID 属性加载到内存中，将该值加上256之后赋值给我们前边提到的 全局变量（因为在上次关机时该全局变量的值可能大于 Max Row ID 属性值）。</li></ul><h3 id="复杂一些的redo日志类型" tabindex="-1"><a class="header-anchor" href="#复杂一些的redo日志类型" aria-hidden="true">#</a> 复杂一些的redo日志类型</h3><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二 级索引对应的 B+ 树）。以一条 INSERT 语句为例，它除了要向 B+ 树的页面中插入数据，也可能更新系统数据 Max Row ID 的值，不过对于我们用户来说，平时更关心的是语句对 B+ 树所做更新：</p><ul><li>表中包含多少个索引，一条 INSERT 语句就可能更新多少棵 B+ 树。</li><li>针对某一棵 B+ 树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记 录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加 目录 项记录 ）。</li></ul><p>在语句执行过程中， INSERT 语句对所有页面的修改都得保存到 redo 日志中去。做起来是很麻烦的，过程省略，有兴趣可以去翻书</p><p>画一个简易的示意图就像是这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220923223707965.png" alt="image-20220923223707965" tabindex="0" loading="lazy"><figcaption>image-20220923223707965</figcaption></figure><p><strong>把一条记录插入到一个页面时需要更改的地方非常多</strong></p><p>这时我们如果使用上边介绍的 简单的物理 redo 日志来记录这些修改时，可以有两种解决方案：</p><ul><li>方案一：在每个修改的地方都记录一条 redo 日志。</li></ul><p>也就是如上图所示，有多少个加粗的块，就写多少条物理 redo 日志。这样子记录 redo 日志的缺点是显而易 见的，因为被修改的地方是在太多了，可能记录的 redo 日志占用的空间都比整个页面占用的空间都多了～</p><ul><li>方案二：将整个页面的 第一个被修改的字节 到 最后一个修改的字节 之间所有的数据当成是一条物理 redo 日志中的具体数据。</li></ul><p>从图中也可以看出来， 第一个被修改的字节 到 最后一个修改的字节 之间仍然有许多没有修改过的数据，我 们把这些没有修改的数据也加入到 redo 日志中去岂不是太浪费了～</p><p>正因为上述两种使用物理 redo 日志的方式来记录某个页面中做了哪些修改比较浪费，设计 InnoDB 的大叔本着勤 俭节约的初心，提出了一些新的 redo 日志类型，比如：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220923224331443.png" alt="image-20220923224331443" tabindex="0" loading="lazy"><figcaption>image-20220923224331443</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220923224322403.png" alt="image-20220923224322403" tabindex="0" loading="lazy"><figcaption>image-20220923224322403</figcaption></figure><p>这些类型的 redo 日志既包含 物理 层面的意思，也包含 逻辑 层面的意思，具体指：</p><p>redo日志格式小结</p><ul><li><p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</p></li><li><p>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</p></li></ul><h3 id="redo日志格式小结" tabindex="-1"><a class="header-anchor" href="#redo日志格式小结" aria-hidden="true">#</a> redo日志格式小结</h3><p>没必要把所有类型搞明白，了解即可！</p><p><strong>redo日志会把事务在执行过程 中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</strong></p><h2 id="mini-transaction" tabindex="-1"><a class="header-anchor" href="#mini-transaction" aria-hidden="true">#</a> Mini-Transaction</h2><h3 id="以组的形式写入redo日志" tabindex="-1"><a class="header-anchor" href="#以组的形式写入redo日志" aria-hidden="true">#</a> 以组的形式写入redo日志</h3><p>语句在执行过程中可能修改若干个页面。比如我们前边说的一<strong>条 INSERT 语句</strong>可能修改系统表空间页号为 7 的页 面的 Max Row ID 属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会<strong>更新聚簇索引 和二级索引对应 B+ 树中的页面</strong>。由于对这些页面的更改都发生在 <code>Buffer Pool</code> 中，所以在修改完页面之后，需 要记录一下相应的 redo 日志。在执行语句的过程中产生的 redo 日志被设计 InnoDB 的大叔人为的划分成了若干 个不可分割的组，比如：</p><ul><li>更新 Max Row ID 属性时产生的 redo 日志是不可分割的。</li><li>向聚簇索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。</li><li>向某个二级索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的 redo 日志是不可分割的</li></ul><p>怎么理解这个 不可分割 的意思呢？我们以向某个索引对应的 B+ 树插入一条记录为例，在向 B+ 树中插入这条记 录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种 可能的情况：</p><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入 到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的 redo 日志就好了，我们把这种情况称之为<code>乐 观插入</code>。假如某个索引对应的 B+ 树长这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929094730229.png" alt="image-20220929094730229" tabindex="0" loading="lazy"><figcaption>image-20220929094730229</figcaption></figure><p>现在我们要插入一条键值为 10 的记录，很显然需要被插入到 页b 中，由于 页b 现在有足够的空间容纳一条 记录，所以直接将该记录插入到 页b 中就好了，就像这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929094750593.png" alt="image-20220929094750593" tabindex="0" loading="lazy"><figcaption>image-20220929094750593</figcaption></figure><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的 页 分裂 操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再 把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条 目录项记录 指向 这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条 redo 日志，我们把 这种情况称之为 悲观插入 。假如某个索引对应的 B+ 树长这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929094942029.png" alt="image-20220929094942029" tabindex="0" loading="lazy"><figcaption>image-20220929094942029</figcaption></figure><p>现在我们要插入一条键值为 10 的记录，很显然需要被插入到 页b 中，但是从图中也可以看出来，此时 页b 已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这 样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929095017911.png" alt="image-20220929095017911" tabindex="0" loading="lazy"><figcaption>image-20220929095017911</figcaption></figure><p>如果作为内节点的 页a 的剩余空闲空间也不足以容纳增加一条 目录项记录 ，那需要继续做内节点 页a 的分 裂操作，也就意味着会修改更多的页面，从而产生更多的 redo 日志。另外，对于 悲观插入 来说，由于需要 新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息 （比如什么 FREE 链表、 FSP_FREE_FRAG 链表吧啦吧啦我们在唠叨表空间那一章中介绍过的各种东东）等等 等等，反正总共需要记录的 redo 日志有二、三十条。</p><blockquote><p>在乐观插入时也可能会产生多条redo日志</p></blockquote><p>设计 InnoDB 的大叔们认为向某个索引对应的 B+ 树中插入一条记录的这个过程必须是原子的，不能说插了一半之 后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中 了，可是没有向内节点中插入一条 目录项记录 ，这个插入过程就是不完整的，这样会形成一棵不正确的 B+ 树。 <strong>我们知道 redo 日志是为了在系统奔溃重启时恢复崩溃前的状态</strong>，如果在悲观插入的过程中只记录了一部分 redo 日志，那么在系统奔溃重启时会将索引对应的 B+ 树恢复成一种不正确的状态，这是设计 InnoDB 的大叔们所不能 忍受的。所以他们规定**在执行这些需要保证原子性的操作时必须以 组 的形式来记录的 redo 日志，在进行系统奔 溃重启恢复时，针对某个组中的 redo 日志，要么把全部的日志都恢复掉，要么一条也不恢复。**怎么做到的呢？ 这得分情况讨论：</p><ul><li>有的需要保证原子性的操作会生成多条 redo 日志，比如向某个索引对应的 B+ 树中进行一次悲观插入就需要 生成许多条 redo 日志。</li></ul><p>如何把这些 redo 日志划分到一个组里边儿呢？设计 InnoDB 的大叔做了一个很简单的小把戏，就是在该组中 的最后一条 redo 日志后边加上一条特殊类型的 redo 日志，该类型名称为 MLOG_MULTI_REC_END ， type 字 段对应的十进制数字为 31 ，该类型的 redo 日志结构很简单，只有一个 type 字段</p><p>所以某个需要保证原子性的操作产生的一系列 redo 日志必须要以一个类型为 <code>MLOG_MULTI_REC_END</code> 结尾，就 像这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929101034715.png" alt="image-20220929101034715" tabindex="0" loading="lazy"><figcaption>image-20220929101034715</figcaption></figure><p>这样在系统奔溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的 redo 日志，才认为解析到了 一组完整的 redo 日志，才会进行恢复。否则的话直接放弃前边解析到的 <code>redo </code>日志。</p><ul><li>有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新 <code>Max Row ID </code>属性的操作就只会生成一条<code>redo</code>日志。</li></ul><h3 id="mini-transaction的概念" tabindex="-1"><a class="header-anchor" href="#mini-transaction的概念" aria-hidden="true">#</a> Mini-Transaction的概念</h3><p>设计 MySQL 的大叔把<strong>对底层页面中的一次原子访问的过程</strong>称之为一个 <code>Mini-Transaction </code>，简称 <strong>mtr</strong></p><ul><li><p>比如上边 所说的修改一次 Max Row ID 的值算是一个 Mini-Transactio</p></li><li><p>向某个索引对应的 B+ 树中插入一条记录的过程 也算是一个 Mini-Transaction</p></li></ul><p>通过上边的叙述我们也知道，一个所谓的 mtr 可以包含一组 redo 日志，在进 行奔溃恢复时这一组 redo 日志作为一个不可分割的整体。</p><p><code>一个事务</code>可以<code>包含若干条语句</code>，<code>每一条语句</code>其实是<code>由若干个 mtr 组成</code>，每一个<code> mtr</code> 又可以包含<code>若干条 redo 日 志</code>，画个图表示它们的关系就是这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929101403381.png" alt="image-20220929101403381" tabindex="0" loading="lazy"><figcaption>image-20220929101403381</figcaption></figure><h2 id="redo日志的写入过程" tabindex="-1"><a class="header-anchor" href="#redo日志的写入过程" aria-hidden="true">#</a> redo日志的写入过程</h2><h3 id="redo-log-block" tabindex="-1"><a class="header-anchor" href="#redo-log-block" aria-hidden="true">#</a> redo log block</h3><p>设计 InnoDB 的大叔为了更好的进行系统奔溃恢复，他们把通过 mtr 生成的 redo 日志都放在了大小为 512字节 的 页 中。为了和我们前边提到的表空间中的页做区别，我们这里把用来存储 redo 日志的页称为 block （你心 里清楚页和block的意思其实差不多就行了）。一个 redo log block 的示意图如下:</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929101617820.png" alt="image-20220929101617820" tabindex="0" loading="lazy"><figcaption>image-20220929101617820</figcaption></figure><p>真正的 redo 日志都是存储到占用 496 字节大小的 log block body 中，图中的 log block header 和 log block trailer 存储的是一些管理信息。我们来看看这些所谓的 管理信息 都是啥：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929101920766.png" alt="image-20220929101920766" tabindex="0" loading="lazy"><figcaption>image-20220929101920766</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929101950871.png" alt="image-20220929101950871" tabindex="0" loading="lazy"><figcaption>image-20220929101950871</figcaption></figure><h3 id="redo日志缓冲区" tabindex="-1"><a class="header-anchor" href="#redo日志缓冲区" aria-hidden="true">#</a> redo日志缓冲区</h3><p>设计 InnoDB 的大叔为了解决磁盘速度过慢的问题而引入了 Buffer Pool 。同理，写入 redo 日 志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的 连续内存空间，翻译成中文就是 redo日志缓冲区 ，我们也可以简称为 log buffer 。这片内存空间被划分成若干 个连续的 redo log block ，就像这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929102026636.png" alt="image-20220929102026636" tabindex="0" loading="lazy"><figcaption>image-20220929102026636</figcaption></figure><p>我们可以通过启动参数 innodb_log_buffer_size 来指定 log buffer 的大小，在 MySQL 5.7.21 这个版本中，该 启动参数的默认值为 16MB</p><h3 id="redo日志写入log-buffer" tabindex="-1"><a class="header-anchor" href="#redo日志写入log-buffer" aria-hidden="true">#</a> redo日志写入log buffer</h3><p>向 log buffer 中写入 redo 日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后 再往下一个block中写。当我们想往 log buffer 中写入 redo 日志时，第一个遇到的问题就是应该写在哪个 block 的哪个偏移量处，所以设计 InnoDB 的大叔特意提供了一个称之为 buf_free 的全局变量，该变量指明后 续写入的 redo 日志应该写入到 log buffer 中的哪个位置，如图所示</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929102712804.png" alt="image-20220929102712804" tabindex="0" loading="lazy"><figcaption>image-20220929102712804</figcaption></figure><p>我们前边说过**一个 mtr 执行过程中可能产生若干条 redo 日志，这些 redo 日志是一个不可分割的组，**所以其实 <strong>并不是每生成一条 redo 日志，就将其插入到 log buffer 中，而是每个 mtr 运行过程中产生的日志先暂时存到 一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志再全部复制到 log buffer 中。</strong></p><p>我们现在假设 有两个名为 T1 、 T2 的事务，每个事务都包含2个 mtr ，我们给这几个 mtr 命名一下：</p><ul><li><p>事务 T1 的两个 mtr 分别称为 mtr_T1_1 和 mtr_T1_2 。</p></li><li><p>事务 T2 的两个 mtr 分别称为 mtr_T2_1 和 mtr_T2_2 。</p></li></ul><p>每个 mtr 都会产生一组 redo 日志，用示意图来描述一下这些 mtr 产生的日志情况：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929103005248.png" alt="image-20220929103005248" tabindex="0" loading="lazy"><figcaption>image-20220929103005248</figcaption></figure><p>不同的事务可能是并发执行的，所以 <code>T1 、 T2</code> 之间的 mtr 可能是交替执行的。每当一个 mtr 执行完成时，伴随 该 mtr 生成的一组 redo 日志就需要被复制到 log buffer 中，也就是说不同事务的 mtr 可能是交替写入 log buffer 的，我们画个示意图（为了美观，我们把一个 mtr 中产生的所有的 redo 日志当作一个整体来画）：</p><p><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929103354050.png" alt="image-20220929103354050" loading="lazy">从示意图中我们可以看出来，不同的 mtr 产生的一组 redo 日志占用的存储空间可能不一样，有的 mtr 产生的 redo 日志量很少，比如 mtr_t1_1 、 mtr_t2_1 就被放到同一个block中存储，有的 mtr 产生的 redo 日志量非常 大，比如 mtr_t1_2 产生的 redo 日志甚至占用了3个block来存储</p><h2 id="redo日志文件" tabindex="-1"><a class="header-anchor" href="#redo日志文件" aria-hidden="true">#</a> redo日志文件</h2><h3 id="redo日志刷盘时机" tabindex="-1"><a class="header-anchor" href="#redo日志刷盘时机" aria-hidden="true">#</a> redo日志刷盘时机</h3><p>我们前边说 mtr 运行过程中产生的一组 redo 日志在 mtr 结束时会被复制到 log buffer 中，可是这些日志总在 内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如：</p><ul><li>log buffer 空间不足时</li></ul><p>log buffer 的大小是有限的（通过系统变量 innodb_log_buffer_size 指定），如果不停的往这个有限大小 的 log buffer 里塞入日志，很快它就会被填满。设计 InnoDB 的大叔认为如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</p><ul><li>事务提交时</li></ul><p>我们前边说过之所以使用 redo 日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改 过的 Buffer Pool 页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的 redo 日志刷新到 磁盘。</p><ul><li>后台线程不停的刷刷刷</li></ul><p>后台有一个线程，大约每秒都会刷新一次 log buffer 中的 redo 日志到磁盘。</p><ul><li>正常关闭服务器时</li><li>做所谓的 checkpoint 时</li><li>.....</li></ul><h3 id="redo日志文件组" tabindex="-1"><a class="header-anchor" href="#redo日志文件组" aria-hidden="true">#</a> redo日志文件组</h3><p>MySQL 的数据目录（使用 SHOW VARIABLES LIKE &#39;datadir&#39; 查看）下默认有两个名为 ib_logfile0 和 ib_logfile1 的文件， log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的 redo 日志文件不满意，可以通过下边几个启动参数来调节：</p><ul><li>innodb_log_group_home_dir</li></ul><p>该参数指定了 redo 日志文件所在的目录，默认值就是当前的数据目录。</p><ul><li>innodb_log_file_size</li></ul><p>该参数指定了每个 redo 日志文件的大小，在 MySQL 5.7.21 这个版本中的默认值为 48MB ，</p><ul><li>innodb_log_files_in_group</li></ul><p>该参数指定 redo 日志文件的个数，默认值为2，最大值为100。</p><p>从上边的描述中可以看到，磁盘上的 redo 日志文件不只一个，而是以一个 日志文件组 的形式出现的。这些文件 以 ib_logfile[数字] （ 数字 可以是 0 、 1 、 2 ...）的形式进行命名。在将 redo 日志写入 日志文件组 时，是 从 ib_logfile0 开始写，如果 ib_logfile0 写满了，就接着 ib_logfile1 写，同理， ib_logfile1 写满了就去 写 ib_logfile2 ，依此类推。如果写到最后一个文件该咋办？那就重新转到 ib_logfile0 继续写，所以整个过程 如下图所示：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929110441817.png" alt="image-20220929110441817" tabindex="0" loading="lazy"><figcaption>image-20220929110441817</figcaption></figure><p>总共的 redo 日志文件大小其实就是： innodb_log_file_size × innodb_log_files_in_group 。</p><blockquote><p>小贴士：如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的 redo日志覆盖掉前边写的redo日志？当然可能了！所以设计InnoDB的大叔提出了checkpoint的概念</p></blockquote><h3 id="redo日志文件格式" tabindex="-1"><a class="header-anchor" href="#redo日志文件格式" aria-hidden="true">#</a> redo日志文件格式</h3><p>我们前边说过 <code>log buffer </code>本质上是一片连续的内存空间，被划分成了若干个 512 字节大小的 block 。<strong>将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中</strong>，所以 redo 日志文件其实也是由若干 个 512 字节大小的block组成。</p><p>redo 日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储 log buffer 中的block镜像的。</li></ul><p>所以我们前边所说的 循环 使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是 这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929110701867.png" alt="image-20220929110701867" tabindex="0" loading="lazy"><figcaption>image-20220929110701867</figcaption></figure><p>普通block的格式我们在唠叨 log buffer 的时候都说过了，就是 log block header 、 log block body 、 log block trialer 这三个部分，就不重复介绍了。这里需要介绍一下每个 redo 日志文件前2048个字节，也就是前4 个特殊block的格式都是干嘛的，废话少说，先看图：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929110748034.png" alt="image-20220929110748034" tabindex="0" loading="lazy"><figcaption>image-20220929110748034</figcaption></figure><p>从图中可以看出来，这4个block分别是：</p><ul><li>log file header ：描述该 redo 日志文件的一些整体属性，看一下它的结构：</li></ul><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929110819539.png" alt="image-20220929110819539" tabindex="0" loading="lazy"><figcaption>image-20220929110819539</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220929110916408.png" alt="image-20220929110916408" tabindex="0" loading="lazy"><figcaption>image-20220929110916408</figcaption></figure><h2 id="log-sequeue-number" tabindex="-1"><a class="header-anchor" href="#log-sequeue-number" aria-hidden="true">#</a> Log Sequeue Number</h2><p>设计 InnoDB 的大叔为记录已经写入的 redo 日志 量，设计了一个称之为<code>Log Sequeue Number</code>的全局变量，翻译过来就是： 日志序列号 ，<strong>简称 lsn 。</strong></p><h2 id="checkpoint" tabindex="-1"><a class="header-anchor" href="#checkpoint" aria-hidden="true">#</a> checkpoint</h2><p>有一个很不幸的事实就是我们的 redo 日志文件组容量是有限的，我们不得不选择循环使用 redo 日志文件组中的 文件，但是这会造成最后写的 redo 日志与最开始写的 redo 日志 追尾 ，这时应该想到：**redo日志只是为了系统 奔溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统奔溃，那么在重启后也用不着 使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的 redo日志所重用。**也就是说：<strong>判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经 刷新到磁盘里。</strong></p><h2 id="崩溃恢复" tabindex="-1"><a class="header-anchor" href="#崩溃恢复" aria-hidden="true">#</a> 崩溃恢复</h2><p>在服务器不挂的情况下， redo 日志简直就是个大累赘，不仅没用，反而让性能变得更差。</p><p>万一数据库挂了，那 redo 日志可是个宝了，我们就可以在重启时根据 redo 日志中的记录就可以将页面恢复 到系统奔溃前的状态。</p><p>下面我们来看下恢复过程是啥样的</p><h3 id="确定恢复的起点" tabindex="-1"><a class="header-anchor" href="#确定恢复的起点" aria-hidden="true">#</a> 确定恢复的起点</h3><p>checkpoint_lsn 之前的 redo 日志都可以被覆盖，也就是说这些 redo 日志对应的脏页都已经被 刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。</p><p><strong>对于 checkpoint_lsn 之后的 redo 日志，它 们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从 checkpoint_lsn 开始读取 redo 日志 来恢复页面。</strong></p><h3 id="确定恢复的终点" tabindex="-1"><a class="header-anchor" href="#确定恢复的终点" aria-hidden="true">#</a> 确定恢复的终点</h3><p>redo 日志恢复的起点确定了，那终点是哪个呢？这个还得从block的结构说起。我们说在写 redo 日志的时候都 是顺序写的，写满了一个block之后会再往下一个block中写：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220930190354694.png" alt="image-20220930190354694" tabindex="0" loading="lazy"><figcaption>image-20220930190354694</figcaption></figure><p>普通block的 log block header 部分有一个称之为 LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前block 里使用了多少字节的空间。对于被填满的block来说，该值永远为 512 。如果该属性的值不为 512 ，那么就是它 了，它就是此次奔溃恢复中需要扫描的最后一个block</p><h3 id="怎么恢复" tabindex="-1"><a class="header-anchor" href="#怎么恢复" aria-hidden="true">#</a> 怎么恢复</h3><p>确定了需要扫描哪些 redo 日志进行奔溃恢复之后，接下来就是怎么进行恢复了。假设现在的 redo 日志文件中有 5条 redo 日志</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220930191159672.png" alt="image-20220930191159672" tabindex="0" loading="lazy"><figcaption>image-20220930191159672</figcaption></figure><p>由于 redo 0 在 checkpoint_lsn 后边，恢复时可以不管它。我们现在可以按照 redo 日志的顺序依次扫描 checkpoint_lsn 之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。这样没什么问题，不过 设计 InnoDB 的大叔还是想了一些办法加快这个恢复的过程：</p><ul><li>使用哈希表</li></ul><p>根据 redo 日志的 space ID 和 page number 属性计算出散列值，把 space ID 和 page number 相同的 redo 日志放到哈希表的同一个槽里，如果有多个 space ID 和 page number 都相同的 redo 日志，那么它们之间 使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20220930191559930.png" alt="image-20220930191559930" tabindex="0" loading="lazy"><figcaption>image-20220930191559930</figcaption></figure><p>之后就可以遍历哈希表，因为对同一个页面进行修改的 redo 日志都放在了一个槽里，所以可以一次性将一 个页面修复好（避免了很多读取页面的随机IO），这样可以加快恢复速度。</p><ul><li>跳过已经刷新到磁盘的页面</li></ul><p>我们前边说过， checkpoint_lsn 之前的 redo 日志对应的脏页确定都已经刷到磁盘了，但是 checkpoint_lsn 之后的 redo 日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次 checkpoint 后，可能后台线程又不断的从 LRU链表 和 flush链表 中将一些脏页刷出 Buffer Pool 。这些 在 checkpoint_lsn 之后的 redo 日志，如果它们对应的脏页在奔溃发生时已经刷新到磁盘，那在恢复时也就 没有必要根据 redo 日志的内容修改该页面了。</p>`,154),d=[n];function t(g,l){return i(),o("div",null,d)}const p=e(r,[["render",t],["__file","redo日志.html.vue"]]);export{p as default};
