import{ac as a,F as i,G as e,ad as o}from"./framework-f12b30cc.js";const t={},n=o('<h2 id="一、基础知识" tabindex="-1"><a class="header-anchor" href="#一、基础知识" aria-hidden="true">#</a> 一、基础知识</h2><h3 id="_1-1-分布式系统定义" tabindex="-1"><a class="header-anchor" href="#_1-1-分布式系统定义" aria-hidden="true">#</a> 1.1 分布式系统定义</h3><blockquote><p>随着业务量的增大，我们不可能把所有的功能都放在一台服务器上，所以我们用很多台服务器每个服务器上都放一点服务，把业务分散在多台主机上。分布在多个主机上也不行啊，怎么处理它们之间的关系呢？</p><p>没错，这个管理者就是我们今天的主角------》Dubbo</p></blockquote><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311091829712.png" alt="image-20220311091829712" tabindex="0" loading="lazy"><figcaption>image-20220311091829712</figcaption></figure><h3 id="_1-2-应用架构的演变" tabindex="-1"><a class="header-anchor" href="#_1-2-应用架构的演变" aria-hidden="true">#</a> 1.2 应用架构的演变</h3><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311092606952.png" alt="image-20220311092606952" tabindex="0" loading="lazy"><figcaption>image-20220311092606952</figcaption></figure><h4 id="_1-2-1-单一应用架构" tabindex="-1"><a class="header-anchor" href="#_1-2-1-单一应用架构" aria-hidden="true">#</a> 1.2.1 单一应用架构</h4><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311092550310.png" alt="image-20220311092550310" tabindex="0" loading="lazy"><figcaption>image-20220311092550310</figcaption></figure><h4 id="_1-2-2-垂直应用架构" tabindex="-1"><a class="header-anchor" href="#_1-2-2-垂直应用架构" aria-hidden="true">#</a> 1.2.2 垂直应用架构</h4><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311093233072.png" alt="image-20220311093233072" tabindex="0" loading="lazy"><figcaption>image-20220311093233072</figcaption></figure><h4 id="_1-2-3-分布式应用架构" tabindex="-1"><a class="header-anchor" href="#_1-2-3-分布式应用架构" aria-hidden="true">#</a> 1.2.3 分布式应用架构</h4><blockquote><p>RPC：分布式服务框架</p><p>主要解决不同服务器之间的远程调用问题</p></blockquote><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311093815885.png" alt="image-20220311093815885" tabindex="0" loading="lazy"><figcaption>image-20220311093815885</figcaption></figure><h4 id="_1-2-4-流动计算架构" tabindex="-1"><a class="header-anchor" href="#_1-2-4-流动计算架构" aria-hidden="true">#</a> 1.2.4 流动计算架构</h4><blockquote><p>分布式架构还存在问题就是资源调度问题，某个服务器请求突然多了，某个服务器很少请求。那么如何协调它们的资源呢，让闲着的帮忙的干点事</p><p>之后呢，出现了流动计算机架构。引入了调度中心能解决资源调度问题</p></blockquote><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311093940746.png" alt="image-20220311093940746" tabindex="0" loading="lazy"><figcaption>image-20220311093940746</figcaption></figure><h3 id="_1-3-rpc" tabindex="-1"><a class="header-anchor" href="#_1-3-rpc" aria-hidden="true">#</a> 1.3 RPC</h3><h4 id="_1-3-1-什么是rpc" tabindex="-1"><a class="header-anchor" href="#_1-3-1-什么是rpc" aria-hidden="true">#</a> 1.3.1 什么是RPC？</h4><blockquote><p>将java对象转化为字节流的过程就叫序列化</p><p>将字节流转化为java对象的过程就叫反序列化</p><p>当java对象需要在网络上进行传输或者持久化存储到文件中，就需要对java对象进行序列化</p><p>对于一个RPC框架好坏的评判就是建立起网络连接的速度快不快，序列化与反序列化的速度快不快</p><p><strong>简而言之RPC的核心模块就是：通讯，序列化</strong></p></blockquote><p>RPC（Remote Producedure Call）是指远程过程调用，是一种进程间的通信方式，它是一种技术思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311095443427.png" alt="image-20220311095443427" tabindex="0" loading="lazy"><figcaption>image-20220311095443427</figcaption></figure><h4 id="_1-3-2-实例" tabindex="-1"><a class="header-anchor" href="#_1-3-2-实例" aria-hidden="true">#</a> 1.3.2 实例</h4><p>客户端A想调用客户端b的方法，那么要经过如下过程</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311100620495.png" alt="image-20220311100620495" tabindex="0" loading="lazy"><figcaption>image-20220311100620495</figcaption></figure><h3 id="_1-4-dubbo简介" tabindex="-1"><a class="header-anchor" href="#_1-4-dubbo简介" aria-hidden="true">#</a> 1.4 dubbo简介</h3><p>面向接口代理：</p><p>类似与mybatis一样，直接调用接口中的方法。不关注内部实现细节</p><p>负载均衡：</p><p>根据服务器的状态，将流量负载到多台服务器上减轻服务器压力</p><p>服务自动注册与发现：</p><p>将服务器都注册到注册中心中，服务上下线都会实时感知。有了注册中心服务调度之间就会很方便，要调用什么服务就去注册中心中去查找。</p><p>可以想象我们现实生活中的婚介公司，里面有很多人注册了信息，你想找什么样的去打电话，吃饭看电影....这样有了婚介公司就对我们找对象很方便了不是~</p><p>同理注册中心也是一样，有了注册中心服务之间的关系就会变得很清晰，很容易找到之间的关系</p><p>高度可扩展能力：</p><blockquote><p>内核是计算机上配置的底层软件，是OS最基本、最核心的部分</p><p>微内核：只包含基础功能的内核部分（必不可少），时钟管理、中断处理、原语</p></blockquote><p>Dubbot遵循微内核+插件的方式，有很强的扩展能力</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311102425482.png" alt="image-20220311102425482" tabindex="0" loading="lazy"><figcaption>image-20220311102425482</figcaption></figure><p>运行期流行调度</p><blockquote><p>灰度发布：就是将新功能先上线部分服务器，这一部分服务器用着没问题了，在发布到其余服务器上</p></blockquote><p>可视化的服务治理与运维</p><p>就是一个可视化的监控平台嘛</p><h3 id="_1-5-dubbot设计架构" tabindex="-1"><a class="header-anchor" href="#_1-5-dubbot设计架构" aria-hidden="true">#</a> 1.5 Dubbot设计架构</h3><blockquote><p>长连接：指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发送链路检测包</p><p>短连接：短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。</p></blockquote><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311121927522.png" alt="image-20220311121927522" tabindex="0" loading="lazy"><figcaption>image-20220311121927522</figcaption></figure><ul><li><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li><li><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li><li><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</li></ul><h4 id="_1-5-1-调用关系说明" tabindex="-1"><a class="header-anchor" href="#_1-5-1-调用关系说明" aria-hidden="true">#</a> 1.5.1 调用关系说明</h4><ol><li>服务容器负责启动，加载，运行服务提供者</li><li>服务提供者在启动时，向注册中心注册自己所提供的服务</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送更新给消费者</li><li>服务消费者，从提供地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="_1-6-zookeeper注册中心" tabindex="-1"><a class="header-anchor" href="#_1-6-zookeeper注册中心" aria-hidden="true">#</a> 1.6 Zookeeper注册中心</h3><p>下载安装包，解压安装即可</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311121201229.png" alt="image-20220311121201229" tabindex="0" loading="lazy"><figcaption>image-20220311121201229</figcaption></figure><p>我们这里只把zk当做注册中心来用，详细的教程后面会出</p><h3 id="_1-7-管理控制台" tabindex="-1"><a class="header-anchor" href="#_1-7-管理控制台" aria-hidden="true">#</a> 1.7 管理控制台</h3><blockquote><p><strong>开启zookeeper服务</strong></p><p>部署在windows服务器上，运行jar包即可</p></blockquote><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p><p>java -jar 包名</p><p>账号密码都是root</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220311124016060.png" alt="image-20220311124016060" tabindex="0" loading="lazy"><figcaption>image-20220311124016060</figcaption></figure>',57),r=[n];function p(g,c){return i(),e("div",null,r)}const l=a(t,[["render",p],["__file","1.Dubbo.html.vue"]]);export{l as default};
