import{ac as a,F as n,G as i,ad as s}from"./framework-f12b30cc.js";const e={},p=s(`<h1 id="三、b-树索引" tabindex="-1"><a class="header-anchor" href="#三、b-树索引" aria-hidden="true">#</a> 三、B+树索引</h1><p>各个数据页可以组成一个 双向链表 ，而每个数据页 中的记录会按照主键值从小到大的顺序组成一个 单向链表 ，每个数据页都会为存储在它里边儿的记录生成一个 页目录 ，<strong>在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对 应分组中的记录即可快速找到指定的记录</strong></p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905220432937.png" alt="image-20220905220432937" tabindex="0" loading="lazy"><figcaption>image-20220905220432937</figcaption></figure><h2 id="没有索引的查找" tabindex="-1"><a class="header-anchor" href="#没有索引的查找" aria-hidden="true">#</a> 没有索引的查找</h2><p>本集的主题是 索引 ，在正式介绍 索引 之前，我们需要了解一下没有索引的时候是怎么查找记录的。为了方便大 家理解，我们下边先只唠叨搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于 = 连接 起的表达式，比如这样：</p><p>SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</p><h3 id="在一个页中的查找" tabindex="-1"><a class="header-anchor" href="#在一个页中的查找" aria-hidden="true">#</a> 在一个页中的查找</h3><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同 分为两种情况：</p><ul><li>以主键为搜索条件</li></ul><p>这个查找过程我们已经很熟悉了，可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应 分组中的记录即可快速找到指定的记录。</p><ul><li>以其他列作为搜索条件</li></ul><p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的 页目录 ，所以 我们无法通过二分法快速定位相应的 槽 。这种情况下只能**从 最小记录 开始依次遍历单链表中的每条记录， 然后对比每条记录是不是符合搜索条件。**很显然，这种查找的效率是非常低的。</p><h3 id="在很多页中查找" tabindex="-1"><a class="header-anchor" href="#在很多页中查找" aria-hidden="true">#</a> 在很多页中查找</h3><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话 可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，**由于我们并不能快速的定位到记录所在的 页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的 记录。**因为要遍历所有的数据页，所以这种方式显然是超级耗时的，如果一个表有一亿条记录，使用这种方式去 查找记录那要等到猴年马月才能等到查找结果。所以祖国和人民都在期盼一种能高效完成搜索的方法， 索引 同 志就要亮相登台了。</p><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo<span class="token punctuation">(</span>
	c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>
	c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
	c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>
<span class="token punctuation">)</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个新建的 index_demo 表中有2个 INT 类型的列，1个 CHAR(1) 类型的列，而且我们规定了 c1 列为主键，这个 表使用 Compact 行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下 index_demo 表的行格式示 意图：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103304357.png" alt="image-20220909103304357" tabindex="0" loading="lazy"><figcaption>image-20220909103304357</figcaption></figure><p>我们只在示意图里展示记录的这几个部分：</p><ul><li>record_type ：记录头信息的一项属性，<strong>表示记录的类型</strong>， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 我们还没用过，等会再说～</li><li>next_record ：记录头信息的一项属性，<strong>表示下一条地址相对于本条记录的地址偏移量</strong>，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</li><li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>为了节省篇幅，我们之后的示意图中会把记录的 其他信息 这个部分省略掉，因为它占地方并且不会有什么观赏 效果。另外，为了方便理解，我们觉得把记录竖着放看起来感觉更好，所以将记录格式示意图的 其他信息 去掉 并把它竖起来的效果就是这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103430969.png" alt="image-20220909103430969" tabindex="0" loading="lazy"><figcaption>image-20220909103430969</figcaption></figure><p>把一些记录放到页里边的示意图就是：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103450825.png" alt="image-20220909103450825" tabindex="0" loading="lazy"><figcaption>image-20220909103450825</figcaption></figure><h3 id="一个简单的索引方案" tabindex="-1"><a class="header-anchor" href="#一个简单的索引方案" aria-hidden="true">#</a> 一个简单的索引方案</h3><p>回到正题，我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？**因为各个页中的记录并没有 规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 不得不 依次遍历所有的数据页。**所以如果我们 想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位 置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完 成下边这些事儿：</p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li></ul><p>为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个 数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 index_demo 表插入3条记录：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;u&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">&#39;d&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;y&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103720390.png" alt="image-20220909103720390" tabindex="0" loading="lazy"><figcaption>image-20220909103720390</figcaption></figure><p>从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为 10 的数据页中了。此时我们再来插入 一条记录：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为 页10 最多只能放3条记录，所以我们不得不再分配一个新页：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103749373.png" alt="image-20220909103749373" tabindex="0" loading="lazy"><figcaption>image-20220909103749373</figcaption></figure><p><strong>新分配的数据页编号可能并不是连续的，也 就是说我们使用的这些页在存储空间里可能并不挨着。<strong>它们只是通过维护着上一个页和下一个页的编号而建 立了链表关系。另外， 页10 中用户记录最大的主键值是 5 ，而 页28 中有一条记录的主键值是 4 ，因为 5 &gt; 4 ，所以这就不符合</strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求</strong>，所 以在插入主键值为 4 的记录的时候需要伴随着一次记录移动，也就是把主键值为 5 的记录移动到 页28 中， 然后再把主键值为 4 的记录插入到 页10 中，这个过程的示意图如下：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103854702.png" alt="image-20220909103854702" tabindex="0" loading="lazy"><figcaption>image-20220909103854702</figcaption></figure><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保 证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程 我们也可以称为 <strong>页分裂</strong> 。</p><ul><li>给所有的页建立一个目录项。</li></ul><p>由于数据页的编号可能并不是连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p><p><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909104015824.png" alt="image-20220909104015824" loading="lazy">因为这些 16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所 在的页，我们需要给它们做个目录，<strong>每个页对应一个目录项</strong>，每个目录项包括下边两个部分：</p><ol><li>页的用户记录中最小的主键值，我们用 key 来表示。</li><li>页号，我们用 page_no 表示。</li></ol><p>所以我们为上边几个页做好的目录就像这样子：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909104055618.png" alt="image-20220909104055618" tabindex="0" loading="lazy"><figcaption>image-20220909104055618</figcaption></figure><p>以 页28 为例，它对应 目录项5 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键 值 5 。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现<strong>根 据主键值</strong>快速查找某条记录的功能了。比方说我们想找主键值为 20 的记录，具体查找过程分两步：</p><ul><li>先从目录项中根据二分法快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对 应的页是 页9 。</li><li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li></ul><p>至此，针对数据页做的简易目录就搞定了。不过忘了说了，<strong>这个 目录 有一个别名，称为 索引</strong> !!!</p><p>写的太好了，通俗易懂！</p><h3 id="innodb中的索引方案" tabindex="-1"><a class="header-anchor" href="#innodb中的索引方案" aria-hidden="true">#</a> InnoDB中的索引方案</h3><p>上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录 项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p><ul><li>InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证 16KB 的连续存储空间，而随着表中记 录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现 实的。</li><li>我们时常会对记录进行增删，假设我们把 页28 中的记录都删除了， 页28 也就没有存在的必要了，那意味 着 目录项2 也就没有存在的必要了，这就需要把 目录项2 后的目录项都向前移动一下，这种牵一发而动全身 的设计不是什么好主意～</li></ul><p>所以，设计 InnoDB 的大叔们需要一种可以灵活管理所有 目录项 的方式。他们灵光乍现，忽然发现这些 目录项 其实长得跟我们的用户记录差不多，只不过 目录项 中的两个列是 主键 和 页号 而已，所以他们<strong>复用了之前存储 用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为</strong> 目录项记 录 。那 InnoDB 怎么区分一条记录是普通的 用户记录 还是 目录项记录 呢？别忘了记录头信息里的 record_type 属性，它的各个取值代表的意思如下：</p><ul><li>0 ：普通的用户记录</li><li>1 ：目录项记录</li><li>2 ：最小记录</li><li>3 ：最大记录</li></ul><p>哈哈，原来这个值为 1 的 record_type 是这个意思呀，我们把前边使用到的目录项放到数据页中的样子就是这样：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909111136827.png" alt="image-20220909111136827" tabindex="0" loading="lazy"><figcaption>image-20220909111136827</figcaption></figure><p>从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储 目录项记录 。这里再次强调一遍 目录项记录 和普通的 用户记录 的不同点：</p><ul><li>目录项记录 的 record_type 值是1，而普通用户记录的 record_type 值是0。</li><li>目录项记录 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。</li><li>还记得我们之前在唠叨记录头信息的时候说过一个叫 min_rec_mask 的属性么，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。</li></ul><p>除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是 0x45BF ，这个属性在 File Header 中，忘了的话可以翻到前边的文章看），页的组成结构也是一样一样的（就是我们前边介绍过的7个部 分），都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用二分法来加快查 询速度。现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储 目录项记录 的页，也就是页 30 中通过二分法快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所 以定位到对应的记录所在的页就是 页9 。</li><li>再到存储用户记录的 页9 中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p>虽然说 目录项记录 中<strong>只存储主键值和对应的页号</strong>，比用户记录需要的存储空间小多了，但是不论怎么说一个页 只有 16KB 大小，能存放的 目录项记录 也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有 的 目录项记录 ，该咋办呢？</p><p>当然是再多整一个存储 目录项记录 的页喽～ 为了大家更好的理解新分配一个 目录项记录 页的过程，我们假设 一个存储 目录项记录 的页最多只能存放4条 目录项记录 （请注意是假设哦，真实情况下可以存放好多条的）， 所以如果此时我们再向上图中插入一条主键值为 320 的用户记录的话，那就需要分配一个新的存储 目录项记录 的页喽：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909112818810.png" alt="image-20220909112818810" tabindex="0" loading="lazy"><figcaption>image-20220909112818810</figcaption></figure><p>从图中可以看出，我们插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 页31 。</li><li>因为原先存储 目录项记录 的 页30 的容量已满（我们前边假设只能存储4条 目录项记录 ），所以不得不需要一个新的 页32 来存放 页31 对应的目录项。</li></ul><p>现在因为存储 目录项记录 的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查 找主键值为 20 的记录为例：</p><ol><li><p>确定 目录项记录 页 我们现在的存储 目录项记录 的页有两个，即 页30 和 页32 ，又因为 页30 表示的目录项的主键值的范围是 [1, 320) ， 页32 表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目录项记录在 页30 中。</p></li><li><p>通过 目录项记录 页确定用户记录真实所在的页。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了，不赘述了～</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。 在一个存储用户记录的页中通过主键值定位一条用户记录的方式已经说过200遍了，你再不会我就，我就， 我就求你到上一篇唠叨数据页结构的文章中多看几遍，求你了～哈哈哈卑微作者在线卖萌</p></li></ol><p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储 目录项记录 的页，但是这些页在存储空间中也可能 不挨着，如果我们表中的数据非常多则会产生很多存储 目录项记录 的页，那我们怎么根据主键值快速定位一个 存储 目录项记录 的页呢？其实也简单，为这些存储 目录项记录 的页再生成一个更高级的目录，就像是一个多级 目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909113040759.png" alt="image-20220909113040759" tabindex="0" loading="lazy"><figcaption>image-20220909113040759</figcaption></figure><p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表 页30 和 页32 ，如果用户记录 的主键值在 [1, 320) 之间，则到 页30 中查找更详细的 目录项记录 ，如果主键值不小于 320 的话，就到 页32 中查找更详细的 目录项记录 。不过这张图好漂亮喔，随着表中记录的增加，这个目录的层级会继续增加，如果 简化一下，那么我们可以用下边这个图来描述它：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909113114301.png" alt="image-20220909113114301" tabindex="0" loading="lazy"><figcaption>image-20220909113114301</figcaption></figure><p>这玩意儿像不像一个倒过来的 树 呀，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种 数据结构，它的名称是 B+ 树。</p><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 B+ 树这个数据结构中了， 所以我们也称这些数据页为 节点 。从图中可以看出来，我们的<strong>实际用户记录其实都存放在B+树的最底层的节点 上</strong>，这些节点也被称为 叶子节点 或 叶节点 ，其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点 ，其 中 B+ 树最上边的那个节点也称为 根节点 。</p><p>从图中可以看出来，一个 B+ 树的节点其实可以分成好多层，设计 InnoDB 的大叔们为了讨论方便，规定最下边的 那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前的讨论我们做了一个非常极端的假设： 存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录 数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有 存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p><ul><li>如果 B+ 树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果 B+ 树有2层，最多能存放 1000×100=100000 条记录。</li><li>如果 B+ 树有3层，最多能存放 1000×1000×100=100000000 条记录。</li><li>如果 B+ 树有4层，最多能存放 1000×1000×1000×100=100000000000 条记录。哇咔咔～这么多的记录！！！</li></ul><p>你的表里能存放 100000000000 条记录么？所以一般情况下，我们用到的 B+ 树都不会超过4层，那我们通过主键 值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内 有所谓的 Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么，哈 哈！</p><h3 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h3><p>我们上边介绍的 B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</li></ol><ul><li><p>页内的记录是按照主键的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p></li></ul><ol start="2"><li>B+ 树的叶子节点存储的是完整的用户记录。</li></ol><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p><p>我们把具有这两种特性的 B+ 树称为 <code>聚簇索引 </code>，所有完整的用户记录都存放在这个 <code>聚簇索引 </code>的叶子节点处。这 种 聚簇索引 并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句）， InnoDB 存储引擎会<strong>自动的为我们创建聚簇索引。<strong>另外有趣的一点是，在 InnoDB 存储引擎中， <code>聚簇索引 </code>就是数据的存储方式（所有的用户记录都存储在了 叶子节点 ），也就是所谓的</strong>索引即数据，数据即索引。</strong></p><h3 id="二级索引" tabindex="-1"><a class="header-anchor" href="#二级索引" aria-hidden="true">#</a> 二级索引</h3><p>上边介绍的 聚簇索引 只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照 主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？</p><p>不，我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据 页、页中记录的排序规则，再建一棵 B+ 树，效果如下图所示：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909141730537.png" alt="image-20220909141730537" tabindex="0" loading="lazy"><figcaption>image-20220909141730537</figcaption></figure><p>这个 B+ 树与上边介绍的聚簇索引有几处不同：</p><ul><li><p>使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p>页内的记录是按照 c2 列的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排成一个双向链表。</p></li></ul></li><li><p>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 <code>c2列+主键 </code>这两个列的值。</p></li><li><p>目录项记录中不再是<code> 主键+页号</code> 的搭配，而变成了<code> c2列+页号</code> 的搭配。</p></li></ul><p>所以如果我们现在想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的 值为 4 的记录为例，查找过程如下：</p><ol><li><p>确定 目录项记录 页 根据 根页面 ，也就是 页44 ，可以快速定位到 目录项记录 所在的页为 页42 （因为 2 &lt; 4 &lt; 9 ）。</p></li><li><p>通过 目录项记录 页确定用户记录真实所在的页。 在 页42 中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以 c2 列值为 4 的记录可能分布在多个数据页中，又因为 2 &lt; 4 ≤ 4 ，所以确定实际存储用户记录的页在 页34 和 页35 中。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。 到 页34 和 页35 中定位到具体的记录。</p></li><li><p>但是这个 B+ 树的叶子节点中的记录只存储了 c2 和 c1 （也就是 主键 ）两个列，所以<strong>我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。(回表)</strong></p></li></ol><p>各位各位，看到步骤4的操作了么？我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值， 所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到 <code>聚簇索引 </code>中再查一遍，这个过程也被称 为<code> 回表</code> 。也就是根据 c2 列的值查询一条完整的用户记录需要使用到 2 棵 B+ 树！！！</p><p>为什么我们还需要一次 <code>回表</code> 操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？你说的对，如果把完整 的用户记录放到 <code>叶子节点 </code>是可以不用 <code>回表</code> ，但是太占地方了呀～相当于每建立一棵 B+ 树都需要把所有的用户 记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照 非主键列 建立的 B+ 树需要一次 回表 操作才可 以定位到完整的用户记录，所以这种 B+ 树也被称为<code>二级索引</code>（英文名 secondary index ），或者 <code>辅助索引 </code>。 由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树为<strong>为c2列建立的索引。</strong></p><h3 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照 c2 列进行排序。</li><li>在记录的 c2 列相同的情况下，采用 c3 列进行排序</li></ul><p>为 c2 和 c3 列建立的索引的示意图如下：</p><figure><img src="https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909142545170.png" alt="image-20220909142545170" tabindex="0" loading="lazy"><figcaption>image-20220909142545170</figcaption></figure><p>如图所示，我们需要注意一下几点：</p><ul><li>每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。</li><li>B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。</li></ul><p>千万要注意一点，<strong>以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的</strong>，不同点如下：</p><ul><li>建立 联合索引 只会建立如上图一样的1棵 B+ 树。</li><li>为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。</li></ul><h3 id="innodb的b-树索引的注意事项" tabindex="-1"><a class="header-anchor" href="#innodb的b-树索引的注意事项" aria-hidden="true">#</a> InnoDB的B+树索引的注意事项</h3><h4 id="根页面万年不动窝" tabindex="-1"><a class="header-anchor" href="#根页面万年不动窝" aria-hidden="true">#</a> 根页面万年不动窝</h4><p>我们前边介绍 B+ 树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画 存储目录项记录的内节点，实际上 B+ 树的形成过程是这样的：</p><ul><li>每当为某个表创建一个 B+ 树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一 个<code> 根节点</code> 页面。最开始表中没有数据的时候，每个 B+ 树索引对应的 根节点 中既没有用户记录，也没有目 录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个 <code>根节点</code> 中。</li><li>当 <code>根节点 </code>中的可用空间用完时继续插入记录，此时会将 根节点 中的所有记录复制到一个新分配的页，比 如 页a 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如 页b 。这时新插入的记录根据键值 （也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 页a 或者 页b 中，而 根节点 便升级为存储目录项记录的页。</li></ul><p>这个过程需要大家特别注意的是：**一个B+树索引的根节点自诞生之日起，便不会再移动。**这样只要我们对某个表 建立一个索引，那么它的 根节点 的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的 时候，都会从那个固定的地方取出 根节点 的页号，从而来访问这个索引。</p><h4 id="一个页面最少存储2条记录" tabindex="-1"><a class="header-anchor" href="#一个页面最少存储2条记录" aria-hidden="true">#</a> 一个页面最少存储2条记录</h4><p>我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上 就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目 录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个 存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以 InnoDB 的 一个数据页至少可以存放两条记录，这也是我们之前唠叨记录行格式的时候说过一个结论（我们当时依据这个结 论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。</p>`,110),o=[p];function l(c,t){return n(),i("div",null,o)}const d=a(e,[["render",l],["__file","3.B_树索引.html.vue"]]);export{d as default};
