import{ac as i,F as p,G as o,D as a,R as n,M as t,ad as e,V as l}from"./framework-f12b30cc.js";const r={},c=e(`<h1 id="mvcc原理" tabindex="-1"><a class="header-anchor" href="#mvcc原理" aria-hidden="true">#</a> MVCC原理</h1><h2 id="版本链" tabindex="-1"><a class="header-anchor" href="#版本链" aria-hidden="true">#</a> 版本链</h2><p>我们前边说过，对于使用 InnoDB 存储引擎的表来说，<strong>它的聚簇索引记录中都包含两个必要的隐藏列</strong>（ row_id 并 不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含 row_id 列）：</p><ul><li><strong>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。</strong></li><li><strong>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏 列就相当于一个指针，可以通过它来找到该记录修改前的信息。</strong></li></ul><p>比方说我们的表 hero 现在只包含一条记录：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------+--------+---------+</span>
<span class="token operator">|</span> number <span class="token operator">|</span> name <span class="token operator">|</span> country <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------+--------+---------+</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> 刘备 <span class="token operator">|</span> 蜀 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------+--------+---------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.07</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设插入该记录的 事务id 为 80 ，那么此刻该条记录的示意图如下所示：<img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221026093301002.png" alt="image-20221026093301002" loading="lazy"></p><p>假设之后两个 事务id 分别为 100 、 200 的事务对这条记录进行 UPDATE 操作，操作流程如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221026093323415.png" alt="image-20221026093323415" tabindex="0" loading="lazy"><figcaption>image-20221026093323415</figcaption></figure><p>每次对记录进行改动，都会记录一条 undo日志 ，每条 undo日志 也都有一个 roll_pointer 属性（ INSERT 操作 对应的 undo日志 没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志 都连起来，串成一个链表，所以现在的情况就像下图一样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221026093342990.png" alt="image-20221026093342990" tabindex="0" loading="lazy"><figcaption>image-20221026093342990</figcaption></figure><p>对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多， 所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 <code>版本链</code> ，<strong>版本链的头节点就是当 前记录最新的值</strong>。另外，每个版本中还包含生成该版本时对应的 事务id ，这个信息很重要，我们稍后就会用到。</p><h2 id="readview" tabindex="-1"><a class="header-anchor" href="#readview" aria-hidden="true">#</a> ReadView</h2><p>对于使用 <code>READ UNCOMMITTED </code>隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录 的最新版本就好了；对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，设计 InnoDB 的大叔规定使用加锁的方式来访 问记录;对于使用 <code>READ COMMITTED</code> 和<code> REPEATABLE READ</code> 隔离级别的事务来 说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交， 是不能直接读取最新版本的记录的，核心问题就是：**需要判断一下版本链中的哪个版本是当前事务可见的。**为 此，设计 InnoDB 的大叔提出了一个 <code>ReadView </code>的概念，这个 ReadView 中主要包含4个比较重要的内容：</p><ul><li><p>m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的 事务id 列表。</p></li><li><p>min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最小值。</p></li><li><p>max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。</p><blockquote><p>小贴士： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p></blockquote></li><li><p>creator_trx_id ：表示生成该 ReadView 的事务的 事务id 。</p></li></ul><blockquote><p>小贴士： 我们前边说过，<strong>只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会 为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</strong></p></blockquote><p>有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断 可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对 该事务完全不可见，查询结果就不包含该记录。</p><p>在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的 时机不同。我们还是以表 hero 为例来，假设现在表 hero 中只有一条由 事务id 为 80 的事务插入的一条记录：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------+--------+---------+</span>
<span class="token operator">|</span> number <span class="token operator">|</span> name <span class="token operator">|</span> country <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------+--------+---------+</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> 刘备 <span class="token operator">|</span> 蜀 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------+--------+---------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.07</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来看一下 READ COMMITTED 和 REPEATABLE READ 所谓的生成ReadView的时机不同到底不同在哪里.</p><h3 id="read-committed-——-每次读取数据前都生成一个readview" tabindex="-1"><a class="header-anchor" href="#read-committed-——-每次读取数据前都生成一个readview" aria-hidden="true">#</a> READ COMMITTED —— 每次读取数据前都生成一个ReadView</h3><p>比方说现在系统里有两个 事务id 分别为 100 、 200 的事务在执行：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># Transaction 100</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;关羽&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;张飞&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment"># Transaction 200</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>小贴士： 再次强调一遍，事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语 句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在Transaction 200中更新一 些别的表的记录，目的是让它分配事务id。</p></blockquote><p>此刻，表 hero 中 number 为 1 的记录得到的版本链表如下所示：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030185902795.png" alt="image-20221030185902795" tabindex="0" loading="lazy"><figcaption>image-20221030185902795</figcaption></figure><p>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 使用READ COMMITTED隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># SELECT1：Transaction 100、200未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为&#39;刘备&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 SELECT1 的执行过程如下：</p><ul><li>在执行 SELECT 语句时会先生成一个 ReadView ， ReadView 的 m_ids 列表的内容就是 [100, 200] ，min_trx_id 为 100 ， max_trx_id 为 201 ， creator_trx_id 为 0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 &#39;张飞&#39; ，该版本的trx_id 值为 100 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;关羽&#39; ，该版本的 trx_id 值也为 100 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;刘备&#39; ，该版本的 trx_id 值为 80 ，小于 ReadView 中的 min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 &#39;刘备&#39; 的记录。</li></ul><p>之后，我们把 事务id 为 100 的事务提交一下，就像这样：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># Transaction 100</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;关羽&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;张飞&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再到 事务id 为 200 的事务中更新一下表 hero 中 number 为 1 的记录：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># Transaction 200</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;赵云&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;诸葛亮&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此刻，表 hero 中 number 为 1 的记录的版本链就长这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030203335069.png" alt="image-20221030203335069" tabindex="0" loading="lazy"><figcaption>image-20221030203335069</figcaption></figure><p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 使用READ COMMITTED隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># SELECT1：Transaction 100、200均未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为&#39;刘备&#39;</span>
<span class="token comment"># SELECT2：Transaction 100提交，Transaction 200未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为&#39;张飞&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在执行 SELECT 语句时会又会单独生成一个 ReadView ，该 ReadView 的 m_ids 列表的内容就是 [200] （ 事务id 为 100 的那个事务已经提交了，所以再次生成快照时就没有它了）， min_trx_id 为 200 ，max_trx_id 为 201 ， creator_trx_id 为 0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 &#39;诸葛亮&#39; ，该版本的trx_id 值为 200 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;赵云&#39; ，该版本的 trx_id 值为 200 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;张飞&#39; ，该版本的 trx_id 值为 100 ，小于 ReadView 中的 min_trx_id 值200 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 &#39;张飞&#39; 的记录。</li></ul><p>以此类推，如果之后 事务id 为 200 的记录也提交了，再此在使用 READ COMMITTED 隔离级别的事务中查询表 hero 中 number 值为 1 的记录时，得到的结果就是 &#39;诸葛亮&#39; 了，具体流程我们就不分析了。总结一下就是：<strong>使 用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</strong></p><h3 id="repeatable-read-——-在第一次读取数据时生成一个readview" tabindex="-1"><a class="header-anchor" href="#repeatable-read-——-在第一次读取数据时生成一个readview" aria-hidden="true">#</a> REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</h3><p>对于使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查 询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p>比方说现在系统里有两个 事务id 分别为 100 、 200 的事务在执行</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># Transaction 100</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;关羽&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;张飞&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment"># Transaction 200</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此刻，表 hero 中 number 为 1 的记录得到的版本链表如下所示：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030205921663.png" alt="image-20221030205921663" tabindex="0" loading="lazy"><figcaption>image-20221030205921663</figcaption></figure><p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 使用REPEATABLE READ隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># SELECT1：Transaction 100、200未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为&#39;刘备&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 SELECT1 的执行过程如下：</p><ul><li>在执行 SELECT 语句时会先生成一个 ReadView ， ReadView 的 m_ids 列表的内容就是 [100, 200] ，min_trx_id 为 100 ， max_trx_id 为 201 ， creator_trx_id 为 0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 &#39;张飞&#39; ，该版本的trx_id 值为 100 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;关羽&#39; ，该版本的 trx_id 值也为 100 ，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;刘备&#39; ，该版本的 trx_id 值为 80 ，小于 ReadView 中的 min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 &#39;刘备&#39; 的记录。</li></ul><p>之后，我们把 事务id 为 100 的事务提交一下，就像这样：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># Transaction 100</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;关羽&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;张飞&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再到 事务id 为 200 的事务中更新一下表 hero 中 number 为 1 的记录：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># Transaction 200</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># 更新了一些别的表的记录</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;赵云&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> hero <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">&#39;诸葛亮&#39;</span> <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此刻，表 hero 中 number 为 1 的记录的版本链就长这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030210144487.png" alt="image-20221030210144487" tabindex="0" loading="lazy"><figcaption>image-20221030210144487</figcaption></figure><p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 使用REPEATABLE READ隔离级别的事务</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment"># SELECT1：Transaction 100、200均未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值为&#39;刘备&#39;</span>
<span class="token comment"># SELECT2：Transaction 100提交，Transaction 200未提交</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># 得到的列name的值仍为&#39;刘备&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 SELECT2 的执行过程如下：</p><ul><li>因为当前事务的隔离级别为 REPEATABLE READ ，而之前在执行 SELECT1 时已经生成过 ReadView 了，所以此 时直接复用之前的 ReadView ，之前的 ReadView 的 m_ids 列表的内容就是 [100, 200] ， min_trx_id 为 100 ， max_trx_id 为 201 ， creator_trx_id 为 0 。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 &#39;诸葛亮&#39; ，该版本的 trx_id 值为 200 ，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;赵云&#39; ，该版本的 trx_id 值为 200 ，也在 m_ids 列表内，所以也不符合 要求，继续跳到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;张飞&#39; ，该版本的 trx_id 值为 100 ，而 m_ids 列表中是包含值为 100 的 事务id 的，所以该版本也不符合要求，同理下一个列 name 的内容是 &#39;关羽&#39; 的版本也不符合要求。继续跳 到下一个版本。</li><li>下一个版本的列 name 的内容是 &#39;刘备&#39; ，该版本的 trx_id 值为 80 ，小于 ReadView 中的 min_trx_id 值 100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 c 为 &#39;刘备&#39; 的记录。</li></ul><p>也就是说两次 SELECT 查询得到的结果是重复的，记录的列 c 值都是 &#39;刘备&#39; ，这就是 可重复读 的含义。如果我 们之后再把 事务id 为 200 的记录提交了，然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这 个 number 为 1 的记录，得到的结果还是 &#39;刘备&#39;</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221027093520558.png" alt="image-20221027093520558" tabindex="0" loading="lazy"><figcaption>image-20221027093520558</figcaption></figure><h2 id="可重复读是如何工作的" tabindex="-1"><a class="header-anchor" href="#可重复读是如何工作的" aria-hidden="true">#</a> 可重复读是如何工作的?</h2><p>为了更好的理解MVCC,我们通过图解来加深印象</p><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030231407865.png" alt="image-20221030231407865" tabindex="0" loading="lazy"><figcaption>image-20221030231407865</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030231509320.png" alt="image-20221030231509320" tabindex="0" loading="lazy"><figcaption>image-20221030231509320</figcaption></figure><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li><li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>接下来，跟大家具体分析下。</p><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030232047906.png" alt="image-20221030232047906" tabindex="0" loading="lazy"><figcaption>image-20221030232047906</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030232100507.png" alt="image-20221030232100507" tabindex="0" loading="lazy"><figcaption>image-20221030232100507</figcaption></figure><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p><p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p><h2 id="读提交是如何工作的" tabindex="-1"><a class="header-anchor" href="#读提交是如何工作的" aria-hidden="true">#</a> 读提交是如何工作的？</h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p><ul><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li></ul><p>那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030232442699.png" alt="image-20221030232442699" tabindex="0" loading="lazy"><figcaption>image-20221030232442699</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030232502245.png" alt="image-20221030232502245" tabindex="0" loading="lazy"><figcaption>image-20221030232502245</figcaption></figure><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221030232527163.png" alt="image-20221030232527163" tabindex="0" loading="lazy"><figcaption>image-20221030232527163</figcaption></figure><p>我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？</p><p>事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明<strong>这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录</strong>。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？</p><p>在事务 A 提交后，<strong>由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View</strong>，此时事务 B 第三次读取数据时创建的 Read View 如下：</p><p>事务 B 在找到小林这条记录时，<strong>会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的</strong>。</p><p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><h2 id="mysql-可重复读隔离级别-完全解决幻读了吗" tabindex="-1"><a class="header-anchor" href="#mysql-可重复读隔离级别-完全解决幻读了吗" aria-hidden="true">#</a> MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102200545944.png" alt="image-20221102200545944" tabindex="0" loading="lazy"><figcaption>image-20221102200545944</figcaption></figure><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是原子性、一致性、隔离性、持久性，我们这次主要讲的是隔离性。</p><p>当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。</p><p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p>`,106),d={href:"https://xiaolincoding.com/mysql/transaction/phantom.html",target:"_blank",rel:"noopener noreferrer"},u=e(`<ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p><h1 id="工作面试老大难-锁" tabindex="-1"><a class="header-anchor" href="#工作面试老大难-锁" aria-hidden="true">#</a> 工作面试老大难-锁</h1><h2 id="并发事务访问相同记录的情况" tabindex="-1"><a class="header-anchor" href="#并发事务访问相同记录的情况" aria-hidden="true">#</a> 并发事务访问相同记录的情况</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p><h3 id="读-读-情况" tabindex="-1"><a class="header-anchor" href="#读-读-情况" aria-hidden="true">#</a> 读-读 情况</h3><p>即并发事务相继读取相同的记录。</p><p>读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="写-写-情况" tabindex="-1"><a class="header-anchor" href="#写-写-情况" aria-hidden="true">#</a> <strong>写-写</strong> 情况</h3><p>即并发事务相继对相同的记录做出改动。</p><p>我们前边说过，在这种情况下会发生 <code>脏写</code> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多 个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过<code>锁</code>来实现的。 这个所谓的 锁 其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和 记录进行关联的，如图所示：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102103605944.png" alt="image-20221102103605944" tabindex="0" loading="lazy"><figcaption>image-20221102103605944</figcaption></figure><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构</code> ，当没有的时候就 会在内存中生成一个 <code>锁结构 </code>与之关联。比方说事务 T1 要对这条记录做改动，就需要生成一个 <code>锁结构 </code>与之 关联：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102103832967.png" alt="image-20221102103832967" tabindex="0" loading="lazy"><figcaption>image-20221102103832967</figcaption></figure><p>其实在 <code>锁结构</code> 里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：</p><ul><li>trx信息 ：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等待。</li></ul><p>如图所示，当事务 T1 改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务 为这条记录加锁，所以 is_waiting 属性就是 false ，<strong>我们把这个场景就称之为获取锁成功</strong>，或者加锁 成功，然后就可以继续执行操作了。</p><p>在事务 T1 提交之前，另一个事务 T2 也想对该记录做改动，那么先去看看有没有 <code>锁结构</code> 与这条记录关 联，发现有一个 <code>锁结构</code> 与之关联后，然后也生成了一个 锁结构 与这条记录关联，不过 锁结构 的 is_waiting 属性值为 true ，表示当前事务需要等待，我们把这个场景就称之为<strong>获取锁失败，或者加锁 失败，或者没有成功的获取到锁</strong>，画个图表示就是这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102104114255.png" alt="image-20221102104114255" tabindex="0" loading="lazy"><figcaption>image-20221102104114255</figcaption></figure><p>在事务 T1 提交之后，就会把该事务生成的 锁结构 释放掉，然后看看还有没有别的事务在等待获取锁， 发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 is_waiting 属性设置为 false ，然后 把该事务对应的线程唤醒，让它继续执行，此时事务 T2 就算获取到锁了。效果图就是这样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102104208301.png" alt="image-20221102104208301" tabindex="0" loading="lazy"><figcaption>image-20221102104208301</figcaption></figure><p>我们总结一下后续内容中可能用到的几种说法，以免大家混淆：</p><ul><li>不加锁</li></ul><p>意思就是不需要在内存中生成对应的 <code>锁结构</code> ，可以直接执行操作。</p><ul><li>获取锁成功，或者加锁成功</li></ul><p>意思就是在内存中生成了对应的 <code>锁结构</code> ，而且锁结构的<code>is_waiting</code>属性为<code> false</code> ，也就是事务可以继续执行操作。</p><ul><li>获取锁失败，或者加锁失败，或者没有获取到锁</li></ul><p>意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务需要等待，不可以继续执行操作。</p><blockquote><p>小贴士： 这里只是对锁结构做了一个非常简单的描述，我们后边会详细唠叨唠叨锁结构的，稍安勿躁</p></blockquote><h3 id="读-写-或-写-读-情况" tabindex="-1"><a class="header-anchor" href="#读-写-或-写-读-情况" aria-hidden="true">#</a> 读-写 或 写-读 情况</h3><p>也就是一个事务进行读取操作，另一个进行改动操作。</p><p>我们前边说过，这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。</p><p>SQL标准 规定不同隔离级别下可能发生的问题不一样：</p><ul><li>在 READ UNCOMMITTED 隔离级别下， 脏读 、 不可重复读 、 幻读 都可能发生。</li><li>在 READ COMMITTED 隔离级别下， 不可重复读 、 幻读 可能发生， 脏读 不可以发生。</li><li>在 REPEATABLE READ 隔离级别下， 幻读 可能发生， 脏读 和 不可重复读 不可以发生。</li><li>在 SERIALIZABLE 隔离级别下，上述问题都不可以发生。</li></ul><p>不过各个数据库厂商对 <code>SQL标准 </code>的支持都可能不一样，与 <code>SQL标准</code> 不同的一点就是， <code>MySQL</code> 在<code>REPEATABLE READ</code> 隔离级别实际上就已经解决了 幻读 问题。</p><p>怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有两种可选的解决方案：</p><p><strong>方案一：读操作利用多版本并发控制（ MVCC ），写操作进行 加锁 。</strong></p><p>MVCC我们前面学过,就是生成一个readView,然后通过readview找到符合条件的记录版本(undo 日志),其实就像是在生成ReadView的那个时刻做了一次时间静止(就像用相机拍了一个快照),查询语句只能读到生成ReadView之前已提交事务所做的更改,在生成ReadView之前未提交的事务或者是之后开启的事务所做的更改是看不到的.而写操作肯定是针对的最新版本的记录,读记录的历史版本和改动记录的最新版本本身并不冲突,也就是采用MVCC时,<code>读-写</code>操作并不冲突</p><blockquote><p>Tips:</p><p>在Read COMMIT隔离级别下,一个事务在执行过程中每次执行select语句操作都会生成一个ReadView,ReadView的存在本身就保证了事务不可以读取到未提交事务所做的更改,也就是避免了脏读现象;</p><p>REPEATABLE READ隔离级别下,一个事务在执行过程中只有第一次select才会生成一个ReadView,之后的SELECT操作都重复用这个ReadView,这样也就避免了不可重复读和幻读的问题.</p></blockquote><p><strong>方案二：读、写操作都采用 加锁 的方式</strong></p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银 行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库 中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事 务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行 加锁 操作，这样也就意味着 读 操 作和 写 操作也像 写-写 操作那样排队执行。</p><blockquote><p>Tips:</p><p>我们说脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务 在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有 脏读问题的产生了。</p><p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记 录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录 时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p>我们 说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了 新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录 称之为幻影记录。<strong>采用加锁的方式解决幻读问题就有那么一丢丢麻烦了，因为当前事务在第一 次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点尴尬 —— 因为你并不知道 给谁加锁</strong>，没关系，这难不倒设计InnoDB的大叔的，我们稍后揭晓答案，稍安勿躁。</p></blockquote><p>很明显，采用 MVCC 方式的话， 读-写 操作彼此并不冲突，性能更高，采用 加锁 方式的话， 读-写 操 作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问 题，但是业务在某些特殊情况下，要求必须采用 加锁 的方式执行，那也是没有办法的事。</p><h2 id="解决并发事务带来问题的两种基本方式" tabindex="-1"><a class="header-anchor" href="#解决并发事务带来问题的两种基本方式" aria-hidden="true">#</a> 解决并发事务带来问题的两种基本方式</h2><h3 id="一致性读-consistent-reads" tabindex="-1"><a class="header-anchor" href="#一致性读-consistent-reads" aria-hidden="true">#</a> 一致性读（Consistent Reads）</h3><p>事务利用MVCC进行的读取操作称之为一致性读,或快照读</p><p>所有普通的SELECT 语句（ plain SELECT ）在 READ COMMITTED 、 REPEATABLE READ 隔离级别下都算是 一致性读 ，比方说：</p><p>SELECT * FROM t; SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2</p><p>一致性读 并不会对表中的任何记录做 加锁 操作，其他事务可以自由的对表中的记录做改动。</p><h3 id="锁定读-locking-reads" tabindex="-1"><a class="header-anchor" href="#锁定读-locking-reads" aria-hidden="true">#</a> 锁定读（Locking Reads）</h3><h4 id="共享锁和独占锁" tabindex="-1"><a class="header-anchor" href="#共享锁和独占锁" aria-hidden="true">#</a> 共享锁和独占锁</h4><p>我们前边说过，并发事务的 读-读 情况并不会引起什么问题，不过对于 写-写 、 读-写 或 写-读 这些情况可能 会引起一些问题，需要使用 MVCC 或者 加锁 的方式来解决它们。在使用 加锁 的方式解决问题时，由于既要允 许 读-读 情况不受影响，又要使 写-写 、 读-写 或 写-读 情况中的操作相互阻塞，所以设计 MySQL 的大叔给锁 分了个类：</p><ul><li>共享锁 ，英文名： Shared Locks ，简称 S锁 。在事务要读取一条记录时，需要先获取该记录的 S锁 。</li><li>独占锁 ，也常称 排他锁 ，英文名： Exclusive Locks ，简称 X锁 。在事务要改动一条记录时，需要先获 取该记录的 X锁 。</li></ul><p>假如事务 T1 首先获取了一条记录的 S锁 之后，事务 T2 接着也要访问这条记录：</p><ul><li>如果事务 T2 想要再获取一个记录的 S锁 ，那么事务 T2 也会获得该锁，也就意味着事务 T1 和 T2 在该记录 上同时持有 S锁 。</li><li>如果事务 T2 想要再获取一个记录的 X锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S锁 释放掉。</li></ul><p>如果事务 T1 首先获取了一条记录的 X锁 之后，那么不管事务 T2 接着想获取该记录的 S锁 还是 X锁 都会被阻 塞，直到事务 T1 提交。</p><p>所以我们说 S锁 和 S锁 是兼容的， S锁 和 X锁 是不兼容的， X锁 和 X锁 也是不兼容的，画个表表示一下就是这 样：</p><p>兼容性 X S X 不兼容 不兼容 S 不兼容 兼容</p><h4 id="锁定读的语句" tabindex="-1"><a class="header-anchor" href="#锁定读的语句" aria-hidden="true">#</a> 锁定读的语句</h4><p>我们前边说在采用 加锁 方式解决 脏读 、 不可重复读 、 幻读 这些问题时，读取一条记录时需要获取一下该记 录的 S锁 ，其实这是不严谨的，有时候想在读取记录时就获取记录的 X锁 ，来禁止别的事务读写该记录，为此设 计 MySQL 的大叔提出了两种比较特殊的 SELECT 语句格式：</p><ul><li>对读取的记录加 S锁 ：</li></ul><p>​ SELECT ... LOCK IN SHARE MODE;</p><p>也就是在普通的 SELECT 语句后边加 <code>LOCK IN SHARE MODE</code> ，如果当前事务执行了该语句，那么它会为读取到 的记录加 S锁 ，这样允许别的事务继续获取这些记录的 S锁 （比方说别的事务也使用 SELECT ... LOCK IN SHARE MODE 语句来读取这些记录），但是不能获取这些记录的 X锁 （比方说使用 SELECT ... FOR UPDATE 语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的 X锁 ，那么它们会阻 塞，直到当前事务提交之后将这些记录上的 S锁 释放掉。</p><ul><li><p>对读取的记录加 X锁 ：</p><p>SELECT ... FOR UPDATE;</p></li></ul><p>也就是在普通的 SELECT 语句后边加 <code>FOR UPDATE </code>，如果当前事务执行了该语句，那么它会为读取到的记录 加 X锁 ，这样既不允许别的事务获取这些记录的 S锁 （比方说别的事务使用 SELECT ... LOCK IN SHARE MODE 语句来读取这些记录），也不允许获取这些记录的 X锁 （比方也说使用 SELECT ... FOR UPDATE 语句 来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的 S锁 或者 X锁 ，那么它们会 阻塞，直到当前事务提交之后将这些记录上的 X锁 释放掉。</p><h3 id="写操作" tabindex="-1"><a class="header-anchor" href="#写操作" aria-hidden="true">#</a> 写操作</h3><p>平常所用到的 写操作 无非是<code> DELETE 、 UPDATE 、 INSERT</code>这三种：</p><ul><li><p>DELETE ：</p><ul><li>对一条记录做 DELETE 操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取一下这条记录的 X锁 ，然后再执行 delete mark 操作。我们也可以把这个定位待删除记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 。</li></ul></li><li><p>UPDATE ：</p><ul><li><p>在对一条记录做 UPDATE 操作时分为三种情况：</p><ul><li><p>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X锁 ，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 。</p></li><li><p>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+ 树中定位到这条记录的位置，然后获取一下记录的 X锁 ，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 ，新插入的记录由 INSERT 操作提供的 隐式锁 进行保护。</p></li><li><p>如果修改了该记录的键值，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT 操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。</p></li></ul></li></ul></li><li><p>INSERT ：</p><ul><li>一般情况下，新插入一条记录的操作并不加锁，设计 InnoDB 的大叔通过一种称之为 隐式锁(MDL) 的东东来保护这条新插入的记录在本事务提交前不被别的事务访问，更多细节我们后边看哈～</li></ul></li></ul><blockquote><p>Tips： 当然，在一些特殊情况下INSERT操作也是会获取锁的，具体情况我们后边唠叨。</p></blockquote><h2 id="多粒度锁" tabindex="-1"><a class="header-anchor" href="#多粒度锁" aria-hidden="true">#</a> 多粒度锁</h2><p>我们前边提到的 锁 都是针对记录的，也可以被称之为 行级锁 或者 行锁 ，对一条记录加锁影响的也只是这条记 录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在 表 级别进行加锁，自然就被称之为 表级锁 或 者 表锁 ，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为 共享锁 （ S锁 ）和 独占锁 （ X锁 ）：</p><ul><li>给表加 S锁 ： <ul><li>如果一个事务给表加了 S锁 ，那么： <ul><li>别的事务可以继续获得该表的 S锁</li><li>别的事务可以继续获得该表中的某些记录的 S锁</li><li>别的事务不可以继续获得该表的 X锁</li><li>别的事务不可以继续获得该表中的某些记录的 X锁</li></ul></li></ul></li><li>给表加 X锁 ： <ul><li>如果一个事务给表加了 X锁 （意味着该事务要独占这个表），那么： <ul><li>别的事务不可以继续获得该表的 S锁</li><li>别的事务不可以继续获得该表中的某些记录的 S锁</li><li>别的事务不可以继续获得该表的 X锁</li><li>别的事务不可以继续获得该表中的某些记录的 X锁</li></ul></li></ul></li></ul><h3 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明" aria-hidden="true">#</a> 举例说明</h3><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102153339119.png" alt="image-20221102153339119" tabindex="0" loading="lazy"><figcaption>image-20221102153339119</figcaption></figure><p>但是这里头有两个问题：</p><ul><li>如果我们想对教学楼整体上 S锁 ，首先需要确保教学楼中的没有正在维修的教室，如果有正在维修的教室， 需要等到维修结束才可以对教学楼整体上S锁 。</li><li>如果我们想对教学楼整体上 X锁 ，首先需要确保教学楼中的没有上自习的教室以及正在维修的教室，如果有 上自习的教室或者正在维修的教室，需要等到全部上自习的同学都上完自习离开，以及维修工维修完教室离 开后才可以对教学楼整体上 X锁 。</li></ul><p>我们在对教学楼整体上锁（ 表锁 ）时，怎么知道教学楼中有没有教室已经被上锁（ 行锁 ）了呢？依次检查每一 间教室门口有没有上锁？那这效率也太慢了吧！<strong>遍历是不可能遍历的，这辈子也不可能遍历的</strong>，于是乎设计 InnoDB 的大叔们提出了一种称之为 <strong><code>意向锁 </code></strong>（英文名： Intention Locks ）的东东：</p><ul><li>意向共享锁，英文名： Intention Shared Lock ，简称 IS锁 。当事务准备在某条记录上加 S锁 时，需要先 在表级别加一个 IS锁 。</li><li>意向独占锁，英文名： Intention Exclusive Lock ，简称 IX锁 。当事务准备在某条记录上加 X锁 时，需 要先在表级别加一个 IX锁 。</li></ul><p>视角回到教学楼和教室上来：</p><ul><li><strong>如果有学生到教室中上自习，那么他先在整栋教学楼门口放一把 IS锁 （表级锁），然后再到教室门口放一 把 S锁 （行锁）。</strong></li><li><strong>如果有维修工到教室中维修，那么它先在整栋教学楼门口放一把 IX锁 （表级锁），然后再到教室门口放一 把 X锁 （行锁）。</strong></li></ul><p>之后：</p><ul><li>如果有领导要参观教学楼，也就是想在教学楼门口前放 S锁 （表锁）时，首先要看一下教学楼门口有没有 IX锁 ，如果有，意味着有教室在维修，需要等到维修结束把 IX锁 撤掉后才可以在整栋教学楼上加 S锁 。</li><li>如果有考试要占用教学楼，也就是想在教学楼门口前放 X锁 （表锁）时，首先要看一下教学楼门口有没有 IS锁 或 IX锁 ，如果有，意味着有教室在上自习或者维修，需要等到学生们上完自习以及维修结束把 IS锁 和 IX锁 撤掉后才可以在整栋教学楼上加 X锁 。</li></ul><blockquote><p>Tips：</p><p>学生在教学楼门口加IS锁时，是不关心教学楼门口是否有IX锁的，维修工在教学楼门口加IX锁时，是不关心教学楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间教学楼里有没有被占用的 教室用的，也就是在对教学楼加S锁或者X锁时才会用到。</p></blockquote><p>总结一下：<strong>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否 被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。我们画个表来看一下表级别的各种锁的兼容性：</strong></p><p>兼容性 X IX S IS X 不兼容 不兼容 不兼容 不兼容 IX 不兼容 兼容 不兼容 兼容 S 不兼容 不兼容 兼容 兼容 IS 不兼容 兼容 兼容 兼容</p><h2 id="mysql中的行锁和表锁" tabindex="-1"><a class="header-anchor" href="#mysql中的行锁和表锁" aria-hidden="true">#</a> MySQL中的行锁和表锁</h2><h3 id="其他存储引擎中的锁" tabindex="-1"><a class="header-anchor" href="#其他存储引擎中的锁" aria-hidden="true">#</a> 其他存储引擎中的锁</h3><p>对于 MyISAM 、 MEMORY 、 MERGE 这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使 用这些存储引擎的锁一般都是针对当前会话来说的。比方说在 Session 1 中对一个表执行 SELECT 操作，就相当 于为这个表加了一个表级别的 S锁 ，如果在 SELECT 操作未完成时， Session 2 中对这个表执行 UPDATE 操作， 相当于要获取表的 X锁 ，此操作会被阻塞，直到 Session 1 中的 SELECT 操作完成，释放掉表级别的 S锁 后， Session 2 中对这个表执行 UPDATE 操作才能继续获取 X锁 ，然后执行具体的更新语句。</p><blockquote><p>Tips：</p><p>因为使用MyISAM、MEMORY、MERGE这些存储引擎的表在同一时刻只允许一个会话对表进行写操作，所以 这些存储引擎实际上最好用在只读，或者大部分都是读操作，或者单用户的情景下。</p></blockquote><h3 id="innodb存储引擎中的锁" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎中的锁" aria-hidden="true">#</a> InnoDB存储引擎中的锁</h3><p>InnoDB 存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要 锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更 精准的并发控制。下边我们详细看一下。</p><h4 id="innodb中的表级锁" tabindex="-1"><a class="header-anchor" href="#innodb中的表级锁" aria-hidden="true">#</a> InnoDB中的表级锁</h4><ul><li>表级别的 S锁 、 X锁</li></ul><p>在对某个表执行 <code>SELECT 、 INSERT 、 DELETE 、 UPDATE</code> 语句时， <strong>InnoDB 存储引擎是不会为这个表添加表 级别的 S锁 或者 X锁 的。</strong></p><p>另外，在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执 行诸如 SELECT 、 INSERT 、 DELETE 、 UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。这个 过程其实是通过在 server层 使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ，简称 MDL ）东东来实 现的，一般情况下也不会使用 InnoDB 存储引擎自己提供的表级别的 S锁 和 X锁 。</p><blockquote><p>Tips：</p><p>在事务简介的章节中我们说过，DDL语句执行时会隐式的提交当前会话中的事务，这主要是DDL语 句的执行一般都会在若干个特殊事务中完成，在开启这些特殊事务前，需要将当前会话中的事务提 交掉。另外，关于MDL锁并不是我们本章所要讨论的范围，大家可以参阅文档了解哈～</p></blockquote><p>其实这个 InnoDB 存储引擎提供的表级 S锁 或者 X锁 是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复 过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量 autocommit=0，innodb_table_locks = 1 时，手动获取 InnoDB 存储引擎提供的表 t 的 S锁 或者 X锁 可以这么写：</p><ul><li>LOCK TABLES t READ ： InnoDB 存储引擎会对表 t 加表级别的 S锁 。</li><li>LOCK TABLES t WRITE ： InnoDB 存储引擎会对表 t 加表级别的 X锁 。</li></ul><p>不过请尽量避免在使用 InnoDB 存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提 供什么额外的保护，只是会降低并发能力而已。 InnoDB 的厉害之处还是实现了更细粒度的行锁，<strong>关于 表级别的 S锁 和 X锁 大家了解一下就罢了。</strong></p><ul><li>表级别的 IS锁 、 IX锁</li></ul><p>当我们在对使用 InnoDB 存储引擎的表的某些记录加 S锁 之前，那就需要先在表级别加一个 IS锁 ，当我们 在对使用 InnoDB 存储引擎的表的某些记录加 X锁 之前，那就需要先在表级别加一个 IX锁 。 **IS锁 和 IX锁 的使命只是为了后续在加表级别的 S锁 和 X锁 时判断表中是否有已经被加锁的记录，以避免用遍历的方式来 查看表中有没有上锁的记录。**更多关于 IS锁 和 IX锁 的解释我们上边都唠叨过了，就不赘述了。</p><ul><li>表级别的 AUTO-INC锁</li></ul><p>在使用 MySQL 过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性，之后在插入记录时，可以不指定 该列的值，系统会自动为它赋上递增的值，比方说我们有一个表：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t <span class="token punctuation">(</span>
 id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
 c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
 <span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于这个表的 id 字段声明了 AUTO_INCREMENT ，也就意味着在书写插入语句时不需要为其赋值，比方说这 样：</p><p>INSERT INTO t(c) VALUES(&#39;aa&#39;), (&#39;bb&#39;);</p><p>上边的插入语句并没有为 id 列显式赋值，所以系统会自动为它赋上递增的值，效果就是这样：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t<span class="token punctuation">;</span>
 <span class="token operator">+</span><span class="token comment">----+------+</span>
 <span class="token operator">|</span> id <span class="token operator">|</span> c <span class="token operator">|</span>
 <span class="token operator">+</span><span class="token comment">----+------+</span>
 <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> aa <span class="token operator">|</span>
 <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> bb <span class="token operator">|</span>
 <span class="token operator">+</span><span class="token comment">----+------+</span>
 <span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>系统实现这种自动给 AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：</p><ul><li>采用 AUTO-INC 锁，也就是在执行插入语句时就在表级别加一个 AUTO-INC 锁，然后为每条待插入记录 的 AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把 AUTO-INC 锁释放掉。这样一个 事务在持有 AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增 值是连续的。</li></ul><p>如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比 方说使用 INSERT ... SELECT 、 REPLACE ... SELECT 或者 LOAD DATA 这种插入语句，一般是使用 AUTO-INC 锁为 AUTO_INCREMENT 修饰的列生成对应的值。</p><blockquote><p>需要注意一下的是，这个AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后， 这个锁就被释放了，</p></blockquote><ul><li>采用一个轻量级的锁，在为插入语句生成 AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁，然 后生成本次插入语句需要用到的 AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到 整个插入语句执行完才释放锁。</li></ul><p>如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表 t 的例子 中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对 AUTO_INCREMENT 修饰的 列进行赋值。这种方式可以避免锁定表，可以提升插入性能。</p><blockquote><p>设计InnoDB的大叔提供了一个称之为innodb_autoinc_lock_mode的系统变量来控制到底使用上 述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值</p><p>当innodb_autoinc_lock_mode值 为0时，一律采用AUTO-INC锁；</p><p>当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁；</p><p>当 innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入记录数量确定时采用轻 量级锁，不确定时使用AUTO-INC锁）</p><p><strong>当innodb_autoinc_lock_mode值为2时，可能会造 成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景 中是不安全的。</strong></p></blockquote><h4 id="innodb中的行级锁-重点" tabindex="-1"><a class="header-anchor" href="#innodb中的行级锁-重点" aria-hidden="true">#</a> InnoDB中的行级锁(重点)</h4><p>真正的重点才刚刚开始!</p><p>行锁 ，也称为 记录锁 ，顾名思义就是在记录上加的锁。不过设计 InnoDB 的大叔很有才，一个 行锁 玩出了各 种花样，也就是把 行锁 分成了各种类型。换句话说即使对同一条记录加 行锁 ，<strong>如果类型不同，起到的功效也是 不同的</strong>.</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161030244.png" alt="image-20221102161030244" tabindex="0" loading="lazy"><figcaption>image-20221102161030244</figcaption></figure><p>我们把 hero 表中的聚簇索引的示意图画一下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161118009.png" alt="image-20221102161118009" tabindex="0" loading="lazy"><figcaption>image-20221102161118009</figcaption></figure><p>当然，我们把 B+树 的索引结构做了一个超级简化，只把索引中的记录给拿了出来，我们这里只是想强调聚簇索 引中的记录是按照主键大小排序的，并且省略掉了聚簇索引中的隐藏列</p><p>现在准备工作做完了，下边我们来看看都有哪些常用的 行锁类型 。</p><h5 id="record-locks-记录锁" tabindex="-1"><a class="header-anchor" href="#record-locks-记录锁" aria-hidden="true">#</a> Record Locks(记录锁)</h5><p>我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上，我决定给这种类型的锁起一个比较不正 经的名字： 正经记录锁 （请允许我皮一下，我实在不知道该叫个啥名好）。官方的类型名称为： LOCK_REC_NOT_GAP 。比方说我们把 number 值为 8 的那条记录加一个 正经记录锁 的示意图如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161317227.png" alt="image-20221102161317227" tabindex="0" loading="lazy"><figcaption>image-20221102161317227</figcaption></figure><p>正经记录锁 是有 S锁 和 X锁 之分的，让我们分别称之为 S型正经记录锁 和 X型正经记录锁 吧（听起来有 点怪怪的），当一个事务获取了一条记录的 S型正经记录锁 后，其他事务也可以继续获取该记录的 S型正经 记录锁 ，但不可以继续获取 X型正经记录锁 ；当一个事务获取了一条记录的 X型正经记录锁 后，其他事务 既不可以继续获取该记录的 S型正经记录锁 ，也不可以继续获取 X型正经记录锁 ；</p><h5 id="gap-locks-间隙锁" tabindex="-1"><a class="header-anchor" href="#gap-locks-间隙锁" aria-hidden="true">#</a> Gap Locks(间隙锁)</h5><p>我们说 MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方 案解决，也可以采用 加锁 方案解决。但是在使用 加锁 方案解决时有个大问题，就是事务在第一次执行读取 操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上 正经记录锁 。不过这难不倒设计 InnoDB 的 大叔，他们提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们也可以简称为 gap 锁 。比方说我们把 number 值为 8 的那条记录加一个 gap锁 的示意图如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161917072.png" alt="image-20221102161917072" tabindex="0" loading="lazy"><figcaption>image-20221102161917072</figcaption></figure><p>如图中为 number 值为 8 的记录加了 gap锁 ，意味着不允许别的事务在 number 值为 8 的记录前边的 间隙 插入新记录，其实就是 number 列的值 (3, 8) 这个区间的新记录是不允许立即插入的。比方说有另外一个事 务再想插入一条 number 值为 4 的新记录，它定位到该条新记录的下一条记录的 number 值为8，而这条记录 上又有一个 gap锁 ，所以就会阻塞插入操作，直到拥有这个 gap锁 的事务提交了之后， number 列的值在区 间 (3, 8) 中的新记录才可以被插入。</p><p>这个 gap锁 的提出<strong>仅仅是为了防止插入幻影记录而提出的</strong>，虽然有 共享gap锁 和 独占gap锁 这样的说法， 但是它们起到的作用都是相同的。而且如果你对一条记录加了 gap锁 （不论是 共享gap锁 还是 独占gap 锁 ），并不会限制其他事务对这条记录加 正经记录锁 或者继续加 gap锁 ，再强调一遍， <strong>gap锁 的作用仅 仅是为了防止插入幻影记录的而已。</strong></p><p>不知道大家发现了一个问题没，给<strong>一条记录加了 gap锁 只是不允许其他事务往这条记录前边的间隙插入新记 录</strong>，那对于最后一条记录之后的间隙，也就是 hero 表中 number 值为 20 的记录之后的间隙该咋办呢？也就 是说给哪条记录加 gap锁 才能阻止其他事务插入 number 值在 (20, +∞) 这个区间的新记录呢？这时候应该 想起我们在前边唠叨 数据页 时介绍的两条伪记录了：</p><ul><li><p><strong>Infimum 记录，表示该页面中最小的记录。</strong></p></li><li><p><strong>Supremum 记录，表示该页面中最大的记录。</strong></p></li></ul><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102162712278.png" alt="image-20221102162712278" tabindex="0" loading="lazy"><figcaption>image-20221102162712278</figcaption></figure><p><strong>Infimum + Supremum 最小记录和最大记录 26 字节 两个虚拟的行记录</strong></p><p>记录在页中的存储如下:</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102162350635.png" alt="image-20221102162350635" tabindex="0" loading="lazy"><figcaption>image-20221102162350635</figcaption></figure><p>为了实现阻止其他事务插入 number 值在 (20, +∞) 这个区间的新记录，我们可以给索引中的最后一条 记录，也就是 number 值为 20 的那条记录所在页面的 <code>Supremum</code> 记录加上一个 gap锁 ，画个图就是这 样：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102162429998.png" alt="image-20221102162429998" tabindex="0" loading="lazy"><figcaption>image-20221102162429998</figcaption></figure><p>这样就可以阻止其他事务插入 number 值在 (20, +∞) 这个区间的新记录。为了大家理解方便，之后的 索引示意图中都会把这个 Supremum 记录画出来。</p><h5 id="next-key-locks" tabindex="-1"><a class="header-anchor" href="#next-key-locks" aria-hidden="true">#</a> Next-Key Locks</h5><p>有时候我们既想<strong>锁住某条记录，又想阻止其他事务在该记录前边的 间隙 插入新记录</strong>，所以设计 InnoDB 的大 叔们就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。比方说我们把 number 值为 8 的那条记录加一个 next-key锁 的示意图如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102163248125.png" alt="image-20221102163248125" tabindex="0" loading="lazy"><figcaption>image-20221102163248125</figcaption></figure><p>next-key锁 的本质就是一个 正经记录锁 和一个 gap锁 的合体，它既能保护该条记录，又能阻止别的事务 将新记录插入被保护记录前边的 间隙 。</p><h5 id="insert-intention-locks-插入意向锁" tabindex="-1"><a class="header-anchor" href="#insert-intention-locks-插入意向锁" aria-hidden="true">#</a> Insert Intention Locks(插入意向锁)</h5><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的 gap锁 （ next-key 锁 也包含 gap锁 ，后边就不强调了），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提 交。但是设计 InnoDB 的大叔规定**<code>事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某 个 间隙 中插入新记录，但是现在在等待</code>。**设计 InnoDB 的大叔就把这种类型的锁命名为 Insert Intention Locks ，官方的类型名称为：<code> LOCK_INSERT_INTENTION</code> ，我们也可以称为 <code>插入意向锁</code> 。</p><p>比方说我们把 number 值为 8 的那条记录加一个<code> 插入意向锁</code> 的示意图如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102163647682.png" alt="image-20221102163647682" tabindex="0" loading="lazy"><figcaption>image-20221102163647682</figcaption></figure><p>为了让大家彻底理解这个 插入意向锁 的功能，我们还是举个例子然后画个图表示一下。比方说现在 T1 为 number 值为 8 的记录加了一个 gap锁 ，然后 T2 和 T3 分别想向 hero 表中插入 number 值分别为 4 、 5 的 两条记录，所以现在为 number 值为 8 的记录加的锁的示意图就如下所示：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102163934813.png" alt="image-20221102163934813" tabindex="0" loading="lazy"><figcaption>image-20221102163934813</figcaption></figure><blockquote><p>我们在锁结构中又新添了一个type属性，表明该锁的类型。稍后会全面介绍InnoDB存储引擎中的 一个锁结构到底长什么样。</p></blockquote><p>从图中可以看到，由于 T1 持有 gap锁 ，所以 T2 和 T3 需要生成一个 插入意向锁 的 锁结构 并且处于等待 状态。</p><p>当 T1 提交后会把它获取到的锁都释放掉，这样 T2 和 T3 就能获取到对应的 插入意向锁 了（本质上 就是把插入意向锁对应锁结构的 is_waiting 属性改为 false ）， T2 和 T3 之间也并不会相互阻塞，它们可 以同时获取到 number 值为8的 插入意向锁 ，然后执行插入操作。事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁（插入意向锁就是这么鸡肋）。</strong></p><h5 id="隐式锁" tabindex="-1"><a class="header-anchor" href="#隐式锁" aria-hidden="true">#</a> 隐式锁</h5><p>我们前边说一个事务在执行 INSERT 操作时，如果即将插入的 间隙 已经被其他事务加了 gap锁 ，那么本次 INSERT 操作会阻塞，并且当前事务会在该间隙上加一个 插入意向锁 ，否则一般情况下 INSERT 操作是不加 锁的。</p><p>那如果<strong>一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：</strong></p><ul><li>立即使用 SELECT ... LOCK IN SHARE MODE 语句读取这条事务，也就是在要获取这条记录的 S锁 ，或者 使用 SELECT ... FOR UPDATE 语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的 X 锁 ，该咋办？</li></ul><p>​ 如果允许这种情况的发生，那么可能产生 脏读 问题。</p><ul><li>立即修改这条记录，也就是要获取这条记录的 X锁 ，该咋办？</li></ul><p>​ 如果允许这种情况的发生，那么可能产生 脏写 问题。 这时候我们前边唠叨了很多遍的 事务id 又要起作用了。我们把聚簇索引和二级索引中的记录分开看一 下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102170423825.png" alt="image-20221102170423825" tabindex="0" loading="lazy"><figcaption>image-20221102170423825</figcaption></figure><h2 id="mysql是怎么加锁的" tabindex="-1"><a class="header-anchor" href="#mysql是怎么加锁的" aria-hidden="true">#</a> Mysql是怎么加锁的</h2><p>因为行级锁加锁规则比较复杂，不同的场景，加锁的形式还不同</p><p>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p><p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。</p><p>实验的表格如下:</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102201813752.png" alt="image-20221102201813752" tabindex="0" loading="lazy"><figcaption>image-20221102201813752</figcaption></figure><p>其中，id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。</p><blockquote><p><strong>非唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中可以重复，不要求唯一</strong></p><p>如联合索引</p></blockquote><h3 id="唯一索引等值查询" tabindex="-1"><a class="header-anchor" href="#唯一索引等值查询" aria-hidden="true">#</a> 唯一索引等值查询</h3><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p><ul><li><strong>当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」</strong>。</li><li><strong>当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」</strong>。</li></ul><p>接下里用两个案例来说明。</p><blockquote><p>先看看记录是存在的。</p></blockquote><p>来看下面这个例子：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102200941187.png" alt="image-20221102200941187" tabindex="0" loading="lazy"><figcaption>image-20221102200941187</figcaption></figure><p>会话1加锁变化过程如下：</p><ol><li><strong>加锁的基本单位是 next-key lock</strong>，因此会话1的加锁范围是(8, 16];</li><li>但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 <strong>next-key lock 退化成记录锁，因此最终加锁的范围是 id = 16 这一行</strong>。</li></ol><p>所以，会话 2 在修改 id=16 的记录时会被锁住，而会话 3 插入 id=9 的记录可以被正常执行。</p><blockquote><p>接下来，看看记录不存在的情况</p></blockquote><p>来看看，下面这个例子：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102202915633.png" alt="image-20221102202915633" tabindex="0" loading="lazy"><figcaption>image-20221102202915633</figcaption></figure><p>会话1加锁变化过程如下：</p><ol><li>加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是(8, 16];</li><li>但是由于查询记录不存在，next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。</li></ol><p>所以，会话 2 要往这个间隙里面插入 id=9 的记录会被锁住，但是会话 3 修改 id =16 是可以正常执行的，因为 id = 16 这条记录并没有加锁。</p><h3 id="唯一索引范围查询" tabindex="-1"><a class="header-anchor" href="#唯一索引范围查询" aria-hidden="true">#</a> 唯一索引范围查询</h3><p>范围查询和等值查询的加锁规则是不同的。</p><p>举个例子，下面这两条查询语句，查询的结果虽然是一样的，但是加锁的范围是不一样的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>select * from t_test where id=8 for update;
select * from t_test where id&gt;=8 and id&lt;9 for update;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>做个实验就知道了。</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102203352979.png" alt="image-20221102203352979" tabindex="0" loading="lazy"><figcaption>image-20221102203352979</figcaption></figure><p>会话 1 加锁变化过程如下：</p><ol><li>最开始要找的第一行是 id = 8，因此 next-key lock(4,8]，但是由于 id 是唯一索引，且该记录是存在的，因此会退化成记录锁，也就是只会对 id = 8 这一行加锁；</li><li>由于是范围查找，就会继续往后找存在的记录，也就是会找到 id = 16 这一行停下来，然后加 next-key lock (8, 16]，但由于 id = 16 不满足 id &lt; 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。</li></ol><p>所以，会话 1 这时候主键索引的锁是记录锁 id=8 和间隙锁(8, 16)。</p><p>会话 2 由于往间隙锁里插入了 id = 9 的记录，所以会被锁住了，而 id = 8 是被加锁的，因此会话 3 的语句也会被阻塞。</p><p>由于 id = 16 并没有加锁，所以会话 4 是可以正常被执行。</p><h3 id="非唯一索引等值查询" tabindex="-1"><a class="header-anchor" href="#非唯一索引等值查询" aria-hidden="true">#</a> 非唯一索引等值查询</h3><p>当我们用非唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p><ul><li><strong>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁</strong>。</li><li><strong>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</strong></li></ul><p>接下里用两个案例来说明。</p><blockquote><p>我们先来看看查询的值存在的情况。</p></blockquote><p>比如下面这个例子：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102203934646.png" alt="image-20221102203934646" tabindex="0" loading="lazy"><figcaption>image-20221102203934646</figcaption></figure><p>会话 1 加锁变化过程如下：</p><ol><li>先会对普通索引 b 加上 next-key lock，范围是(4,8];</li><li><strong>然后<code>因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止</code></strong>，因此间隙锁的范围是(8,16)。</li></ol><p>所以，会话1的普通索引 b 上共有两个锁，分别是 next-key lock (4,8] 和间隙锁 (8,16) 。</p><p>那么，当会话 2 往间隙锁里插入 id = 9 的记录就会被锁住，而会话 3 和会话 4 是因为更改了 next-key lock 范围里的记录而被锁住的。</p><p>然后因为 b = 16 这条记录没有加锁，所以会话 5 是可以正常执行的。</p><blockquote><p>接下来，我们看看查询的值不存在的情况</p></blockquote><p>直接看案例：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102204430815.png" alt="image-20221102204430815" tabindex="0" loading="lazy"><figcaption>image-20221102204430815</figcaption></figure><p>会话 1 加锁变化过程如下：</p><ol><li>先会对普通索引 b 加上 next-key lock，范围是(8,16];</li><li>但是由于查询的记录是不存在的，所以不会再额外加个间隙锁，但是 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。</li></ol><p>会话 2 因为往间隙锁里插入了 b = 9 的记录，所以会被锁住，而 b = 16 是没有被加锁的，因此会话 3 的语句可以正常执行。</p><h3 id="非唯一索引范围查询" tabindex="-1"><a class="header-anchor" href="#非唯一索引范围查询" aria-hidden="true">#</a> 非唯一索引范围查询</h3><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁</strong>。</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102204721988.png" alt="image-20221102204721988" tabindex="0" loading="lazy"><figcaption>image-20221102204721988</figcaption></figure><p>会话 1 加锁变化过程如下：</p><ol><li>最开始要找的第一行是 b = 8，因此 next-key lock(4,8]，但是由于 b 不是唯一索引，并不会退化成记录锁。</li><li>但是由于是范围查找，就会继续往后找存在的记录，也就是会找到 b = 16 这一行停下来，然后加 next-key lock (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。</li></ol><p>所以，会话 1 的普通索引 b 有两个 next-key lock，分别是 (4,8] 和(8, 16]。这样，你就明白为什么会话 2 、会话 3 、会话 4 的语句都会被锁住了。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h3><p>唯一索引等值查询：</p><ul><li>当查询的记录是存在的，next-key lock 会退化成「记录锁」。</li><li>当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。</li></ul><p>非唯一索引等值查询：</p><ul><li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li><li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li></ul><p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p><ul><li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。</li><li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li></ul><h2 id="mysql-死锁了-怎么办" tabindex="-1"><a class="header-anchor" href="#mysql-死锁了-怎么办" aria-hidden="true">#</a> MySQL 死锁了，怎么办？</h2><h3 id="死锁的发生" tabindex="-1"><a class="header-anchor" href="#死锁的发生" aria-hidden="true">#</a> 死锁的发生</h3><p>本次案例使用存储引擎 Innodb，隔离级别为可重复读（RR）。</p><p>接下来，我用实战的方式来带大家看看死锁是怎么发生的。</p><p>我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>t_order<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>order_no<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>create_date<span class="token punctuation">\`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>index_order<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>order_no<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，先 <code>t_order</code> 表里现在已经有了 6 条记录：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102212510990.png" alt="image-20221102212510990" tabindex="0" loading="lazy"><figcaption>image-20221102212510990</figcaption></figure><p>假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102212615719.png" alt="image-20221102212615719" tabindex="0" loading="lazy"><figcaption>image-20221102212615719</figcaption></figure><p>可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。</p><p>这里在查询记录是否存在的时候，使用了 <code>select ... for update</code> 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。</p><p>如果没有使用 <code>select ... for update</code> 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：<img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213106425.png" alt="image-20221102213106425" loading="lazy"></p><h3 id="为什么会产生死锁" tabindex="-1"><a class="header-anchor" href="#为什么会产生死锁" aria-hidden="true">#</a> 为什么会产生死锁？</h3><p>可重复读隔离级别下，是存在幻读的问题。</p><p><strong>Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。</p><ul><li>Record Lock，记录锁，锁的是记录本身；</li><li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li></ul><p>普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token comment">//对读取的记录加共享锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span> <span class="token comment">//锁释放</span>

<span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token comment">//对读取的记录加排他锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span> <span class="token comment">//锁释放</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。</strong></p><p>比如，下面事务 A 查询语句会锁住 <code>(2, +∞]</code> 范围的记录，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213230281.png" alt="image-20221102213230281" tabindex="0" loading="lazy"><figcaption>image-20221102213230281</figcaption></figure><p>需要注意的是，<strong><code>如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。</code></strong></p><p>所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞!!!!!</p><p>回到前面死锁的例子。</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213639972.png" alt="image-20221102213639972" tabindex="0" loading="lazy"><figcaption>image-20221102213639972</figcaption></figure><p>事务 A 在执行下面这条语句的时候：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id <span class="token keyword">from</span> t_order <span class="token keyword">where</span> order_no <span class="token operator">=</span> <span class="token number">1007</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以通过 <code>select * from performance_schema.data_locks\\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p><figure><img src="https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213808356.png" alt="image-20221102213808356" tabindex="0" loading="lazy"><figcaption>image-20221102213808356</figcaption></figure><p>从上图可以看到，共加了两个锁，分别是：</p><ul><li>表锁：X 类型的意向锁；</li><li>行锁：X 类型的间隙锁；</li></ul><p>这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p><ul><li>如果 LOCK_MODE 为 <code>X</code>，说明是 X 型的 next-key 锁；</li><li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是 X 型的记录锁；</li><li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是 X 型的间隙锁；</li></ul><p>如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。</p><blockquote><p>supremum为数据页的内容</p></blockquote><p>当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">Insert</span> <span class="token keyword">into</span> t_order <span class="token punctuation">(</span>order_no<span class="token punctuation">,</span> create_date<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1008</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，<strong>而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以两个事务中 <code>select ... for update</code> 语句并不会相互影响</strong>。</p><p>案例中的事务 A 和事务 B 在执行完后 <code>select ... for update</code> 语句后都持有范围为<code>(1006,+∞]</code>的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。</p>`,271);function m(g,k){const s=l("ExternalLinkIcon");return p(),o("div",null,[c,a("p",null,[n("而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇"),a("a",d,[n("文章 (opens new window)"),t(s)]),n("），解决的方案有两种：")]),u])}const E=i(r,[["render",m],["__file","从根上理解Mysql4.html.vue"]]);export{E as default};
