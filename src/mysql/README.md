# 从一条记录说起-InnoDB记录结构

## 字符集的介绍

### ASCII

https://zh.m.wikipedia.org/zh-hans/ASCII

在计算机中所有的数据在存储和运算时都要使用二进制数表示。例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常见的符号（*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体**使用那些二进制数来表示哪个符号，这就是编码**。如果不同的计算机想要互相通信不造成混乱，那么每台计算机就必须使用相同的编码规则，于是美国有关的[标准化组织](https://zh.m.wikipedia.org/wiki/標準組織)就推出了ASCII编码。

`ASCII`使用标准的`单字节字符编码`(**一个字符占用一个字节**)方案，用于基于文本的数据。

![image-20220906151127815](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906151127815.png)

![image-20220906151136029](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906151136029.png)

####  缺点

ASCII的局限在于只能显示26个基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语

现在大多软件系统采用Unicode，特别是与ASCII向下兼容的UTF-8.

### UTF-8

**UTF-8**（**8-bit Unicode Transformation Format**）是一种针对[Unicode](https://zh.m.wikipedia.org/wiki/Unicode)的**可变长度**[字元编码](https://zh.m.wikipedia.org/wiki/字元編碼)，也是一种[前缀码](https://zh.m.wikipedia.org/wiki/前缀码)。它可以用**一至四个字节**对Unicode字符集中的所有有效编码点进行编码，属于[Unicode](https://zh.m.wikipedia.org/wiki/Unicode)标准的一部分

由于较小值的编码点一般使用频率较高，直接使用Unicode编码效率低下，大量浪费内存空间。UTF-8就是为了解决向后兼容ASCII码而设计，Unicode中前128个字符，使用与ASCII码相同的二进制值的单个[字节](https://zh.m.wikipedia.org/wiki/字节)进行编码，而且字面与ASCII码的字面一一对应，这使得原来处理ASCII字元的[软体](https://zh.m.wikipedia.org/wiki/軟體)无须或只须做少部份修改，即可继续使用。因此，它逐渐成为[电子邮件](https://zh.m.wikipedia.org/wiki/電子郵件)、[网页](https://zh.m.wikipedia.org/wiki/網頁)及其他[储存](https://zh.m.wikipedia.org/wiki/儲存裝置)或传送文字优先采用的编码方式。

## InnoDB页简介

InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机重启后数据还是在的。真正处理数据的过程是发生在内存当中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而磁盘的读写速度是很慢的，所以当我们想从表中获取数据时，InnoDB引擎采取的方式是：**将数据划分为若干个页，以页为单位作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB。**也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中16kb内容刷新到磁盘中

## InnoDB行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。 设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 **Compact 、 Redundant 、 Dynamic 和 Compressed 行格式**，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理 上大体都是相同的。

### 指定行格式的语法

我们可以在创建或修改表的语句中指定 行格式 ：

CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称 

ALTER TABLE 表名 ROW_FORMAT=行格式名称

比如我们在 xiaohaizi 数据库里创建一个演示用的表 record_format_demo ，可以这样指定它的 行格式 ：

```sql
mysql> USE xiaohaizi;
Database changed
mysql> CREATE TABLE record_format_demo (
 -> c1 VARCHAR(10),
 -> c2 VARCHAR(10) NOT NULL,
 -> c3 CHAR(10),
 -> c4 VARCHAR(10)
 -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
```

可以看到我们刚刚创建的这个表的 行格式 就是 Compact ，另外，我们还显式指定了这个表的字符集为 ascii ， 因为 ascii 字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这 个表里的。我们现在向这个表中插入两条记录：

```sql\
mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'),
('eeee', 'fff', NULL, NULL);
Query OK, 2 rows affected (0.02 sec)
Records: 2 Duplicates: 0 Warnings: 0
```

现在表中的记录就是这个样子的：

```sql
mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  |  c3  |  c4  |
+------+-----+------+------+
| aaaa | bbb | cc   |  d   |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
```

### COMPACT行格式

![image-20220904142502789](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904142502789.png)

#### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段 长度列表 、 NULL值列表 和 记录头信息

##### 变长字段长度列表

MySQL 支持一些变长的数据类型，比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类 型，我们也可以把拥有这些数据类型的列称为 变长字段 ，变长字段中存储多少字节的数据是不固定的，所以我 们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 MySQL 服务器搞懵，所以 这些变长字段占用的存储空间分为两部分： 

1. 真正的数据内容 
2. 占用的字节数

在 Compact 行格式中，**把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放**

![image-20220905223901417](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905223901417.png)

##### NULL值列表

如果把`NULL`值都放到记录的真实数据中存储会很占用地方，所以Compact行格式把这个些`NULL`值列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的：

1. 首先统计表中允许存储 NULL 的列有哪些

我们前边说过，主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列 算进去

2. **如果表中没有允许存储NULL值的列，则NULL值列表也不存在了**，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列
   - 二进制位的值为1时，代表该列的值为NULL
   - 二进制位的值为0时，代表该列的值不位NULL

因为表 record_format_demo 有3个值允许为 NULL 的列，所以这3个列和二进制位的对应关系就是这 样：

![image-20220905225003694](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905225003694.png)

二进制位按照列的顺序**逆序**排列，所以第一个列 c1 和最后一个二进制位对应

3. MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节 的高位补 0 。

表 record_format_demo 只有3个值允许为 NULL 的列，对应3个二进制位，不足一个字节，所以在字节的高 位补 0 ，效果就是这样：

![image-20220905225901129](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905225901129.png)

以此类推，如果一个表中有9个允许为 NULL ，那这个记录的 NULL 值列表部分就需要2个字节来表示了。

知道了规则之后，我们再返回头看表 record_format_demo 中的两条记录中的 NULL值列表 应该怎么储存。因为只 有 c1 、 c3 、 c4 这3个列允许存储 NULL 值，所以所有记录的 NULL值列表 只需要一个字节。 

- 对于第一条记录来说， c1 、 c3 、 c4 这3个列的值都不为 NULL ，所以它们对应的二进制位都是 0 ，画个 图就是这样：

![image-20220905225940635](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905225940635.png)

所以第一条记录的 NULL值列表 用十六进制表示就是： 0x00 。

对于第二条记录来说， c1 、 c3 、 c4 这3个列中 c3 和 c4 的值都为 NULL ，所以这3个列对应的二进制位的 情况就是：

![image-20220905230019367](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230019367.png)

所以第二条记录的 NULL值列表 用十六进制表示就是： 0x06 。

所以这两条记录在填充了 NULL值列表 后的示意图就是这样：

![image-20220905230039541](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230039541.png)

##### 记录头信息

除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组 成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图：

![image-20220904153815836](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904153815836.png)

这些二进制位代表的详细信息如下表：

![image-20220905230231002](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230231002.png)

我们现在直接看一下 record_format_demo 中的两条记录的 头信息 分别是什么：

###### 记录的真实数据

对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据 以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：



![image-20220904160501312](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904160501312.png)

因为表 record_format_demo 并没有定义主键，所以 MySQL 服务器会为每条记录增加上述的3个列。现在看一下 加上 记录的真实数据 的两个记录长什么样吧

![image-20220905230612848](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905230612848.png)

看这个图的时候我们需要注意几点：

1. 表 record_format_demo 使用的是 ascii 字符集，所以 0x61616161 就表示字符串 'aaaa' ， 0x626262 就表示字符串 'bbb' ，以此类推。

2. 注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是： 'cc' ，而 ascii 字符集中的字节表示是 '0x6363' ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用`空格字符填充`，空格字符在 ascii 字符集的表示就是 0x20 。
3. 注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处就不再冗余存储，从而节省存储空间。

###### CHAR(M)列的存储格式

record_format_demo 表的 c1 、 c2 、 c4 列的类型是 VARCHAR(10) ，而 c3 列的类型是 CHAR(10) ，我们说在 Compact 行格式下只会把变长类型的列的长度逆序存到 变长字段长度列表 中，就像这样：

![image-20220905231151660](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905231151660.png)

但是这只是因为我们的` record_format_demo` 表采用的是 `ascii `字符集，这个字符集是一个`定长字符集`，也就是 说**表示一个字符采用固定的一个字节**，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如 gbk 表示一个字符要12个字节、 utf8 表示一个字符要13个字节等）的话， c3 列的长度也会被存储到 变长字段 长度列表 中，比如我们修改一下record_format_demo 表的字符集：

```sql
mysql> ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
Query OK, 2 rows affected (0.02 sec)
Records: 2 Duplicates: 0 Warnings: 0
```

修改该列字符集后记录的 变长字段长度列表 也发生了变化，如图：

![image-20220905232957104](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905232957104.png)

这就意味着：**对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字 段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。**

另外有一点还需要注意，变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，而 VARCHAR(M) 却没有这个要 求。比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10～30个字节。即 使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节 长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有 的记录空间成为所谓的碎片。

###### varchar和char的的区别是什么

**char的长度是不可变的，而varchar的长度是可变的。**

定义一个char（10）和varchar（10），如果存进去的是三个字节，那么char会用空格填满10个字节

varchar不会这样做，varchar的话本来是10个字节，那么它就会把长度变为3了

取数据的时候，cahr类型的要用trim（）去掉多余的空格，而varchar是不需要的。

`char的存取速度比varchar快的多`，因为它`长度固定`，方便程序的存储与查找，相当于是以`空间换取时间效率`

`varchar`是以`空间效率为首位`。

**char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。**

 **varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。**

### Redundant行格式

为了知识的系统性，我们也来看下Redundant行格式

![image-20220906113020329](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906113020329.png)

现在我们把表 record_format_demo 的行格式修改为 Redundant ：

```
mysql> ALTER TABLE record_format_demo ROW_FORMAT=Redundant;
Query OK, 0 rows affected (0.05 sec)
Records: 0 Duplicates: 0 Warnings: 0
```

了方便大家理解和节省篇幅，我们直接把表 record_format_demo 在 Redundant 行格式下的两条记录的真实存 储数据提供出来，之后我们着重分析两种行格式的不同即可。

![image-20220906113546830](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906113546830.png)

下边我们从各个方面看一下 Redundant 行格式有什么不同的地方：

- 字段长度偏移列表

注意 Compact 行格式的开头是 变长字段长度列表 ，而 Redundant 行格式的开头是 字段长度偏移列表 ，与 变长字段长度列表 有两处不同：

- 没有了`变长`两个字，意味着 Redundant 行格式会把该条记录中`所有列`（包括 隐藏列 ）的长度信息都按 照`逆序`存储到 字段长度偏移列表 。
- 多了个`偏移`两个字，这意味着计算列值长度的方式不像 Compact 行格式那么直观，它是采用两个相邻数 值的差值来计算各个列值的长度。

比如第一条记录的 字段长度偏移列表 就是： 

​	25 24 1A 17 13 0C 06 

因为它是逆序排放的，所以按照列的顺序排列就是： 

​	06 0C 13 17 1A 24 25 

按照两个相邻数值的差值来计算各个列值的长度的意思就是：

​	第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。 

​	第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。 

​	第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。 

​	第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。 

​	第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。 

​	第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。 

​	第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。

### 行溢出数据

#### VARCHAR（M）最多能存储的数据

我们知道对于 VARCHAR(M) 类型的列最多可以占用 65535 个字节。其中的 M 代表该类型最多存储的字符数量，如 果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们看看 VARCHAR(65535) 是否可用：

```sql
CREATE TABLE varchar_size_demo(
	c VARCHAR(65535)
)CHARSET=ascii ROW_FORMAT=Compact;
some columns to TEXT or BLOBs
> 时间: 0.002s
```

从报错信息里可以看出， MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之 外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。所以 MySQL 服 务器建议我们把存储类型改为 TEXT 或者 BLOB 的类型。这个 65535 个字节除了列本身的数据之外，还包括一些 其他的数据（ storage overhead ），比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间：

- 真实数据 
- 真实数据占用字节的长度 
- NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间

如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能 占用2个字节， NULL 值标识需要占用1个字节：

```sql
mysql> CREATE TABLE varchar_size_demo(
 -> c VARCHAR(65532)
 -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2个字节，不需要 NULL 值标识：

```sql
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.01 sec)
mysql> CREATE TABLE varchar_size_demo(
 -> c VARCHAR(65533) NOT NULL
 -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果 VARCHAR(M) 类型的列使用的不是 ascii 字符集，那会怎么样呢？来看一下：

```sql
mysql> CREATE TABLE varchar_size_demo(
 -> c VARCHAR(65532)
 -> ) CHARSET=gbk ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 32767); use BLOB or TEXT i
nstead

mysql> CREATE TABLE varchar_size_demo(
 -> c VARCHAR(65532)
 -> ) CHARSET=utf8 ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 21845); use BLOB or TEXT i
nstead
```

从执行结果中可以看出，如果 VARCHAR(M) 类型的列使用的不是 ascii 字符集，那 M 的最大取值取决于该字符集 表示一个字符最多需要的字节数。在列的值允许为 NULL 的情况下， gbk 字符集表示一个字符最多需要 2 个字 节，那在该字符集下， M 的最大取值就是 32766 （也就是：65532/2），也就是说最多能存储 32766 个字符； utf8 字符集表示一个字符最多需要 3 个字节，那在该字符集下， M 的最大取值就是 21844 ，就是说最多能存 储 21844 （也就是：65532/3）个字符。

**UTF8编码中一个汉字（包括数字）占用3个字节**

**GBK编码中一个汉字（包括数字）占用2个字节**

#### 记录中的数据太多产生的溢出

我们以 ascii 字符集下的 varchar_size_demo 表为例，插入一条记录：

```
mysql> CREATE TABLE varchar_size_demo(
 -> c VARCHAR(65532)
 -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)
mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)
```

其中的 REPEAT('a', 65532) 是一个函数调用，它表示生成一个把字符 'a' 重复 65532 次的字符串。前边说 过，` MySQL `中磁盘和内存交互的基本单位是 `页 `，也就是说 `MySQL 是以 页 为基本单位来管理存储空间的`，我们 的记录都会被分配到某个 页 中存储。而`一个页的大小一般是 16KB` ，也就是 16384 字节，而`一个 VARCHAR(M) 类 型的列就最多可以存储 65532 个字节`，这样就可能造成`一个页存放不了一条记录`的尴尬情况。

在 `Compact `和` Reduntant` 行格式中，**对于占用存储空间非常大的列，在 记录的真实数据 处只会存储该列的一部 分数据，把剩余的数据分散存储在几个其他的页中，然后 记录的真实数据 处用20个字节存储指向这些页的地址 （当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页**， 如图所示：

![image-20220906153739582](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906153739582.png)

从图中可以看出来，对于 Compact 和 Reduntant 行格式来说，如果某一列中的数据非常多的话，在本记录的真实 数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个 过程也叫做 行溢出 ，存储超出 768 字节的那些页面也被称为 溢出页 。画一个简图就是这样：

![image-20220906153751843](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906153751843.png)

最后需要注意的是，**不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候 也会发生 行溢出 。**

####  行溢出的临界点

在列存储多少字节的数据时会发生行溢出？

MySQL 中规定**一个页中至少存放两行记录**，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影 响。以上边的 varchar_size_demo 表为例，它只有一个列 c ，我们往这个表中插入两条记录，每条记录最少插入 多少字节的数据才会 行溢出 的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要 136 个字节
  的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。
- 每个记录需要的额外信息是 27 字节。

这27个字节包括下边这些部分：

- 2个字节用于存储真实数据的长度
- 1个字节用于存储列是否是NULL值
- 5个字节大小的头信息
- 6个字节的 row_id 列
- 6个字节的 transaction_id 列
- 7个字节的 roll_pointer 列

**你不用关注这个临界点是什 么，只要知道如果我们想一个行中存储了很大的数据时，可能发生 行溢出 的现象。**

### Dynamic和Compressed行格式

Dynamic 和 Compressed 行格式，我现在使用的 MySQL 版本是 5.7 ，它的默认行格 式就是 Dynamic ，这俩行格式和 Compact 行格式挺像，只不过在处理 行溢出 数据时有点儿分歧，它们不会在记 录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数 据处存储其他页面的地址，就像这样：

![image-20220906144330784](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906144330784.png)

**Compressed 行格式和 Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空 间。**

## 总结

![image-20220824202128667](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824202128667.png)

![image-20220824202136734](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824202136734.png)

4. 一个页一般是 16KB ，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种 现象称为 行溢出 。



# 二、盛放记录的大盒子-InnoDB数据页结构

## 不同类型的页简介

前边我们简单提了一下 页 的概念，它是 InnoDB 管理存储空间的基本单位，一个页的大小一般是 16KB 。 InnoDB 为了不同的目的而设计了许多种不同类型的 页 ，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 undo 日志信息的页等等等等。我们聚焦的是那些 存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（ INDEX ）页，鉴于我们还没有了解过索引 是个什么东西，而这些表中的记录就是我们日常口中所称的 数据 ，所以目前还是叫这种存放记录的页为 数据页 吧。

## 数据页结构的快速浏览

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

![image-20220824203051546](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824203051546.png)

从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的， 有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速 的瞅一眼就行了，后边会详细唠叨的）：

![image-20220824203125400](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824203125400.png)

## 记录在页中的存储

![image-20220824211740106](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220824211740106.png)

### 记录头信息的秘密

我们先创建一个表：

```sql
mysql> CREATE TABLE page_demo(
 -> c1 INT,
 -> c2 INT,
 -> c3 VARCHAR(10000),
 -> PRIMARY KEY (c1)
 -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

这个新创建的 page_demo 表有3个列，其中 c1 和 c2 列是用来存储整数的， c3 列是用来存储字符串的。需要注 意的是，我们把 c1 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 row_id 隐 藏列了。而且我们为这个表指定了 ascii 字符集以及 Compact 的行格式。所以这个表中记录的行格式示意图就是 这样的：

![image-20220904153815836](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904153815836.png)

简化后如下：

![image-20220904160915879](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904160915879.png)

下边我们试着向 page_demo 表中插入几条记录：

```sql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'),
(4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4 Duplicates: 0 Warnings: 0
```

为了方便大家分析这些记录在 页 的 User Records 部分中是怎么表示的，我把记录中头信息和实际的列数据都用 十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：

![image-20220904160942858](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220904160942858.png)

看这个图的时候需要注意一下，各条记录在` User Records `中存储的时候并没有空隙，这里只是为了大家观看方 便才把每条记录单独画在一行中。我们对照着这个图来看看记录头信息中的各个属性是啥意思：

- delete_mask

这个属性标记着当前记录是否被删除，占用1个二进制位，值为 0 的时候代表记录并没有被删除，为 1 的时 候代表记录被删除掉了。 

啥？**被删除的记录还在 页 中么？是的**，摆在台面上的和背地里做的可能大相径庭，**你以为它删除了，可它 还在真实的磁盘上**[摊手]（忽然想起冠希～）。

这些被删除的记录之所以不立即从磁盘上移除，是因为移除 它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记 录都会组成一个所谓的 垃圾链表 ，在这个链表中的记录占用的空间称之为所谓的 可重用空间 ，之后如果有 新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- min_rec_mask

B+树的每层非叶子节点中的最小记录都会添加该标记，什么是个 B+ 树？什么是个非叶子节点？好吧，等会 再聊这个问题。反正我们自己插入的四条记录的 min_rec_mask 值都是 0 ，意味着它们都不是 B+ 树的非叶 子节点中的最小记录。

- heap_no

这个属性表示当前记录在本 页 中的位置，从图中可以看出来，我们插入的4条记录在本 页 中的位置分别 是： 2 、 3 、 4 、 5 。

其中0和1分别为`伪记录`和`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`

是的，记录也可以比大小，对于一条完整的记录来说，比较的记录大小就是比较主键的大小。比如我们插入的4行记录的主键值分别是：1，2，3，4这也就意外着这四条记录的大小从到大依次递增

> 对于一条完整的记录来说，比较记录的大小就相当于比的是主键的大小。

但是不管我们向 页 中插入了多少自己的记录，设计 InnoDB 的大叔们都规定他们定义的两条伪记录分别为最 小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的 记录头信息 和8字节大小的一个固定 的部分组成的，如图所示

![image-20220906161007510](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906161007510.png)

由于这两条记录不是我们自己定义的记录，所以它们并不存放在 页 的 User Records 部分，他们被单独放在 一个称为 Infimum + Supremum 的部分，如图所示：

![image-20220906161025673](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906161025673.png)

从图中我们可以看出来，最小记录和最大记录的 heap_no 值分别是 0 和 1 ，也就是说它们的位置最靠前。

- record_type

这个属性表示当前记录的类型，一共有4种类型的记录， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表 示最小记录， 3 表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0 ，而最小记录和最大记录的 record_type 值分别为 2 和 3 。 至于 record_type 为 1 的情况，我们之后在说索引的时候会重点强调的。

- next_record

这玩意儿非常重要，它表示**从当前记录的真实数据到下一条记录的真实数据的地址偏移量**。比方说第一条记 录的 next_record 值为 32 ，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的 真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个 链表 ，可以通过一条记录找到它的下一 条记录。但是需要注意注意再注意的一点是， 下一条记录 **指得并不是按照我们插入顺序的下一条记录，而 是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是 本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就 是最大记录）** ，为了更形象的表示一下这个 next_record 起到的作用，我们用箭头来替代一下 next_record 中的地址偏移量：

![image-20220906161246136](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906161246136.png)

从图中可以看出来，**我们的记录按照主键从小到大的顺序形成了一个单链表**。 最大记录 的 next_record 的 值为 0 ，这也就是说最大记录是没有 下一条记录 了，它是这个单链表中的最后一个节点。如果从中删除掉 一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：

```
 mysql> DELETE FROM page_demo WHERE c1 = 2;
 Query OK, 1 row affected (0.02 sec)
```

**删掉第2条记录后的示意图就是：**![image-20220906161413007](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906161413007.png)

从图中可以看出来，删除第2条记录前后主要发生了这些变化：

- 第2条记录并没有从存储空间中移除，而是把该条记录的 delete_mask 值设置为 1 。
- 第2条记录的 next_record 值变为了0，意味着该记录没有下一条记录了。
- 第1条记录的 next_record 指向了第3条记录。
- 还有一点你可能忽略了，就是 最大记录 的 n_owned 值从 5 变成了 4 ，关于这一点的变化我们稍后会详
  细说明的。

所以，**不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个**
**节点是按照主键值由小到大的顺序连接起来的。**

再来看一个有意思的事情，因为主键值为 2 的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这 条记录插入到表中，会发生什么事呢？

```sql
mysql> INSERT INTO page_demo VALUES(2, 200, 'bbbb');
Query OK, 1 row affected (0.00 sec)
```

我们看一下记录的存储情况：

![image-20220906161705253](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906161705253.png)

从图中可以看到， InnoDB 并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录 的存储空间。

> 小贴士： 当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成 一个垃圾链表，以备之后重用这部分存储空间。

## Page Directory（页目录）

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某 条记录该咋办呢？比如说这样的查询语句：

SELECT * FROM page_demo WHERE c1 = 3;

**最笨的办法：**从 Infimum 记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到[摊 手]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点 代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。

但是设计InnoDB的是什么人物？它们会用这么笨的方法吗？当然不会，它们采用一个类似目录的结构，它们的制作过程是这样的：

1. **将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组**
2. 每个组的最后一条记录（也就是组内最大的记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录
3. **将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 页 的尾部的地方，这个地方就是所 谓的 Page Directory ，也就是 页目录 （此时应该返回头看看页面各个部分的图）**。页面目录中的这些`地址 偏移量`被称为 `槽`（英文名： Slot ），所以这个`页面目录`就是`由 槽 组成`的。

比方说现在的 page_demo 表中正常的记录共有6条， InnoDB 会把它们分成两组，第一组中只有一个最小记录， 第二组中是剩余的5条记录，看下边的示意图：

![image-20220908155903047](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220908155903047.png)

从这个图中我们需要注意这么几点：

- 现在 页目录 部分中有两个槽，也就意味着我们的记录被分成了两个组， 槽1 中的值是 112 ，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）； 槽0 中的值是 99 ，代表最小记录的地址偏移量。

- 注意最小和最大记录的头信息中的 n_owned 属性
  - 最小记录的 n_owned 值为 1 ，这就代表着以最小记录结尾的这个分组中只有 1 条记录，也就是最小记录 本身。 
  - 最大记录的 n_owned 值为 5 ，这就代表着以最大记录结尾的这个分组中只有 5 条记录，包括最大记录本 身还有我们自己插入的 4 条记录。

99 和 112 这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的 示意图就是这样：

![image-20220908160516578](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220908160516578.png)

单纯从逻辑上看一下这些记录和页目录的关系：

![image-20220908160545055](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220908160545055.png)

为什么最小记录的 n_owned 值为1，而最大记录的 n_owned 值为 5 呢，这里头有什么猫腻 么？ 

是的，设计 InnoDB 的大叔们对每个分组中的记录条数是有规定的：**对于最小记录所在的分组只能有 1 条记录， 最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。 所以分组是按照下边的步骤进行的:**

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一
  个5条记录。这个过程会在 页目录 中新增一个 槽 来记录这个新增分组中最大的那条记录的偏移量。

由于现在 page_demo 表中的记录太少，无法演示添加了 页目录 之后加快查找速度的过程，所以再往 page_demo 表中添加一些记录：

```sql
mysql> INSERT INTO page_demo VALUES(5, 500, 'eeee'), (6, 600, 'ffff'), (7, 700, 'gggg'),
(8, 800, 'hhhh'), (9, 900, 'iiii'), (10, 1000, 'jjjj'), (11, 1100, 'kkkk'), (12, 1200, 'l
lll'), (13, 1300, 'mmmm'), (14, 1400, 'nnnn'), (15, 1500, 'oooo'), (16, 1600, 'pppp');
Query OK, 12 rows affected (0.00 sec)
Records: 12 Duplicates: 0 Warnings: 0
```

我们在添加了12条记录，现在页里边就一共有18条记录了（包括最小和最大记录），这些记录 被分成了5个组，如图所示：

![image-20220906164939638](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906164939638.png)

现在看怎么从这个 页目 录 中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的 二分法 来进行 快速查找。4个槽的编号分别是： 0 、 1 、 2 、 3 、 4 ，所以初始情况下最低的槽就是 low=0 ，最高的槽就是 high=4 。比方说我们想找主键值为 6 的记录，过程是这样的：

1. 计算中间槽的位置： (0+4)/2=2 ，所以查看 槽2 对应记录的主键值为 8 ，又因为 8 > 6 ，所以设置
   high=2 ， low 保持不变。
2. 重新计算中间槽的位置： (0+2)/2=1 ，所以查看 槽1 对应的主键值为 4 ，又因为 4 < 6 ，所以设置
   low=1 ， high 保持不变。
3. 因为 high - low 的值为1，所以确定主键值为 5 的记录在 槽2 对应的组中。此刻我们需要找到 槽2 中主键
   值最小的那条记录，然后沿着单向链表遍历 槽2 中的记录。但是我们前边又说过，每个槽对应的记录都是该
   组中主键值最大的记录，这里 槽2 对应的记录是主键值为 8 的记录，怎么定位一个组中最小的记录呢？别忘
   了各个槽都是挨着的，我们可以很轻易的拿到 槽1 对应的记录（主键值为 4 ），该条记录的下一条记录就
   是 槽2 中主键值最小的记录，该记录的主键值为 5 。所以我们可以从这条主键值为 5 的记录出发，遍历 槽
   2 中的各条记录，直到找到主键值为 6 的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以
   遍历一个组中的记录的代价是很小的。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. **通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。**
2. **通过记录的` next_record `属性遍历该槽所在的组中的各个记录。**

## Page Header（页面头部）

设计 InnoDB 的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第 一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是 页 结构的第二部分，这个部分占用固定的 56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下

![image-20220906165757271](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906165757271.png)

**PAGE_DIRECTION 和 PAGE_N_DIRECTION 的意思：**

- PAGE_DIRECTION

假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左
边。用来表示最后一条记录插入方向的状态就是 PAGE_DIRECTION 。

- PAGE_N_DIRECTION

假设连续几次插入新记录的方向都是一致的， InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条
数就用 PAGE_N_DIRECTION 这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值
会被清零重新统计。

> 作者给了我一碗鸡汤，我又干劲十足
>
> 大意是坚持做自己喜欢的事儿，你在做的时候可能并不能搞清楚这些事 儿对自己之后的人生有啥影响，但当你一路走来回头看时，一切都是那么清晰，就像是命中注定的一 样

## File Header（文件头部）

上边唠叨的 `Page Header` 是专门针对` 数据页 `记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个 槽了呀。我们现在描述的 `File Header` 针对`各种类型的页`都通用，也就是说不同类型的页都会以 File Header`作 为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、 下一个页是谁啦吧啦吧啦～ 这个部分占用固定的 38 个字节，是由下边这些内容组成的：



![image-20220906170444968](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906170444968.png)

对照着这个表格，我们看几个目前比较重要的部分：

- FIL_PAGE_SPACE_OR_CHKSUM

这个代表`当前页面的校验和`（checksum）。`啥是个校验和？`**就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为 校验和 。**

这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。

- FIL_PAGE_OFFSET

每一个 页 都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以唯一定位一个 页 。

- FIL_PAGE_TYPE

这个代表当前 页 的类型，我们前边说过， InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的 其实都是存储记录的 数据页 ，其实还有很多别的类型的页

**我们存放记录的数据页的类型其实是 FIL_PAGE_INDEX ，也就是所谓的 索引页** 。至于啥是个索引，且听下回 分解～

- FIL_PAGE_PREV 和 FIL_PAGE_NEXT

我们前边强调过， InnoDB 都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大 （比方说一张表中可以有成千上万条记录）， InnoDB 可能不可以一次性为这么多数据分配一个非常大的存 储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来， FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了， 而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过 我们本集中唠叨的 数据页 （也就是类型为 FIL_PAGE_INDEX 的页）是有这两个属性的，所以所有的数据页其 实是一个双链表，就像这样：

![image-20220906171054722](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906171054722.png)

## File Trailer

我们知道` InnoDB 存储引擎会把数据存储到磁盘上`，但是磁盘速度太慢，需要以` 页 `为单位`把数据加载到内存中处理`，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在`同步了一半的时候中断电了`咋办，这不是莫名尴尬么？为了`检测一个页是否完整`（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计 InnoDB 的大叔们在`每个页的尾部都加了一个 File Trailer 部分`，这个部分由 8 个字节组成，可以分成2个小部分：

- 前4个字节代表页的校验和

这个部分是和 File Header 中的校验和相对应的。**每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为` File Header `在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。**如果写了一半儿断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

这个部分也是为了校验页的完整性的，只不过我们目前还没说 LSN 是个什么意思，所以大家可以先不用管这个属性。

**这个 File Trailer 与 File Header 类似，都是所有类型的页通用的。**

## 总结

1. InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 **数据页** 。


2. 一个数据页可以被大致划分为7个部分，分别是

   - File Header ，表示页的一些通用信息，占固定的38字节。

   - Page Header ，表示数据页专有的一些信息，占固定的56个字节。

   - Infimum + Supremum ，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 26 个字节。

   - User Records ：真实存储我们插入的记录的部分，大小不固定。

   - Free Space ：页中尚未使用的部分，大小不确定。

   - Page Directory ：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。

   - File Trailer ：用于检验页是否完整的部分，占用固定的8个字节。

3. 每个记录的头信息中都有一个 next_record 属性，从而使页中的所有记录串联成一个 单链表 。

4. InnoDB 会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个 槽 ，存放在Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：

   - 通过二分法确定该记录所在的槽。

   - 通过记录的next_record属性遍历该槽所在的组中的各个记录。

5. 每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 双链表 。

6. 为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 LSN 值，如果首部和尾部的校验和和 LSN 值校验不成功的话，就说明同步过程出现了问题。

# 三、B+树索引

各个数据页可以组成一个 双向链表 ，而每个数据页 中的记录会按照主键值从小到大的顺序组成一个 单向链表 ，每个数据页都会为存储在它里边儿的记录生成一个 页目录 ，**在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对 应分组中的记录即可快速找到指定的记录**

![image-20220905220432937](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220905220432937.png)

## 没有索引的查找

本集的主题是 索引 ，在正式介绍 索引 之前，我们需要了解一下没有索引的时候是怎么查找记录的。为了方便大 家理解，我们下边先只唠叨搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于 = 连接 起的表达式，比如这样：

SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;

### 在一个页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同 分为两种情况：

- 以主键为搜索条件

这个查找过程我们已经很熟悉了，可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应 分组中的记录即可快速找到指定的记录。

- 以其他列作为搜索条件

对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的 页目录 ，所以 我们无法通过二分法快速定位相应的 槽 。这种情况下只能**从 最小记录 开始依次遍历单链表中的每条记录， 然后对比每条记录是不是符合搜索条件。**很显然，这种查找的效率是非常低的。

### 在很多页中查找

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话 可以分为两个步骤：

1. 定位到记录所在的页。 
2. 从所在的页内中查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，**由于我们并不能快速的定位到记录所在的 页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的 记录。**因为要遍历所有的数据页，所以这种方式显然是超级耗时的，如果一个表有一亿条记录，使用这种方式去 查找记录那要等到猴年马月才能等到查找结果。所以祖国和人民都在期盼一种能高效完成搜索的方法， 索引 同 志就要亮相登台了。

## 索引

```sql
 CREATE TABLE index_demo(
	c1 INT,
	c2 INT,
	c3 CHAR(1),
	PRIMARY KEY(c1)
) ROW_FORMAT = Compact;
```

这个新建的 index_demo 表中有2个 INT 类型的列，1个 CHAR(1) 类型的列，而且我们规定了 c1 列为主键，这个 表使用 Compact 行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下 index_demo 表的行格式示 意图：

![image-20220909103304357](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103304357.png)



我们只在示意图里展示记录的这几个部分：

- record_type ：记录头信息的一项属性，**表示记录的类型**， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 我们还没用过，等会再说～
- next_record ：记录头信息的一项属性，**表示下一条地址相对于本条记录的地址偏移量**，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。
- 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。
- 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

为了节省篇幅，我们之后的示意图中会把记录的 其他信息 这个部分省略掉，因为它占地方并且不会有什么观赏 效果。另外，为了方便理解，我们觉得把记录竖着放看起来感觉更好，所以将记录格式示意图的 其他信息 去掉 并把它竖起来的效果就是这样：

![image-20220909103430969](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103430969.png)

把一些记录放到页里边的示意图就是：

![image-20220909103450825](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103450825.png)

### 一个简单的索引方案

回到正题，我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？**因为各个页中的记录并没有 规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 不得不 依次遍历所有的数据页。**所以如果我们 想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位 置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完 成下边这些事儿：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个 数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 index_demo 表插入3条记录：

```sql
INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');	
```

那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：

![image-20220909103720390](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103720390.png)



从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为 10 的数据页中了。此时我们再来插入 一条记录：

```sql
INSERT INTO index_demo VALUES(4, 4, 'a');
```

因为 页10 最多只能放3条记录，所以我们不得不再分配一个新页：

![image-20220909103749373](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103749373.png)

**新分配的数据页编号可能并不是连续的，也 就是说我们使用的这些页在存储空间里可能并不挨着。**它们只是通过维护着上一个页和下一个页的编号而建 立了链表关系。另外， 页10 中用户记录最大的主键值是 5 ，而 页28 中有一条记录的主键值是 4 ，因为 5 > 4 ，所以这就不符合**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求**，所 以在插入主键值为 4 的记录的时候需要伴随着一次记录移动，也就是把主键值为 5 的记录移动到 页28 中， 然后再把主键值为 4 的记录插入到 页10 中，这个过程的示意图如下：

![image-20220909103854702](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909103854702.png)

这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保 证这个状态一直成立：**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**。这个过程 我们也可以称为 **页分裂** 。

- 给所有的页建立一个目录项。

由于数据页的编号可能并不是连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：

![image-20220909104015824](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909104015824.png)因为这些 16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所 在的页，我们需要给它们做个目录，**每个页对应一个目录项**，每个目录项包括下边两个部分：

1. 页的用户记录中最小的主键值，我们用 key 来表示。 
2. 页号，我们用 page_no 表示。

所以我们为上边几个页做好的目录就像这样子：

![image-20220909104055618](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909104055618.png)

以 页28 为例，它对应 目录项5 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键 值 5 。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现**根 据主键值**快速查找某条记录的功能了。比方说我们想找主键值为 20 的记录，具体查找过程分两步：

- 先从目录项中根据二分法快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对 应的页是 页9 。
-  再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。不过忘了说了，**这个 目录 有一个别名，称为 索引** !!!

写的太好了，通俗易懂！

### InnoDB中的索引方案

上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录 项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：

- InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证 16KB 的连续存储空间，而随着表中记 录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现 实的。
- 我们时常会对记录进行增删，假设我们把 页28 中的记录都删除了， 页28 也就没有存在的必要了，那意味 着 目录项2 也就没有存在的必要了，这就需要把 目录项2 后的目录项都向前移动一下，这种牵一发而动全身 的设计不是什么好主意～

所以，设计 InnoDB 的大叔们需要一种可以灵活管理所有 目录项 的方式。他们灵光乍现，忽然发现这些 目录项 其实长得跟我们的用户记录差不多，只不过 目录项 中的两个列是 主键 和 页号 而已，所以他们**复用了之前存储 用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为** 目录项记 录 。那 InnoDB 怎么区分一条记录是普通的 用户记录 还是 目录项记录 呢？别忘了记录头信息里的 record_type 属性，它的各个取值代表的意思如下：

- 0 ：普通的用户记录
- 1 ：目录项记录
- 2 ：最小记录
- 3 ：最大记录

哈哈，原来这个值为 1 的 record_type 是这个意思呀，我们把前边使用到的目录项放到数据页中的样子就是这样：

![image-20220909111136827](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909111136827.png)

从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储 目录项记录 。这里再次强调一遍 目录项记录 和普通的 用户记录 的不同点：

- 目录项记录 的 record_type 值是1，而普通用户记录的 record_type 值是0。
- 目录项记录 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。
- 还记得我们之前在唠叨记录头信息的时候说过一个叫 min_rec_mask 的属性么，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。

除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是 0x45BF ，这个属性在 File Header 中，忘了的话可以翻到前边的文章看），页的组成结构也是一样一样的（就是我们前边介绍过的7个部 分），都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用二分法来加快查 询速度。现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储 目录项记录 的页，也就是页 30 中通过二分法快速定位到对应目录项，因为 12 < 20 < 209 ，所 以定位到对应的记录所在的页就是 页9 。
2. 再到存储用户记录的 页9 中根据二分法快速定位到主键值为 20 的用户记录。

虽然说 目录项记录 中**只存储主键值和对应的页号**，比用户记录需要的存储空间小多了，但是不论怎么说一个页 只有 16KB 大小，能存放的 目录项记录 也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有 的 目录项记录 ，该咋办呢？

当然是再多整一个存储 目录项记录 的页喽～ 为了大家更好的理解新分配一个 目录项记录 页的过程，我们假设 一个存储 目录项记录 的页最多只能存放4条 目录项记录 （请注意是假设哦，真实情况下可以存放好多条的）， 所以如果此时我们再向上图中插入一条主键值为 320 的用户记录的话，那就需要分配一个新的存储 目录项记录 的页喽：

![image-20220909112818810](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909112818810.png)

从图中可以看出，我们插入了一条主键值为 320 的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了 页31 。
- 因为原先存储 目录项记录 的 页30 的容量已满（我们前边假设只能存储4条 目录项记录 ），所以不得不需要一个新的 页32 来存放 页31 对应的目录项。

现在因为存储 目录项记录 的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查 找主键值为 20 的记录为例：

1. 确定 目录项记录 页
   我们现在的存储 目录项记录 的页有两个，即 页30 和 页32 ，又因为 页30 表示的目录项的主键值的范围是
   [1, 320) ， 页32 表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目录项记录在 页30
   中。

2. 通过 目录项记录 页确定用户记录真实所在的页。
在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了，不赘述了～
3. 在真实存储用户记录的页中定位到具体的记录。
在一个存储用户记录的页中通过主键值定位一条用户记录的方式已经说过200遍了，你再不会我就，我就，
我就求你到上一篇唠叨数据页结构的文章中多看几遍，求你了～哈哈哈卑微作者在线卖萌

那么问题来了，在这个查询步骤的第1步中我们需要定位存储 目录项记录 的页，但是这些页在存储空间中也可能 不挨着，如果我们表中的数据非常多则会产生很多存储 目录项记录 的页，那我们怎么根据主键值快速定位一个 存储 目录项记录 的页呢？其实也简单，为这些存储 目录项记录 的页再生成一个更高级的目录，就像是一个多级 目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![image-20220909113040759](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909113040759.png)

如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表 页30 和 页32 ，如果用户记录 的主键值在 [1, 320) 之间，则到 页30 中查找更详细的 目录项记录 ，如果主键值不小于 320 的话，就到 页32 中查找更详细的 目录项记录 。不过这张图好漂亮喔，随着表中记录的增加，这个目录的层级会继续增加，如果 简化一下，那么我们可以用下边这个图来描述它：

![image-20220909113114301](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909113114301.png)

这玩意儿像不像一个倒过来的 树 呀，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种 数据结构，它的名称是 B+ 树。

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 B+ 树这个数据结构中了， 所以我们也称这些数据页为 节点 。从图中可以看出来，我们的**实际用户记录其实都存放在B+树的最底层的节点 上**，这些节点也被称为 叶子节点 或 叶节点 ，其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点 ，其 中 B+ 树最上边的那个节点也称为 根节点 。

从图中可以看出来，一个 B+ 树的节点其实可以分成好多层，设计 InnoDB 的大叔们为了讨论方便，规定最下边的 那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前的讨论我们做了一个非常极端的假设： 存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录 数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有 存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：

- 如果 B+ 树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
- 如果 B+ 树有2层，最多能存放 1000×100=100000 条记录。
- 如果 B+ 树有3层，最多能存放 1000×1000×100=100000000 条记录。
- 如果 B+ 树有4层，最多能存放 1000×1000×1000×100=100000000000 条记录。哇咔咔～这么多的记录！！！

你的表里能存放 100000000000 条记录么？所以一般情况下，我们用到的 B+ 树都不会超过4层，那我们通过主键 值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内 有所谓的 Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么，哈 哈！

###  聚簇索引

我们上边介绍的 B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

   - 页内的记录是按照主键的大小顺序排成一个单向链表。

   - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。

   - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2. B+ 树的叶子节点存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的 B+ 树称为 `聚簇索引 `，所有完整的用户记录都存放在这个 `聚簇索引 `的叶子节点处。这 种 聚簇索引 并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句）， InnoDB 存储引擎会**自动的为我们创建聚簇索引。**另外有趣的一点是，在 InnoDB 存储引擎中， `聚簇索引 `就是数据的存储方式（所有的用户记录都存储在了 叶子节点 ），也就是所谓的**索引即数据，数据即索引。**

### 二级索引

上边介绍的 聚簇索引 只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照 主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？

不，我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据 页、页中记录的排序规则，再建一棵 B+ 树，效果如下图所示：

![image-20220909141730537](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909141730537.png)

这个 B+ 树与上边介绍的聚簇索引有几处不同：

- 使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：

  - 页内的记录是按照 c2 列的大小顺序排成一个单向链表。

  - 各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。

  - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排成一个双向链表。

- B+ 树的叶子节点存储的并不是完整的用户记录，而只是 `c2列+主键 `这两个列的值。
- 目录项记录中不再是` 主键+页号` 的搭配，而变成了` c2列+页号` 的搭配。

所以如果我们现在想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的 值为 4 的记录为例，查找过程如下：

1. 确定 目录项记录 页
   根据 根页面 ，也就是 页44 ，可以快速定位到 目录项记录 所在的页为 页42 （因为 2 < 4 < 9 ）。

2. 通过 目录项记录 页确定用户记录真实所在的页。
在 页42 中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以 c2 列值为 4 的记录可能分布在多个数据页中，又因为 2 < 4 ≤ 4 ，所以确定实际存储用户记录的页在 页34 和 页35 中。
3. 在真实存储用户记录的页中定位到具体的记录。
到 页34 和 页35 中定位到具体的记录。
4. 但是这个 B+ 树的叶子节点中的记录只存储了 c2 和 c1 （也就是 主键 ）两个列，所以**我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。(回表)**

各位各位，看到步骤4的操作了么？我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值， 所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到 `聚簇索引 `中再查一遍，这个过程也被称 为` 回表` 。也就是根据 c2 列的值查询一条完整的用户记录需要使用到 2 棵 B+ 树！！！

为什么我们还需要一次 `回表` 操作呢？直接把完整的用户记录放到` 叶子节点 `不就好了么？你说的对，如果把完整 的用户记录放到 `叶子节点 `是可以不用 `回表` ，但是太占地方了呀～相当于每建立一棵 B+ 树都需要把所有的用户 记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照 非主键列 建立的 B+ 树需要一次 回表 操作才可 以定位到完整的用户记录，所以这种 B+ 树也被称为` 二级索引 `（英文名 secondary index ），或者 `辅助索引 `。 由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树为**为c2列建立的索引。**

### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照 c2 列进行排序。 
- 在记录的 c2 列相同的情况下，采用 c3 列进行排序

为 c2 和 c3 列建立的索引的示意图如下：

![image-20220909142545170](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220909142545170.png)

如图所示，我们需要注意一下几点：

- 每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。
- B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。

千万要注意一点，**以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的**，不同点如下：

- 建立 联合索引 只会建立如上图一样的1棵 B+ 树。
- 为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。

### InnoDB的B+树索引的注意事项

#### 根页面万年不动窝

我们前边介绍 B+ 树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画 存储目录项记录的内节点，实际上 B+ 树的形成过程是这样的：

- 每当为某个表创建一个 B+ 树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一 个` 根节点` 页面。最开始表中没有数据的时候，每个 B+ 树索引对应的 根节点 中既没有用户记录，也没有目 录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个 `根节点` 中。
- 当 `根节点 `中的可用空间用完时继续插入记录，此时会将 根节点 中的所有记录复制到一个新分配的页，比 如 页a 中，然后对这个新页进行 `页分裂` 的操作，得到另一个新页，比如 页b 。这时新插入的记录根据键值 （也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 页a 或者 页b 中，而 根节点 便升级为存储目录项记录的页。

这个过程需要大家特别注意的是：**一个B+树索引的根节点自诞生之日起，便不会再移动。**这样只要我们对某个表 建立一个索引，那么它的 根节点 的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的 时候，都会从那个固定的地方取出 根节点 的页号，从而来访问这个索引。

#### 一个页面最少存储2条记录

我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上 就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目 录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个 存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以 InnoDB 的 一个数据页至少可以存放两条记录，这也是我们之前唠叨记录行格式的时候说过一个结论（我们当时依据这个结 论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。



# 四、B+树索引的使用

前边详细、详细又详细的唠叨了 InnoDB 存储引擎的 B+ 树索引，我们必须熟悉下边这些结论：

- 每个索引都对应一棵 B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有 用户记录都存储在 B+ 树的叶子节点，所有 目录项记录 都存储在内节点。
- InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立 聚簇索引 ，聚簇索引的叶子节点包含完整的用户记录。
- 我们可以为自己感兴趣的列建立 二级索引 ， 二级索引 的叶子节点包含的用户记录由 索引列 + 主键 组成，所以如果想通过 二级索引 来查找完整的用户记录的话，需要通过 回表 操作，也就是在通过 二级索引找到主键值之后再到 聚簇索引 中查找完整的用户记录。
- B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是 联合索引 的话，则页面和记录先按照 联合索引 前边的列排序，如果该列值相同，再按照 联合索引 后边的列排序。
- 通过索引查找记录是从 B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立Page Directory （页目录），所以在这些页面中的查找非常快。

## 索引的代价

- 空间上的代价

这个是显而易见的，每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页， 一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那可是很大的一片存储空间呢。

- 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且我们讲过， B+ 树每层节点都 是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录 （也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而 增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页 面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都 要进行相关的维护操作，这还能不给性能拖后腿么？

所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好 又少的索引，我们先得学学这些索引在哪些条件下起作用的。

## B+树索引适用的条件

首先， B+ 树索引并不是万能的，并不是所有的查询语句都能用 到我们建立的索引。下边介绍几个我们可能使用 B+ 树索引来进行查询的情况。为了故事的顺利发展，我们需要 先创建一个表，这个表是用来存储人的一些基本信息的：

```sql
CREATE TABLE person_info(
 id INT NOT NULL auto_increment,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

对于这个 person_info 表我们需要注意两点：

- 表中的主键是 id 列，它存储一个自动递增的整数。所以 InnoDB 存储引擎会自动为 id 列建立聚簇索引。
- 我们额外定义了一个二级索引 idx_name_birthday_phone_number ，它是由3个列组成的联合索引。所以在这个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 name 、 birthday 、 phone_number 这三个列的值以及主键 id 的值，并不会保存 country 列的值。

从这两点注意中我们可以再次看到，一个表中有多少索引就会建立多少棵 B+ 树， person_info 表会为聚簇索引 和 idx_name_birthday_phone_number 索引建立2棵 B+ 树。下边我们画一下索引

idx_name_birthday_phone_number 的示意图，不过既然我们已经掌握了 InnoDB 的 B+ 树索引原理，那我们在画 图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内 节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留 name 、 birthday 、 phone_number 、 id 这四个列的真实数据值，所以示意图就长这样

![image-20220910112827150](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220910112827150.png)

为了方便大家理解，我们特意标明了哪些是内节点，哪些是叶子节点。再次强调一下，内节点中存储的是 目录项 记录 ，叶子节点中存储的是 用户记录 （由于不是聚簇索引，所以用户记录是不完整的，缺少 country 列的 值）。从图中可以看出，这个idx_name_birthday_phone_number 索引对应的 B+ 树中页面和记录的排序方式就是 这样的：

- 先按照 name 列的值进行排序。
- 如果 name 列的值相同，则按照 birthday 列的值进行排序。
- 如果 birthday 列的值也相同，则按照 phone_number 的值进行排序。

因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找

### 全值匹配

如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

我们建立的 idx_name_birthday_phone_number 索引包含的3个列在这个查询语句中都展现出来了。大家可以想象 一下这个查询过程：

- 因为 B+ 树的数据页和记录先是按照 name 列的值进行排序的，所以先可以很快定位 name 列的值是 Ashburn的记录位置。
- 在 name 列相同的记录里又是按照 birthday 列的值进行排序的，所以在 name 列的值是 Ashburn 的记录里又可以快速定位 birthday 列的值是 '1990-09-27' 的记录。
- 如果很不幸， name 和 birthday 列的值都是相同的，那记录是按照 phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。

有的同学也许有个疑问， WHERE 子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换 name 、 birthday 、 phone_number 这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样：

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27' AND phone_number = '15123983239' A ND name = 'Ashburn';
```

答案是：没影响哈。 MySQL 有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺 序来决定先使用哪个搜索条件，后使用哪个搜索条件。

### 匹配左边的列

其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn';
```

或者包含多个左边的列也行：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

那为什么搜索条件中必须出现左边的列才可以使用到这个 B+ 树索引呢？比如下边的语句就用不到这个 B+ 树索引 么？

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

是的，的确用不到，因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使 用 birthday 列进行排序，也就是说 name 列的值不同的记录中 birthday 的值可能是无序的。而现在你跳过 name 列直接根据 birthday 的值去查找，臣妾做不到呀～

**如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列**

### 匹配列前缀

我们前边说过为某个列建立索引的意思其实就是在对应的 B+ 树的记录中使用该列的值进行排序，比方说 person_info 表上建立的联合索引 idx_name_birthday_phone_number 会先用 name 列的值进行排序，所以这个 联合索引对应的 B+ 树中的记录的 name 列的排列就是这样的

```
Aaron
Aaron
...
Aaron
Asa
Ashburn
...
Ashburn
Baird
Barlow
...
Barlow
```

字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和 比较规则。这里需要注意的是，一般的比较规则都是逐个比较字符的大 小，也就是说我们比较两个字符串的大小的过程其实是这样的：

- 先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。
- 如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。
- 如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。

所以一个排好序的字符串列其实有这样的特点：

- 先按照字符串的第一个字符进行排序。
- 如果第一个字符相同再按照第二个字符进行排序。
- 如果第二个字符相同再按照第三个字符进行排序，依此类推。

也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配 它的前缀也是可以快速定位记录的，比方说我们想查询名字以 'As' 开头的记录，那就可以这么写查询语句：

SELECT * FROM person_info WHERE name LIKE 'As%';

但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：

SELECT * FROM person_info WHERE name LIKE '%As%';

MySQL 就无法快速定位记录位置了，因为字符串中间有 'As' 的字符串并没有排好序，所以只能全表扫描了。（索引失效）

### 匹配范围值

回头看我们 idx_name_birthday_phone_number 索引的 B+ 树示意图，**所有记录都是按照索引列的值从小到大的顺 序排好序的**，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

由于 B+ 树中的数据页和记录是先按 name 列排序的，所以我们上边的查询过程其实是这样的：

- 找到 name 值为 Asa 的记录。
- 找到 name 值为 Barlow 的记录。
- 哦啦，由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来喽～
- 找到这些记录的主键值，再到 聚簇索引 中 回表 查找完整的记录

不过在使用联合进行范围查找的时候需要注意，**如果对多个列同时进行范围查找的话，只有对索引最左边的那个 列进行范围查找的时候才能用到 B+ 树索引**，比方说这样：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

上边这个查询可以分成两个部分：

1. 通过条件 name > 'Asa' AND name < 'Barlow' 来对 name 进行范围，查找的结果可能有多条 name 值不同的记录，

2. 对这些 name 值不同的记录继续通过 birthday > '1980-01-01' 条件继续过滤。

这样子对于联合索引 idx_name_birthday_phone_number 来说，只能用到 name 列的部分，而用不到 birthday 列 的部分，因为只有 name 值相同的情况下才能用 birthday 列的值进行排序，而这个查询中**通过 name 进行范围查 找的记录中可能并不是按照 birthday 列进行排序的**，所以在搜索条件中继续以 birthday 列进行查找时是用不到 这个 B+ 树索引的。



### 精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精 确查找，则右边的列可以进行范围查找，比方说这样：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

这个查询的条件可以分为3个部分：

1. name = 'Ashburn' ，对 name 列进行精确查找，当然可以使用 B+ 树索引了。
2. birthday > '1980-01-01' AND birthday < '2000-12-31' ，由于 name 列是精确查找，所以通过 name = 'Ashburn' 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序。所以此时 对 birthday 列进行范围查找是可以用到 B+ 树索引的

3. phone_number > '15100000000' ，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个 条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。

同理，下边的查询也是可能用到这个 idx_name_birthday_phone_number 联合索引的：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1980-01-01' AND AND phone
_number > '15100000000';
```

### 用于排序

我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下， 我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对 这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的 空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在 MySQL 中，把这种在内存中或者磁 盘上进行排序的方式统称为文件排序（英文名： filesort ），跟 文件 这个词儿一沾边儿，就显得这些排序操作 非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果 ORDER BY 子句里使用到了我们的 索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

这个查询的结果集需要先按照 name 值排序，如果记录的 name 值相同，则需要按照 birthday 来排序，如果 birthday 的值相同，则需要按照 phone_number 排序。大家可以回过头去看我们建立的 idx_name_birthday_phone_number 索引的示意图，因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直 接从索引中提取数据，然后进行 回表 操作取出该索引中不包含的列就好了。简单吧？是的，索引就是这么牛 逼。

#### 使用联合索引进行排序注意事项

对于 联合索引 有个问题需要注意， ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 ORDER BY phone_number, birthday, name 的顺序，那也是用不了 B+ 树索引

同理， ORDER BY name 、 ORDER BY name, birthday 这种匹配索引左边的列的形式可以使用部分的 B+ 树索引。 当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：

SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;

这个查询能使用联合索引进行排序是因为 name 列的值相同的记录是按照 birthday , phone_number 排序的，说 了好多遍了都。

#### 不可以使用索引进行排序的几种情况

1. 使用联合索引的各个排序列的排序顺序必须是一致的。

2. 排序列包含非同一个索引的列

```sql
SELECT * FROM person_info ORDER BY name, country LIMIT 10;
```

3. 排序列使用了复杂的表达式

### 用于分组

有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：

```sql
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, ph
one_number
```

这个查询语句相当于做了3次分组操作：

1. 先把记录按照 name 值进行分组，所有 name 值相同的记录划分为一组。
2. 将每个 name 值相同的分组里的记录再按照 birthday 的值进行分组，将 birthday 值相同的记录放到一个小
分组里，所以看起来就像在一个大分组里又化分了好多小分组。
3. 再将上一步中产生的小分组按照 phone_number 的值分成更小的分组，所以整体上看起来就像是先把记录分
成一个大分组，然后把 大分组 分成若干个 小分组 ，然后把若干个 小分组 再细分成更多的 小小分组 。

然后针对那些 小小分组 进行统计，比如在我们这个查询语句中就是统计每个 小小分组 包含的记录条数。如果没 有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+ 树 中的索引列的顺序是一致的，而我们的 B+ 树索引又是按照索引列排好序的，这不正好么，所以可以直接使用 B+ 树索引进行分组。

## 回表的代价

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

在使用 idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤：

1. 从索引 idx_name_birthday_phone_number 对应的 B+ 树中取出 name 值在 Asa ～ Barlow 之间的用户记录。
2. 由于索引 idx_name_birthday_phone_number 对应的 B+ 树用户记录中只包含 name 、 birthday 、 phone_number 、 id 这4个字段，而查询列表是 * ，意味着要查询表中所有字段，也就是还要包括 country 字段。这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的 B+ 树中找到完整的用户记 录，也就是我们通常所说的 回表 ，然后把完整的用户记录返回给查询用户。

> 使用索引 idx_name_birthday_phone_number 的查询有这么两个特点：

- 会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。
- 访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O 。

**需要回表的记录越多，使用二级索引的性能就越低**，甚至让某些查询宁愿使用全表扫描也不使用 二级索引 。比 方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用 idx_name_birthday_phone_number 索引的话，有90%多的 id 值需要回表，这不是吃力不讨好么，还不如直接去 扫描聚簇索引（也就是全表扫描）。

那什么时候采用全表扫描的方式，什么时候使用采用 二级索引 + 回表 的方式去执行查询呢？这个就是传说中的 查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的 条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索 引 + 回表 的方式。一般情况下，**限制 查询获取较少的记录数会让优化器更倾向于选择使用 二级索引 + 回表 的方式进行查询**，因为回表的记录越少， 性能提升就越高，比方说上边的查询可以改写成这样：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
```

添加了 LIMIT 10 的查询更容易让优化器采用 二级索引 + 回表 的方式进行查询。

对于有排序需求的查询，上边讨论的采用 全表扫描 还是 二级索引 + 回表 的方式进行查询的条件也是成立的， 比方说下边这个查询：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number;
```

由于查询列表是 * ，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这 样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（ filesort ）低，所以优化器会倾向于使用 全表扫 描 的方式执行查询。如果我们加了 LIMIT 子句，比如这样

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

这样需要回表的记录特别少，优化器就会倾向于使用 二级索引 + 回表 的方式执行查询。

### 覆盖索引

为了彻底告别 回表 操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列，比如这样：

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlo
w'
```

因为我们只查询 name , birthday , phone_number 这三个索引列的值，所以在通过 idx_name_birthday_phone_number 索引得到结果后就不必到 聚簇索引 中再查找记录的剩余列，也就是 country 列的值了，这样就省去了 回表 操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为 索引 覆盖 。排序操作也优先使用 覆盖索引 的方式进行查询，比方说这个查询：

```sql
SELECT name, birthday, phone_number FROM person_info ORDER BY name, birthday, phone_numbe
r;
```

虽然这个查询中没有 LIMIT 子句，但是采用了 覆盖索引 ，所以查询优化器就会直接使用 idx_name_birthday_phone_number 索引进行排序而不需要回表操作了。 当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是**我们很不鼓励用 * 号作为查询列 表，最好把我们需要查询的列依次标明。**

所以我们写sql的时候，查询列表一般要写具体的，不要写全部，因为写全部一般情况都会进行回表！

## 如何挑选索引

上边我们以 idx_name_birthday_phone_number 索引为例对索引的适用条件进行了详细的唠叨，下边看一下我们 在建立索引时或者编写查询语句时就应该注意的一些事项。

### 只为用于搜索、排序或分组的列创建索引

也就是说，只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的 列创建索引。而出现在查询列表中的列就没必要建立索引了：

```sql
SELECT birthday, country FROM person name WHERE name = 'Ashburn';
```

像查询列表中的 birthday 、 country 这两个列就不需要建立索引，我们只需要为出现在 WHERE 子句中的 name 列创建索引就可以了。

### 考虑列的基数

列的基数 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有 9 条 记录，但该列的基数却是 3 。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基 数越小，该列中的值越集中。**

**最好为那些列的基数大的列建立索引，为基数 太小列的建立索引效果可能不好。**

### 索引列的类型尽量小

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 TINYINT 、 MEDIUMINT 、 INT 、 BIGINT 这么几种，它们占用的存储空间依次递增，我们这里所说的 类型大小 指的就是**该类型表示的数据范围的大小。**

在表示的整数范围允许的情况 下，尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用 INT ～ 这是因为：

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东） 
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带 来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会 存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/O 。

### 索引字符串值的前缀

我们知道一个字符串其实是由若干个字符组成，如果我们在 MySQL 中使用 utf8 字符集去存储字符串的话，编码 一个字符需要占用 1~3 个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们 需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有这么两个问题：

- B+ 树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。
- 如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。

我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 --- **只对字符串的前几 个字符进行索引**也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位 到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串 值，再对比就好了。这样只在 B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时 间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对 name 列的前10个字符进行索引可以 这么写：

```sql
CREATE TABLE person_info(
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
); 
```

name(10) 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码，这种**只索引字符串值的前缀的策略是 我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。**

#### 索引列前缀对排序的影响

如果使用了索引列前缀，比方说前边只把 name 列的前10个字符放到了二级索引中，下边这个查询可能就有点儿 尴尬了：

```sql
SELECT * FROM person_info ORDER BY name LIMIT 10;
```

因为二级索引中不包含完整的 name 列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也 就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。

### 让索引列在比较表达式中单独出现

假设表中有一个整数列 my_col ，我们为这个列建立了索引。下边的两个 WHERE 子句虽然语义是一致的，但是在 效率上却有差别：

```sql
WHERE my_col * 2 < 4
WHERE my_col < 4/2
```

**如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出 现的话，是用不到索引的。**

### 主键插入顺序

我们知道，对于一个使用 InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存 储在 聚簇索引 的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺 序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页 继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存 储的主键值在 1~100 之间：

![image-20220910154856021](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220910154856021.png)

如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：

![image-20220910154904634](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220910154904634.png)

可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到 新创建的这个页中。页面分裂和记录移位意味着什么？意味着：**性能损耗！**所以如果我们想尽量避免这样无谓的 性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具 有 AUTO_INCREMENT ，**让存储引擎自己为表生成主键，而不是我们手动插入** ，比方说我们可以这样定义person_info 表：

```sql
CREATE TABLE person_info(
 id INT UNSIGNED NOT NULL AUTO_INCREMENT,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
); 
```

我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。

### 冗余和重复索引

有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：

```sql
CREATE TABLE person_info(
 id INT UNSIGNED NOT NULL AUTO_INCREMENT,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
 KEY idx_name (name(10))
); 
```

我们知道，通过` idx_name_birthday_phone_number` 索引就可以对 name 列进行快速搜索，再创建一个专门针对 `name` 列的索引就算是一个 **冗余 索引**，维护这个索引只会`增加维护的成本`，并不会对搜索有什么好处。 另一种情况，我们可能会对某个列重复建立索引，比方说这样：

```sql
CREATE TABLE repeat_index_demo (
 c1 INT PRIMARY KEY,
 c2 INT,
 UNIQUE uidx_c1 (c1),
 INDEX idx_c1 (c1)
); 
```

我们看到，` c1 `既是主键、又给它定义为一个`唯一索引`，还给它定义了一个`普通索引`，可是主键本身就会生成聚 簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。

## 总结

1. B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。

2. B+ 树索引适用于下边这些情况：
1. 全值匹配
2. 匹配左边的列
3. 匹配范围值
4. 精确匹配某一列并范围匹配另外一列
5. 用于排序
6. 用于分组
3. 在使用索引时需要注意下边这些事项：
1. 只为用于搜索、排序或分组的列创建索引
2. 为列的基数大的列创建索引
3. 索引列的类型尽量小
4. 可以只对字符串值的前缀建立索引
5. 只有索引列在比较表达式中单独出现才可以适用索引
6. 为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。
7. 定位并删除表中的重复和冗余索引
8. 尽量使用 覆盖索引 进行查询，避免 回表 带来的性能损耗。

# 















































































