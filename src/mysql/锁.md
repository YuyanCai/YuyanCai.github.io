---
title: 锁
---
# 工作面试老大难-锁

## 并发事务访问相同记录的情况

并发事务访问相同记录的情况大致可以划分为3种：

### 读-读 情况

即并发事务相继读取相同的记录。

读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。

### **写-写** 情况

即并发事务相继对相同的记录做出改动。

我们前边说过，在这种情况下会发生 `脏写` 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多 个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过` 锁 `来实现的。 这个所谓的 锁 其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和 记录进行关联的，如图所示：

![image-20221102103605944](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102103605944.png)

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 `锁结构` ，当没有的时候就 会在内存中生成一个 `锁结构 `与之关联。比方说事务 T1 要对这条记录做改动，就需要生成一个 `锁结构 `与之 关联：

![image-20221102103832967](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102103832967.png)

其实在 `锁结构` 里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：

- trx信息 ：代表这个锁结构是哪个事务生成的。
- is_waiting ：代表当前事务是否在等待。

如图所示，当事务 T1 改动了这条记录后，就生成了一个` 锁结构 `与该记录关联，因为之前没有别的事务 为这条记录加锁，所以 is_waiting 属性就是 false ，**我们把这个场景就称之为获取锁成功**，或者加锁 成功，然后就可以继续执行操作了。



在事务 T1 提交之前，另一个事务 T2 也想对该记录做改动，那么先去看看有没有 `锁结构` 与这条记录关 联，发现有一个 `锁结构` 与之关联后，然后也生成了一个 锁结构 与这条记录关联，不过 锁结构 的 is_waiting 属性值为 true ，表示当前事务需要等待，我们把这个场景就称之为**获取锁失败，或者加锁 失败，或者没有成功的获取到锁**，画个图表示就是这样：



![image-20221102104114255](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102104114255.png)

在事务 T1 提交之后，就会把该事务生成的 锁结构 释放掉，然后看看还有没有别的事务在等待获取锁， 发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 is_waiting 属性设置为 false ，然后 把该事务对应的线程唤醒，让它继续执行，此时事务 T2 就算获取到锁了。效果图就是这样：

![image-20221102104208301](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102104208301.png)

我们总结一下后续内容中可能用到的几种说法，以免大家混淆：

- 不加锁

意思就是不需要在内存中生成对应的 `锁结构` ，可以直接执行操作。

- 获取锁成功，或者加锁成功

意思就是在内存中生成了对应的 `锁结构` ，而且锁结构的` is_waiting `属性为` false` ，也就是事务可以继续执行操作。

- 获取锁失败，或者加锁失败，或者没有获取到锁

意思就是在内存中生成了对应的` 锁结构 `，不过锁结构的` is_waiting `属性为` true `，也就是事务需要等待，不可以继续执行操作。

> 小贴士： 这里只是对锁结构做了一个非常简单的描述，我们后边会详细唠叨唠叨锁结构的，稍安勿躁

### 读-写 或 写-读 情况

也就是一个事务进行读取操作，另一个进行改动操作。

我们前边说过，这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

SQL标准 规定不同隔离级别下可能发生的问题不一样：

- 在 READ UNCOMMITTED 隔离级别下， 脏读 、 不可重复读 、 幻读 都可能发生。
- 在 READ COMMITTED 隔离级别下， 不可重复读 、 幻读 可能发生， 脏读 不可以发生。
- 在 REPEATABLE READ 隔离级别下， 幻读 可能发生， 脏读 和 不可重复读 不可以发生。
- 在 SERIALIZABLE 隔离级别下，上述问题都不可以发生。

不过各个数据库厂商对 `SQL标准 `的支持都可能不一样，与 `SQL标准` 不同的一点就是， `MySQL` 在`REPEATABLE READ` 隔离级别实际上就已经解决了 幻读 问题。



怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有两种可选的解决方案：

**方案一：读操作利用多版本并发控制（ MVCC ），写操作进行 加锁 。**

MVCC我们前面学过,就是生成一个readView,然后通过readview找到符合条件的记录版本(undo 日志),其实就像是在生成ReadView的那个时刻做了一次时间静止(就像用相机拍了一个快照),查询语句只能读到生成ReadView之前已提交事务所做的更改,在生成ReadView之前未提交的事务或者是之后开启的事务所做的更改是看不到的.而写操作肯定是针对的最新版本的记录,读记录的历史版本和改动记录的最新版本本身并不冲突,也就是采用MVCC时,`读-写`操作并不冲突

> Tips:
>
> 在Read COMMIT隔离级别下,一个事务在执行过程中每次执行select语句操作都会生成一个ReadView,ReadView的存在本身就保证了事务不可以读取到未提交事务所做的更改,也就是避免了脏读现象;
>
> REPEATABLE READ隔离级别下,一个事务在执行过程中只有第一次select才会生成一个ReadView,之后的SELECT操作都重复用这个ReadView,这样也就避免了不可重复读和幻读的问题.

**方案二：读、写操作都采用 加锁 的方式**

如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银 行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库 中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事 务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行 加锁 操作，这样也就意味着 读 操 作和 写 操作也像 写-写 操作那样排队执行。

> Tips:
>
> 我们说脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务 在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有 脏读问题的产生了。
>
> 不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记 录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录 时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。
>
> 我们 说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了 新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录 称之为幻影记录。**采用加锁的方式解决幻读问题就有那么一丢丢麻烦了，因为当前事务在第一 次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点尴尬 —— 因为你并不知道 给谁加锁**，没关系，这难不倒设计InnoDB的大叔的，我们稍后揭晓答案，稍安勿躁。

很明显，采用 MVCC 方式的话， 读-写 操作彼此并不冲突，性能更高，采用 加锁 方式的话， 读-写 操 作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问 题，但是业务在某些特殊情况下，要求必须采用 加锁 的方式执行，那也是没有办法的事。

## 解决并发事务带来问题的两种基本方式

### 一致性读（Consistent Reads）

事务利用MVCC进行的读取操作称之为一致性读,或快照读



所有普通的SELECT 语句（ plain SELECT ）在 READ COMMITTED 、 REPEATABLE READ 隔离级别下都算是 一致性读 ，比方说：

SELECT * FROM t; SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2



一致性读 并不会对表中的任何记录做 加锁 操作，其他事务可以自由的对表中的记录做改动。

### 锁定读（Locking Reads）

#### 共享锁和独占锁

我们前边说过，并发事务的 读-读 情况并不会引起什么问题，不过对于 写-写 、 读-写 或 写-读 这些情况可能 会引起一些问题，需要使用 MVCC 或者 加锁 的方式来解决它们。在使用 加锁 的方式解决问题时，由于既要允 许 读-读 情况不受影响，又要使 写-写 、 读-写 或 写-读 情况中的操作相互阻塞，所以设计 MySQL 的大叔给锁 分了个类：

- 共享锁 ，英文名： Shared Locks ，简称 S锁 。在事务要读取一条记录时，需要先获取该记录的 S锁 。
- 独占锁 ，也常称 排他锁 ，英文名： Exclusive Locks ，简称 X锁 。在事务要改动一条记录时，需要先获 取该记录的 X锁 。



假如事务 T1 首先获取了一条记录的 S锁 之后，事务 T2 接着也要访问这条记录：

- 如果事务 T2 想要再获取一个记录的 S锁 ，那么事务 T2 也会获得该锁，也就意味着事务 T1 和 T2 在该记录 上同时持有 S锁 。
- 如果事务 T2 想要再获取一个记录的 X锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S锁 释放掉。



如果事务 T1 首先获取了一条记录的 X锁 之后，那么不管事务 T2 接着想获取该记录的 S锁 还是 X锁 都会被阻 塞，直到事务 T1 提交。



所以我们说 S锁 和 S锁 是兼容的， S锁 和 X锁 是不兼容的， X锁 和 X锁 也是不兼容的，画个表表示一下就是这 样：

兼容性 	X 		S
X 		不兼容 	不兼容
S 		不兼容 	兼容



#### 锁定读的语句

我们前边说在采用 加锁 方式解决 脏读 、 不可重复读 、 幻读 这些问题时，读取一条记录时需要获取一下该记 录的 S锁 ，其实这是不严谨的，有时候想在读取记录时就获取记录的 X锁 ，来禁止别的事务读写该记录，为此设 计 MySQL 的大叔提出了两种比较特殊的 SELECT 语句格式：

- 对读取的记录加 S锁 ：

​	SELECT ... LOCK IN SHARE MODE;

也就是在普通的 SELECT 语句后边加 `LOCK IN SHARE MODE` ，如果当前事务执行了该语句，那么它会为读取到 的记录加 S锁 ，这样允许别的事务继续获取这些记录的 S锁 （比方说别的事务也使用 SELECT ... LOCK IN SHARE MODE 语句来读取这些记录），但是不能获取这些记录的 X锁 （比方说使用 SELECT ... FOR UPDATE 语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的 X锁 ，那么它们会阻 塞，直到当前事务提交之后将这些记录上的 S锁 释放掉。

- 对读取的记录加 X锁 ：

  SELECT ... FOR UPDATE;

也就是在普通的 SELECT 语句后边加 `FOR UPDATE `，如果当前事务执行了该语句，那么它会为读取到的记录 加 X锁 ，这样既不允许别的事务获取这些记录的 S锁 （比方说别的事务使用 SELECT ... LOCK IN SHARE MODE 语句来读取这些记录），也不允许获取这些记录的 X锁 （比方也说使用 SELECT ... FOR UPDATE 语句 来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的 S锁 或者 X锁 ，那么它们会 阻塞，直到当前事务提交之后将这些记录上的 X锁 释放掉。

### 写操作

平常所用到的 写操作 无非是` DELETE 、 UPDATE 、 INSERT`这三种：

- DELETE ：
  - 对一条记录做 DELETE 操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取一下这条记录的 X锁 ，然后再执行 delete mark 操作。我们也可以把这个定位待删除记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 。

- UPDATE ：

  - 在对一条记录做 UPDATE 操作时分为三种情况：

    - 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X锁 ，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 。

    - 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+ 树中定位到这条记录的位置，然后获取一下记录的 X锁 ，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 ，新插入的记录由 INSERT 操作提供的 隐式锁 进行保护。

    - 如果修改了该记录的键值，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT 操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。

- INSERT ：
  - 一般情况下，新插入一条记录的操作并不加锁，设计 InnoDB 的大叔通过一种称之为 隐式锁(MDL) 的东东来保护这条新插入的记录在本事务提交前不被别的事务访问，更多细节我们后边看哈～

> Tips：
> 当然，在一些特殊情况下INSERT操作也是会获取锁的，具体情况我们后边唠叨。

## 多粒度锁

我们前边提到的 锁 都是针对记录的，也可以被称之为 行级锁 或者 行锁 ，对一条记录加锁影响的也只是这条记 录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在 表 级别进行加锁，自然就被称之为 表级锁 或 者 表锁 ，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为 共享锁 （ S锁 ）和 独占锁 （ X锁 ）：

- 给表加 S锁 ：
  - 如果一个事务给表加了 S锁 ，那么：
    - 别的事务可以继续获得该表的 S锁
    - 别的事务可以继续获得该表中的某些记录的 S锁
    - 别的事务不可以继续获得该表的 X锁
    - 别的事务不可以继续获得该表中的某些记录的 X锁
- 给表加 X锁 ：
  - 如果一个事务给表加了 X锁 （意味着该事务要独占这个表），那么：
    - 别的事务不可以继续获得该表的 S锁
    - 别的事务不可以继续获得该表中的某些记录的 S锁
    - 别的事务不可以继续获得该表的 X锁
    - 别的事务不可以继续获得该表中的某些记录的 X锁

### 举例说明

![image-20221102153339119](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102153339119.png)

但是这里头有两个问题：

- 如果我们想对教学楼整体上 S锁 ，首先需要确保教学楼中的没有正在维修的教室，如果有正在维修的教室， 需要等到维修结束才可以对教学楼整体上S锁 。
- 如果我们想对教学楼整体上 X锁 ，首先需要确保教学楼中的没有上自习的教室以及正在维修的教室，如果有 上自习的教室或者正在维修的教室，需要等到全部上自习的同学都上完自习离开，以及维修工维修完教室离 开后才可以对教学楼整体上 X锁 。



我们在对教学楼整体上锁（ 表锁 ）时，怎么知道教学楼中有没有教室已经被上锁（ 行锁 ）了呢？依次检查每一 间教室门口有没有上锁？那这效率也太慢了吧！**遍历是不可能遍历的，这辈子也不可能遍历的**，于是乎设计 InnoDB 的大叔们提出了一种称之为 **`意向锁 `**（英文名： Intention Locks ）的东东：

- 意向共享锁，英文名： Intention Shared Lock ，简称 IS锁 。当事务准备在某条记录上加 S锁 时，需要先 在表级别加一个 IS锁 。
- 意向独占锁，英文名： Intention Exclusive Lock ，简称 IX锁 。当事务准备在某条记录上加 X锁 时，需 要先在表级别加一个 IX锁 。

视角回到教学楼和教室上来：

- **如果有学生到教室中上自习，那么他先在整栋教学楼门口放一把 IS锁 （表级锁），然后再到教室门口放一 把 S锁 （行锁）。**
- **如果有维修工到教室中维修，那么它先在整栋教学楼门口放一把 IX锁 （表级锁），然后再到教室门口放一 把 X锁 （行锁）。**

之后：

- 如果有领导要参观教学楼，也就是想在教学楼门口前放 S锁 （表锁）时，首先要看一下教学楼门口有没有 IX锁 ，如果有，意味着有教室在维修，需要等到维修结束把 IX锁 撤掉后才可以在整栋教学楼上加 S锁 。
- 如果有考试要占用教学楼，也就是想在教学楼门口前放 X锁 （表锁）时，首先要看一下教学楼门口有没有 IS锁 或 IX锁 ，如果有，意味着有教室在上自习或者维修，需要等到学生们上完自习以及维修结束把 IS锁 和 IX锁 撤掉后才可以在整栋教学楼上加 X锁 。

> Tips：
>
> 学生在教学楼门口加IS锁时，是不关心教学楼门口是否有IX锁的，维修工在教学楼门口加IX锁时，是不关心教学楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间教学楼里有没有被占用的 教室用的，也就是在对教学楼加S锁或者X锁时才会用到。

总结一下：**IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否 被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。我们画个表来看一下表级别的各种锁的兼容性：**

兼容性 		X 		IX 		S 		IS
X 			不兼容 	不兼容 	 不兼容 	不兼容
IX 		   不兼容 	兼容 	   不兼容 	兼容
S 			不兼容 	不兼容 	 兼容 	  兼容
IS 		   不兼容 	兼容 	   兼容 	 兼容

## MySQL中的行锁和表锁

### 其他存储引擎中的锁

对于 MyISAM 、 MEMORY 、 MERGE 这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使 用这些存储引擎的锁一般都是针对当前会话来说的。比方说在 Session 1 中对一个表执行 SELECT 操作，就相当 于为这个表加了一个表级别的 S锁 ，如果在 SELECT 操作未完成时， Session 2 中对这个表执行 UPDATE 操作， 相当于要获取表的 X锁 ，此操作会被阻塞，直到 Session 1 中的 SELECT 操作完成，释放掉表级别的 S锁 后， Session 2 中对这个表执行 UPDATE 操作才能继续获取 X锁 ，然后执行具体的更新语句。

> Tips：
>
> 因为使用MyISAM、MEMORY、MERGE这些存储引擎的表在同一时刻只允许一个会话对表进行写操作，所以 这些存储引擎实际上最好用在只读，或者大部分都是读操作，或者单用户的情景下。

### InnoDB存储引擎中的锁

InnoDB 存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要 锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更 精准的并发控制。下边我们详细看一下。

#### InnoDB中的表级锁

- 表级别的 S锁 、 X锁

在对某个表执行 `SELECT 、 INSERT 、 DELETE 、 UPDATE` 语句时， **InnoDB 存储引擎是不会为这个表添加表 级别的 S锁 或者 X锁 的。**

另外，在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执 行诸如 SELECT 、 INSERT 、 DELETE 、 UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。这个 过程其实是通过在 server层 使用一种称之为 `元数据锁` （英文名： Metadata Locks ，简称 MDL ）东东来实 现的，一般情况下也不会使用 InnoDB 存储引擎自己提供的表级别的 S锁 和 X锁 。

> Tips：
>
> 在事务简介的章节中我们说过，DDL语句执行时会隐式的提交当前会话中的事务，这主要是DDL语 句的执行一般都会在若干个特殊事务中完成，在开启这些特殊事务前，需要将当前会话中的事务提 交掉。另外，关于MDL锁并不是我们本章所要讨论的范围，大家可以参阅文档了解哈～

其实这个 InnoDB 存储引擎提供的表级 S锁 或者 X锁 是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复 过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量 autocommit=0，innodb_table_locks = 1 时，手动获取 InnoDB 存储引擎提供的表 t 的 S锁 或者 X锁 可以这么写：

- LOCK TABLES t READ ： InnoDB 存储引擎会对表 t 加表级别的 S锁 。
- LOCK TABLES t WRITE ： InnoDB 存储引擎会对表 t 加表级别的 X锁 。

不过请尽量避免在使用 InnoDB 存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提 供什么额外的保护，只是会降低并发能力而已。 InnoDB 的厉害之处还是实现了更细粒度的行锁，**关于 表级别的 S锁 和 X锁 大家了解一下就罢了。**

- 表级别的 IS锁 、 IX锁

当我们在对使用 InnoDB 存储引擎的表的某些记录加 S锁 之前，那就需要先在表级别加一个 IS锁 ，当我们 在对使用 InnoDB 存储引擎的表的某些记录加 X锁 之前，那就需要先在表级别加一个 IX锁 。 **IS锁 和 IX锁 的使命只是为了后续在加表级别的 S锁 和 X锁 时判断表中是否有已经被加锁的记录，以避免用遍历的方式来 查看表中有没有上锁的记录。**更多关于 IS锁 和 IX锁 的解释我们上边都唠叨过了，就不赘述了。

- 表级别的 AUTO-INC锁

在使用 MySQL 过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性，之后在插入记录时，可以不指定 该列的值，系统会自动为它赋上递增的值，比方说我们有一个表：

```sql
CREATE TABLE t (
 id INT NOT NULL AUTO_INCREMENT,
 c VARCHAR(100),
 PRIMARY KEY (id)
 ) Engine=InnoDB CHARSET=utf8;
```

由于这个表的 id 字段声明了 AUTO_INCREMENT ，也就意味着在书写插入语句时不需要为其赋值，比方说这 样：

INSERT INTO t(c) VALUES('aa'), ('bb');

上边的插入语句并没有为 id 列显式赋值，所以系统会自动为它赋上递增的值，效果就是这样：

```sql
mysql> SELECT * FROM t;
 +----+------+
 | id | c |
 +----+------+
 | 1 | aa |
 | 2 | bb |
 +----+------+
 2 rows in set (0.00 sec)
```

系统实现这种自动给 AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：

- 采用 AUTO-INC 锁，也就是在执行插入语句时就在表级别加一个 AUTO-INC 锁，然后为每条待插入记录 的 AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把 AUTO-INC 锁释放掉。这样一个 事务在持有 AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增 值是连续的。

如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比 方说使用 INSERT ... SELECT 、 REPLACE ... SELECT 或者 LOAD DATA 这种插入语句，一般是使用 AUTO-INC 锁为 AUTO_INCREMENT 修饰的列生成对应的值。

>  需要注意一下的是，这个AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后， 这个锁就被释放了，

- 采用一个轻量级的锁，在为插入语句生成 AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁，然 后生成本次插入语句需要用到的 AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉，并不需要等到 整个插入语句执行完才释放锁。

如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表 t 的例子 中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对 AUTO_INCREMENT 修饰的 列进行赋值。这种方式可以避免锁定表，可以提升插入性能。

> 设计InnoDB的大叔提供了一个称之为innodb_autoinc_lock_mode的系统变量来控制到底使用上 述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值
>
> 当innodb_autoinc_lock_mode值 为0时，一律采用AUTO-INC锁；
>
> 当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁；
>
> 当 innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入记录数量确定时采用轻 量级锁，不确定时使用AUTO-INC锁）
>
> **当innodb_autoinc_lock_mode值为2时，可能会造 成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景 中是不安全的。**

#### InnoDB中的行级锁(重点)

真正的重点才刚刚开始!

行锁 ，也称为 记录锁 ，顾名思义就是在记录上加的锁。不过设计 InnoDB 的大叔很有才，一个 行锁 玩出了各 种花样，也就是把 行锁 分成了各种类型。换句话说即使对同一条记录加 行锁 ，**如果类型不同，起到的功效也是 不同的**.

![image-20221102161030244](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161030244.png)

我们把 hero 表中的聚簇索引的示意图画一下：

![image-20221102161118009](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161118009.png)

当然，我们把 B+树 的索引结构做了一个超级简化，只把索引中的记录给拿了出来，我们这里只是想强调聚簇索 引中的记录是按照主键大小排序的，并且省略掉了聚簇索引中的隐藏列

现在准备工作做完了，下边我们来看看都有哪些常用的 行锁类型 。

##### Record Locks(记录锁)

我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上，我决定给这种类型的锁起一个比较不正 经的名字： 正经记录锁 （请允许我皮一下，我实在不知道该叫个啥名好）。官方的类型名称为： LOCK_REC_NOT_GAP 。比方说我们把 number 值为 8 的那条记录加一个 正经记录锁 的示意图如下：

![image-20221102161317227](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161317227.png)

正经记录锁 是有 S锁 和 X锁 之分的，让我们分别称之为 S型正经记录锁 和 X型正经记录锁 吧（听起来有 点怪怪的），当一个事务获取了一条记录的 S型正经记录锁 后，其他事务也可以继续获取该记录的 S型正经 记录锁 ，但不可以继续获取 X型正经记录锁 ；当一个事务获取了一条记录的 X型正经记录锁 后，其他事务 既不可以继续获取该记录的 S型正经记录锁 ，也不可以继续获取 X型正经记录锁 ；

##### Gap Locks(间隙锁)

我们说 MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方 案解决，也可以采用 加锁 方案解决。但是在使用 加锁 方案解决时有个大问题，就是事务在第一次执行读取 操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上 正经记录锁 。不过这难不倒设计 InnoDB 的 大叔，他们提出了一种称之为 Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们也可以简称为 gap 锁 。比方说我们把 number 值为 8 的那条记录加一个 gap锁 的示意图如下：

![image-20221102161917072](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102161917072.png)



如图中为 number 值为 8 的记录加了 gap锁 ，意味着不允许别的事务在 number 值为 8 的记录前边的 间隙 插入新记录，其实就是 number 列的值 (3, 8) 这个区间的新记录是不允许立即插入的。比方说有另外一个事 务再想插入一条 number 值为 4 的新记录，它定位到该条新记录的下一条记录的 number 值为8，而这条记录 上又有一个 gap锁 ，所以就会阻塞插入操作，直到拥有这个 gap锁 的事务提交了之后， number 列的值在区 间 (3, 8) 中的新记录才可以被插入。

这个 gap锁 的提出**仅仅是为了防止插入幻影记录而提出的**，虽然有 共享gap锁 和 独占gap锁 这样的说法， 但是它们起到的作用都是相同的。而且如果你对一条记录加了 gap锁 （不论是 共享gap锁 还是 独占gap 锁 ），并不会限制其他事务对这条记录加 正经记录锁 或者继续加 gap锁 ，再强调一遍， **gap锁 的作用仅 仅是为了防止插入幻影记录的而已。**

不知道大家发现了一个问题没，给**一条记录加了 gap锁 只是不允许其他事务往这条记录前边的间隙插入新记 录**，那对于最后一条记录之后的间隙，也就是 hero 表中 number 值为 20 的记录之后的间隙该咋办呢？也就 是说给哪条记录加 gap锁 才能阻止其他事务插入 number 值在 (20, +∞) 这个区间的新记录呢？这时候应该 想起我们在前边唠叨 数据页 时介绍的两条伪记录了：

- **Infimum 记录，表示该页面中最小的记录。**

- **Supremum 记录，表示该页面中最大的记录。**

![image-20221102162712278](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102162712278.png)

**Infimum + Supremum 最小记录和最大记录 26 字节 两个虚拟的行记录**



记录在页中的存储如下:

![image-20221102162350635](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102162350635.png)



为了实现阻止其他事务插入 number 值在 (20, +∞) 这个区间的新记录，我们可以给索引中的最后一条 记录，也就是 number 值为 20 的那条记录所在页面的 `Supremum` 记录加上一个 gap锁 ，画个图就是这 样：

![image-20221102162429998](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102162429998.png)

这样就可以阻止其他事务插入 number 值在 (20, +∞) 这个区间的新记录。为了大家理解方便，之后的 索引示意图中都会把这个 Supremum 记录画出来。

##### Next-Key Locks

有时候我们既想**锁住某条记录，又想阻止其他事务在该记录前边的 间隙 插入新记录**，所以设计 InnoDB 的大 叔们就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。比方说我们把 number 值为 8 的那条记录加一个 next-key锁 的示意图如下：

![image-20221102163248125](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102163248125.png)

next-key锁 的本质就是一个 正经记录锁 和一个 gap锁 的合体，它既能保护该条记录，又能阻止别的事务 将新记录插入被保护记录前边的 间隙 。

##### Insert Intention Locks(插入意向锁)

我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的 gap锁 （ next-key 锁 也包含 gap锁 ，后边就不强调了），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提 交。但是设计 InnoDB 的大叔规定**`事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某 个 间隙 中插入新记录，但是现在在等待`。**设计 InnoDB 的大叔就把这种类型的锁命名为 Insert Intention Locks ，官方的类型名称为：` LOCK_INSERT_INTENTION` ，我们也可以称为 `插入意向锁` 。

比方说我们把 number 值为 8 的那条记录加一个` 插入意向锁` 的示意图如下：

![image-20221102163647682](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102163647682.png)

为了让大家彻底理解这个 插入意向锁 的功能，我们还是举个例子然后画个图表示一下。比方说现在 T1 为 number 值为 8 的记录加了一个 gap锁 ，然后 T2 和 T3 分别想向 hero 表中插入 number 值分别为 4 、 5 的 两条记录，所以现在为 number 值为 8 的记录加的锁的示意图就如下所示：

![image-20221102163934813](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102163934813.png)

> 我们在锁结构中又新添了一个type属性，表明该锁的类型。稍后会全面介绍InnoDB存储引擎中的 一个锁结构到底长什么样。

从图中可以看到，由于 T1 持有 gap锁 ，所以 T2 和 T3 需要生成一个 插入意向锁 的 锁结构 并且处于等待 状态。

当 T1 提交后会把它获取到的锁都释放掉，这样 T2 和 T3 就能获取到对应的 插入意向锁 了（本质上 就是把插入意向锁对应锁结构的 is_waiting 属性改为 false ）， T2 和 T3 之间也并不会相互阻塞，它们可 以同时获取到 number 值为8的 插入意向锁 ，然后执行插入操作。事实上**插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁（插入意向锁就是这么鸡肋）。**

##### 隐式锁

我们前边说一个事务在执行 INSERT 操作时，如果即将插入的 间隙 已经被其他事务加了 gap锁 ，那么本次 INSERT 操作会阻塞，并且当前事务会在该间隙上加一个 插入意向锁 ，否则一般情况下 INSERT 操作是不加 锁的。

那如果**一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：**

- 立即使用 SELECT ... LOCK IN SHARE MODE 语句读取这条事务，也就是在要获取这条记录的 S锁 ，或者 使用 SELECT ... FOR UPDATE 语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的 X 锁 ，该咋办？


​	如果允许这种情况的发生，那么可能产生 脏读 问题。

- 立即修改这条记录，也就是要获取这条记录的 X锁 ，该咋办？

​	如果允许这种情况的发生，那么可能产生 脏写 问题。 这时候我们前边唠叨了很多遍的 事务id 又要起作用了。我们把聚簇索引和二级索引中的记录分开看一 下：

![image-20221102170423825](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102170423825.png)

## Mysql是怎么加锁的

因为行级锁加锁规则比较复杂，不同的场景，加锁的形式还不同

对记录加锁时，**加锁的基本单位是 next-key lock**，它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间**。

但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。

实验的表格如下:

![image-20221102201813752](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102201813752.png)

其中，id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。

> **非唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中可以重复，不要求唯一**
>
> 如联合索引

### 唯一索引等值查询

当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：

- **当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」**。
- **当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」**。

接下里用两个案例来说明。

> 先看看记录是存在的。

来看下面这个例子：

![image-20221102200941187](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102200941187.png)

会话1加锁变化过程如下：

1. **加锁的基本单位是 next-key lock**，因此会话1的加锁范围是(8, 16];
2. 但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 **next-key lock 退化成记录锁，因此最终加锁的范围是 id = 16 这一行**。

所以，会话 2 在修改 id=16 的记录时会被锁住，而会话 3 插入 id=9 的记录可以被正常执行。

> 接下来，看看记录不存在的情况

来看看，下面这个例子：

![image-20221102202915633](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102202915633.png)

会话1加锁变化过程如下：

1. 加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是(8, 16];
2. 但是由于查询记录不存在，next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。

所以，会话 2 要往这个间隙里面插入 id=9 的记录会被锁住，但是会话 3 修改 id =16 是可以正常执行的，因为 id = 16 这条记录并没有加锁。

### 唯一索引范围查询

范围查询和等值查询的加锁规则是不同的。

举个例子，下面这两条查询语句，查询的结果虽然是一样的，但是加锁的范围是不一样的。

```text
select * from t_test where id=8 for update;
select * from t_test where id>=8 and id<9 for update;
```

做个实验就知道了。

![image-20221102203352979](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102203352979.png)

会话 1 加锁变化过程如下：

1. 最开始要找的第一行是 id = 8，因此 next-key lock(4,8]，但是由于 id 是唯一索引，且该记录是存在的，因此会退化成记录锁，也就是只会对 id = 8 这一行加锁；
2. 由于是范围查找，就会继续往后找存在的记录，也就是会找到 id = 16 这一行停下来，然后加 next-key lock (8, 16]，但由于 id = 16 不满足 id < 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。

所以，会话 1 这时候主键索引的锁是记录锁 id=8 和间隙锁(8, 16)。

会话 2 由于往间隙锁里插入了 id = 9 的记录，所以会被锁住了，而 id = 8 是被加锁的，因此会话 3 的语句也会被阻塞。

由于 id = 16 并没有加锁，所以会话 4 是可以正常被执行。

### 非唯一索引等值查询

当我们用非唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：

- **当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁**。
- **当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。**

接下里用两个案例来说明。

> 我们先来看看查询的值存在的情况。

比如下面这个例子：

![image-20221102203934646](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102203934646.png)

会话 1 加锁变化过程如下：

1. 先会对普通索引 b 加上 next-key lock，范围是(4,8];
2. **然后`因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止`**，因此间隙锁的范围是(8,16)。

所以，会话1的普通索引 b 上共有两个锁，分别是 next-key lock (4,8] 和间隙锁 (8,16) 。

那么，当会话 2 往间隙锁里插入 id = 9 的记录就会被锁住，而会话 3 和会话 4 是因为更改了 next-key lock 范围里的记录而被锁住的。

然后因为 b = 16 这条记录没有加锁，所以会话 5 是可以正常执行的。

> 接下来，我们看看查询的值不存在的情况

直接看案例：

![image-20221102204430815](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102204430815.png)

会话 1 加锁变化过程如下：

1. 先会对普通索引 b 加上 next-key lock，范围是(8,16];
2. 但是由于查询的记录是不存在的，所以不会再额外加个间隙锁，但是 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。

会话 2 因为往间隙锁里插入了 b = 9 的记录，所以会被锁住，而 b = 16 是没有被加锁的，因此会话 3 的语句可以正常执行。

### 非唯一索引范围查询

非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于**普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁**。

![image-20221102204721988](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102204721988.png)

会话 1 加锁变化过程如下：

1. 最开始要找的第一行是 b = 8，因此 next-key lock(4,8]，但是由于 b 不是唯一索引，并不会退化成记录锁。
2. 但是由于是范围查找，就会继续往后找存在的记录，也就是会找到 b = 16 这一行停下来，然后加 next-key lock (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。

所以，会话 1 的普通索引 b 有两个 next-key lock，分别是 (4,8] 和(8, 16]。这样，你就明白为什么会话 2 、会话 3 、会话 4 的语句都会被锁住了。

### 总结

唯一索引等值查询：

- 当查询的记录是存在的，next-key lock 会退化成「记录锁」。
- 当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。

非唯一索引等值查询：

- 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。
- 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。

非唯一索引和主键索引的范围查询的加锁规则不同之处在于：

- 唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。
- 非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。



## MySQL 死锁了，怎么办？

### 死锁的发生

本次案例使用存储引擎 Innodb，隔离级别为可重复读（RR）。

接下来，我用实战的方式来带大家看看死锁是怎么发生的。

我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：

```sql
CREATE TABLE `t_order` (
  `id` int NOT NULL AUTO_INCREMENT,
  `order_no` int DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_order` (`order_no`) USING BTREE
) ENGINE=InnoDB ;
```

然后，先 `t_order` 表里现在已经有了 6 条记录：

![image-20221102212510990](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102212510990.png)



假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：

![image-20221102212615719](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102212615719.png)

可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。

这里在查询记录是否存在的时候，使用了 `select ... for update` 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。

如果没有使用 `select ... for update` 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：![image-20221102213106425](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213106425.png)

### 为什么会产生死锁？

可重复读隔离级别下，是存在幻读的问题。

**Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁**，它是记录锁和间隙锁的组合。

- Record Lock，记录锁，锁的是记录本身；
- Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。

普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：

```sql
begin;
//对读取的记录加共享锁
select ... lock in share mode;
commit; //锁释放

begin;
//对读取的记录加排他锁
select ... for update;
commit; //锁释放
```

**行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。**

比如，下面事务 A 查询语句会锁住 `(2, +∞]` 范围的记录，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。

![image-20221102213230281](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213230281.png)

需要注意的是，**`如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。`**

所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞!!!!!

回到前面死锁的例子。

![image-20221102213639972](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213639972.png)

事务 A 在执行下面这条语句的时候：

```sql
select id from t_order where order_no = 1007 for update;
```

我们可以通过 `select * from performance_schema.data_locks\G;` 这条语句，查看事务执行 SQL 过程中加了什么锁。

![image-20221102213808356](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221102213808356.png)

从上图可以看到，共加了两个锁，分别是：

- 表锁：X 类型的意向锁；
- 行锁：X 类型的间隙锁；

这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：

- 如果 LOCK_MODE 为 `X`，说明是 X 型的 next-key 锁；
- 如果 LOCK_MODE 为 `X, REC_NOT_GAP`，说明是 X 型的记录锁；
- 如果 LOCK_MODE 为 `X, GAP`，说明是 X 型的间隙锁；

如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。

> supremum为数据页的内容

当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住：

```sql
Insert into t_order (order_no, create_date) values (1008, now());
```

因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，**而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以两个事务中 `select ... for update` 语句并不会相互影响**。

案例中的事务 A 和事务 B 在执行完后 `select ... for update` 语句后都持有范围为`(1006,+∞]`的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。





