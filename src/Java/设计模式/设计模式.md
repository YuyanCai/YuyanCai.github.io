---
title: 设计模式
---
## 一、设计模式总览

设计模式是在94年由4个人在一本书中提出来的概念

设计模式最重要的两点：

- **对接口编程而不是对实现编程**
- **优先使用对象组合而不是继承**

我们在编写一个功能的时候，提取出一个一个的功能，定义为接口，接口就是标准、规范。之后对接口进行实现，这就是面向接口编程。 面向接口编程真正的威力在于，当别的类需要引用这些功能的时候，我们直接引入接口，之后呢我们传任何接口的实现类即可完成指定功能（多态）

### 设计模式的基石

- 封装
- 继承
- 多态

- 顺序
- 判断
- 循环

### 设计模式总览

**创建型模式（Creational Patterns）**

1. 单例（Singleton）模式
2. 原型（Prototype）模式
3. 工厂方法（FactoryMethod）模式
4. 抽象工厂（AbstractFactory）模式
5. 建造者（Builder）模式



**结构型模式（Structural Patterns）**

1. 代理（Proxy）模式
2. 适配器（Adapter）模式
3. 桥接（Bridge）模式
4. 装饰（Decorator）模式
5. 外观（Facade）模式
6. 享元（Flyweight）模式
7. 组合（Composite）模式
8. 过滤器模式（Filter Pattern）



**行为型模式（Behavioral Patterns**

1. 模板方法（Template Method）模式
2. 策略（Strategy）模式
3. 命令（Command）模式
4. 职责链（Chain of Responsibility）模式
5. 状态（State）模式
6. 观察者（Observer）模式
7. 中介者（Mediator）模式
8. 迭代器（Iterator）模式
9. 访问者（Visitor）模式
10. 备忘录（Memento）模式
11. 解释器（Interpreter）模式



==设计模式是一种思想，灵活运用思想远大于死记代码、咬文爵字==



### 理解设计模式的三种分类

这里我们可以想象类的创建到销毁过程，每个过程对应不同分类的设计模式

- 当类创建的时候，结构型模式帮我们类设计的更好
- 当创建对象的时候，创建型模式帮我们创建的更好
- 当对象调用方法的时候，行为型模式让我们调用的更好

![image-20220712221126277](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220712221126277.png)

## 二、UML类图



### 类图中具体类、抽象、接口和包的表示法

#### 具体类

具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：

- “+”表示 `public`；
- “-”表示 `private`；
- “##”表示 `protected`；
- 不带符号表示 `default`。

![img](https://raw.githubusercontent.com/YuyanCai/imagebed/main/v2-71b22158f5b09dffa57a123d72ec4653_1440w.webp)

#### 抽象类

抽象类在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示

![image-20221016160316985](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016160316985.png)

#### 接口

![image-20221016160424189](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016160424189.png)

#### 包

![image-20221016161217413](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016161217413.png)

### 在类图中表示关系

![image-20221016161635794](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016161635794.png)

#### 继承

> 继承用一条带**空心箭头**的直接表示。
>

![image-20221016145252810](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016145252810.png)

#### 实现

> 实现关系用一条带**空心箭头**的虚线表示。
>

![image-20221016145336285](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016145336285.png)

#### 关联

关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用。也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。

关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。

在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象

![image-20221016161813679](../../../../../../Library/Application Support/typora-user-images/image-20221016161813679.png)

一个对象可以持有其它对象的数组或者集合。在UML中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。多重性允许的表达式示例如下：

- 数字：精确的数量
- `*`或者`0..*`：表示0到多个
- `0..1`：表示0或者1个，在Java中经常用一个空引用来实现
- `1..*`：表示1到多个

关联关系又分为**依赖关联、聚合关联和组合关联**三种类型。

##### 组合

与聚合关系一样，组合关系同样表示整体由部分构成的语义。比如公司由多个部门组成，但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。例如，公司不存在了，部门也将不存在了。

![image-20221016145414087](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016145414087.png)

##### 聚合

聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义，例如一个部门由多个员工组成。与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。例如，部门撤销了，人员不会消失，他们依然存在。

![image-20221016145515265](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016145515265.png)







##### 依赖

依赖（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。

在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用

![image-20221016162817847](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016162817847.png)

依赖关系在Java中的具体代码表现形式为**B为A的构造器**或**方法中的局部变量**、**方法或构造器的参数**、**方法的返回值**，或者**A调用B的静态方法**。



下面我们用代码清单1和代码清单2所示的Java代码来演示对象和对象之间的依赖关系。

代码清单1所示的`B`类定义了一个成员变量 `field1`，一个普通方法 `method1()` 和一个静态方法 `method2()`。

```java
//代码清单1 B.java
public class B {
  public String field1;   //成员变量

  public void method1() {
    System.println("在类B的方法1中");
  }

  public static void method2() {                 //静态方法
    System.out.println("在类B的静态方法2中");
  }
}
```



代码清单2所示的`A`类依赖于`B`类，在`A`类中定义了四个方法，分别演示四种依赖形式。

```java
/* 代码清单2 A.java
  A依赖于B
*/

public class A {
  public void method1() {
    //A依赖于B的第一种表现形式：B为A的局部变量
    B b = new B();
    b.method1();
  }

  public void method2() {
    //A依赖于B的第二种表现形式： 调用B的静态方法
    B.method2();
  }

  public void method3(B b)  {
    //A依赖于B的第三种表现形式：B作为A的方法参数
    String s = b.field1;
  }

  //A依赖于B的第四种表现形式：B作为A的方法的返回值
  public B method4() {
    return new B();
  }
}
```











































## 三、设计模式7大原则

### 开闭原则（OCP）

软件实体应当**对扩展开放，对修改关闭**(Software entities should be open for extension,but closed for modification)
合成复用原则、里氏替换原则相辅相成，都是开闭原则的具体实现规范

**新增功能的时候不是修改旧类，而是创建新类**



### 里氏替换原则（LSP）

继承必须确保超类所拥有的性质在子类中仍然成立

**继承父类而不去改变父类**，子类不改变父类定义好的方法，只对可扩展的方法进行修改



### 依赖倒置原则（DIP ）

高层模块不应该依赖低层模块，两者都应该依赖其抽象|抽象不应该依赖细节，细节应该依赖抽象

**面向接口编程，而不是面向是实现类**

当我们写controller的时候，里面永远自动装配的是Service的接口，Service里面自动装配的的永远是Dao的接口，这种定义的方式其实就满足DIP



### 单一职责（SRP)

一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分

**每个类只负责自己的事情，而不是变成万能**



### 接口隔离原则（ISP）

一个类对另一个类的依赖应该建立在最小的接口上

**各个类建立自己的专用接口，而不是建立万能接口**，当A类要用B类里的方法的时候不能引入一个万能接口（接口的方法A类也有B类也有）要对接口进行分割在引用



### 迪米特法则（LOD）

最少知识原则，只与你的直接朋友交谈，不跟“陌生人”说话

**无需直接交换的两如果需要交互，使用中间者**

**过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低个类**

低耦合，高内聚。



### 合成复用原则（CRP）

又叫组合/聚合复用原则

软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现

**优先组合，其次继承**



**什么是组合**？

A类想有B类里的方法，怎么办？

- 继承
- 在A类写一个B类当成属性，我们选这种方式



## 四、创建型模式

### 为什么使用创建型模式

 创建者模式关注的是**怎么把对象给创建出来**

**将对象的创建与使用分离**

降低系统的耦合度

使用者无需关注对象的创建细节

- 对象的创建由相关的工厂来完成；（各种工厂模式）
- 对象的创建由一个建造者来完成；（建造者模式）
- 对象的创建由原来对象克隆完成；（原型模式）
- 对象始终在系统中只有一个示例；（单例模式）



### 1.单例模式

1. 某个类只能有一个实例；（构造器私有）

2. 它必须自行创建这个实例；（自己编写实例化逻辑）

3. 它必须自行向整个系统提供这个实例；（对外提供实例化方法）




#### 单例模式实现方式

单例模式的实现方式有两种，饿汉式和懒汉式

懒汉式又称延迟加载，就是在提供对象的方法中会进行一个判断，需要创建对象的时候才进行创建，线程不安全。优点是能够节约资源

饿汉式又称预先加载，就是直接创建好对象，需要的时候直接返回对象，线程安全。优点是初始化速度快，占用内存小。

![img](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/v2-f79c2f1308eab7f882979cc65a5c7a5d_r.jpg)



#### 懒汉式-线程不安全

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}

```

#### 饿汉式-线程安全

线程不安全问题主要是由于 uniqueInstance 被多次实例化，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。

但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。

```java
private static Singleton uniqueInstance = new Singleton();
```

#### 双重校验锁-线程安全

uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。

双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程同时执行 if 语句，那么两个线程就会同时进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 `uniqueInstance = new Singleton();` 这条语句，只是先后的问题，那么就会进行两次实例化，从而产生了两个实例。因此必须使用双重校验锁，也就是需要使用两个 if 语句。

```java
if (uniqueInstance == null) {
    synchronized (Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
```

uniqueInstance 采用 volatile 关键字修饰也是很有必要的。`uniqueInstance = new Singleton();` 这段代码其实是分为三步执行。

1. 分配内存空间
2. 初始化对象
3. 将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1>3>2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以致于程序出错。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

#### 应用场景

- 多线程中的线程池
- 数据库的连接池
- 系统环境信息
- 上下文（ServletContext）



### 2.原型模式

**原型模式（Prototype** **Pattern）是用于创建重复的对象，同时又能保证性能**

**本体给外部提供一个克隆体进行使用**

#### 类图

![image-20221016164123933](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221016164123933.png)

#### 实例

> 原型对象

```java
public abstract class Prototype {
    abstract Prototype myClone();
}
```

> 克隆对象

本体提供一个克隆体对外进行使用，不改变本体

```java
public class ConcretePrototype extends Prototype{
    private String field;
   
    public ConcretePrototype(String field) {
        this.field = field;
    }

    @Override
    Prototype myClone() {
        return new ConcretePrototype(field);
    }

    @Override
    public String toString() {
        return field;
    }
}
```

> 测试

```java
public class Client {
    public static void main(String[] args) {
        Prototype pro = new ConcretePrototype("abc");
        Prototype clone = pro.myClone();
        System.out.println(clone.toString());
    }
}
```



### 3.简单工厂

#### 介绍

提供一个创建对象实例的功能，而无须关心具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体实现的类

> 一图胜千言

![image-20221019230933363](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221019230933363.png)

#### 实例1

这里我们拿设计计算器实例来说明

> 运算接口

```java
public interface Operations {
    //抽取运算
    double getResult(double numA,double numB);
}
```

> 实现类

```java
public class AddImpl implements Operations {
    @Override
    public double getResult(double numA, double numB) {
        double result = numA + numB;
        return result;
    }
}

public class SubImpl implements Operations {
    @Override
    public double getResult(double numA, double numB) {
        double result = numA - numB;
        return result;
    }
}

public class MulImpl implements Operations {
    @Override
    public double getResult(double numA, double numB) {
        double result = numA * numB;
        return result;
    }
}

public class DivImpl implements Operations {
    @Override
    public double getResult(double numA, double numB) {
        double result = numA / numB;
        return result;
    }
}
```

> 工厂

这里返回接口也是多态的体现

```java
public class OpeartionFactory {

    public static Operations createOperation(String operate){
        Operations operation = null;
        switch (operate){
            case "+":
                operation = new AddImpl();
                break;
            case "-":
                operation = new SubImpl();
                break;
            case "*":
                operation = new MulImpl();
                break;
            case "/":
                operation = new DivImpl();
                break;
        }
        return operation;
    }
}
```

> 客户端

```java
public class Client01 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("*******欢迎来到计算器*****");
        double numA;
        while (true) {
            try {
                System.out.println("请输入你的第一个数");
                numA = sc.nextDouble();
                break;
            } catch (Exception e) {
                sc = new Scanner(System.in);
                System.out.println("输入只能为数字！");
            }
        }

        System.out.println("请输入+,-,*,/符号");
        String operate = sc.next();
        Operations operation = OpeartionFactory.createOperation(operate);

        double numB;
        while (true) {
            try {
                System.out.println("请输入你的第二个数");
                numB = sc.nextDouble();
                while (numB == 0){
                    System.out.println("除数不能为0，请重新输入！");
                    numB = sc.nextDouble();
                }
                break;
            } catch (Exception e) {
                sc = new Scanner(System.in);
                System.out.println("输入只能为数字！");
            }
        }

        double result = operation.getResult(numA, numB);
        System.out.println("计算公式为:" + numA + operate + numB + "=" + result);
    }

}
```

#### 实例2

> 类图如下

![image-20221017224548230](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221017224548230.png)

UML图的解释：

- Car为抽象类
- VanCar和MiniCar为Car的子类
- WuliFactory创建负责创建这两个对象（通过黄色部分逻辑判断）

> 抽象汽车接口

为什么要抽象出一个汽车接口呢？我们直接生成汽车类不行吗？

这里其实也体现了设计模式7大原则中的依赖倒置原则，也就是面向接口编程。同时也能体现出开闭原则，对扩展开放，对修改关闭。如果需要新的汽车，那么就新建一个类去实现这个接口即可！（不改变源代码，而是对其扩展）

```java
public interface AbstractCar {
    void run();
}
```

> 汽车实现类

```java
public class BenchiCar implements AbstractCar{
    @Override
    public void run() {
        System.out.println("我是奔驰，我可以跑跳着跑！");
    }
}


public class WulingCar implements AbstractCar{
    @Override
    public void run() {
        System.out.println("我是五菱，我能飞！");
    }
}
```

> 简单工厂

这个工厂很简单，就是提供了一个方法。可以根据传来的参数创建相应的对象

``` java
public class CarFactory {
    public AbstractCar returnCar(String type) {
        if ("Benchi".equals(type)) {
            return new BenchiCar();
        } else if ("Wuling".equals(type)) {
            return new WulingCar();
        }
        //......有新的汽车进来，那就需要改变造车厂的逻辑，在添加if，else
        return null;
    }
}
```

> 会员端

我们在会员端来体会一下简单工厂的作用：

- new这个简单工厂

- 调用简单工厂中创建对象的方法

- 运行对应对于的方法

通过运行结果我们可以发现，我们只需要创建工厂然后调用里面的方法对象就被创建出来了。这不就是我们前面说的隐藏了对象的创建细节，并提供一个创建对象的通用接口，实现了解耦。

```java
public class Client {
    public static void main(String[] args) {
        CarFactory factory = new CarFactory();

        AbstractCar benci = factory.returnCar("Benchi");
        AbstractCar wuling = factory.returnCar("Wuling");

        benci.run();
        wuling.run();
    }
}

我是奔驰，我可以跑跳着跑！
我是五菱，我能飞！
```

#### 总结

> 1.使用的场景?

**如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体**，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体实现；

**如果想要把对外创建对象的职责集中管理和控制**，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制。



> 2.本质是什么?

**简单工厂的本质是：选择实现。**

**注意简单工厂的重点在选择，实现是已经做好了的。**就算实现再简单，也要由具体的实现类来实现，而不是在简单工厂里面来实现。**简单工厂的目的在于为客户端来选择相应的实现，从而使得客户端和实现之间解耦**，这样一来，具体实现发生了变化，就不用变动客户端了，这个变化会被简单工厂吸收和屏蔽掉。

**实现简单工厂的难点就在于“如何选择”实现**，前面讲到了几种传递参数的方法，那都是静态的参数，还可以实现成为动态的参数。比如：在运行期间，由工厂去读取某个内存的值，或者是去读取数据库中的值，然后根据这个值来选择具体的实现等等。



> 3.它解决了什么问题?

将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。

使用者可以直接消费产品而不需要知道生产的细节



> 4.它体现了设计模式中什么原则?

面向接口编程



> 5.存在的缺陷?

- 可能增加客户端的复杂度：如果通过客户端的参数来选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，这会增加客户端使用的难度，也部分暴露了内部实现，这种情况可以选用可配置的方式来实现。

- 不方便扩展子工厂：私有化简单工厂的构造方法，使用静态方法来创建接口，也就不能通过写简单工厂类的子类来改变创建接口的方法的行为了。不过，通常情况下是不需要为简单工厂创建子类的。

> 6.你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- 简单工厂和抽象工厂模式

简单工厂是用来选择实现的，可以选择任意接口的实现，一个简单工厂可以有多个用于选择并创建对象的方法，多个方法创建的对象可以有关系也可以没有关系。

抽象工厂模式是用来选择产品簇的实现的，也就是说一般抽象工厂里面有多个用于选择并创建对象的方法，但是这些方法所创建的对象之间通常是有关系的，这些被创建的对象通常是构成一个产品簇所需要的部件对象。

所以从某种意义上来说，简单工厂和抽象工厂是类似的，如果抽象工厂退化成为只有一个实现，不分层次，那么就相当于简单工厂了。



- 简单工厂和工厂方法模式

简单工厂和工厂方法模式也是非常类似的。工厂方法的本质也是用来选择实现的，跟简单工厂的区别在于工厂方法是把选择具体实现的功能延迟到子类去实现。如果把工厂方法中选择的实现放到父类直接实现，那就等同于简单工厂。



- 简单工厂和能创建对象实例的模式

简单工厂的本质是选择实现，所以它可以跟其它任何能够具体的创建对象实例的模式配合使用，比如：单例模式、原型模式、生成器模式等等。



> 7.开源架构中哪些使用了这一模式?





### 4.工厂方法(Factory Method)

#### 介绍

工厂方法模式,又称工厂模式、多态工厂模式，通过定义工厂父类负责定义创建对象的公共接口，而子类负责生成具体的对象。

工厂方法使一个类的实例化延迟到工厂类的子类(具体工厂)中完成,既由子类来决定应该实例化(创建)哪一个类。



> 一图胜千言

![image-20221019231035866](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221019231035866.png)

#### 实例

> 抽象汽车接口

```java
public interface AbstractCar {
    void run();
}
```

> 汽车实现类

```java
public class BenchiCar implements AbstractCar{
    @Override
    public void run() {
        System.out.println("我是奔驰，我可以跑跳着跑！");
    }
}


public class WulingCar implements AbstractCar{
    @Override
    public void run() {
        System.out.println("我是五菱，我能飞！");
    }
}
```

> 工厂接口

```java
public interface AbstractCarFactory {

    AbstractCar newCar();
}
```

> 工厂实现类

```java
public class BenciCarFactory implements AbstractCarFactory{
    @Override
    public AbstractCar newCar() {
        return new BenchiCar();
    }
}

public class WulinCarFactory implements AbstractCarFactory{
    @Override
    public AbstractCar newCar() {
        return new WulingCar();
    }
}
```

> 会员端

```java
public class Client {
    public static void main(String[] args) {
        AbstractCarFactory wulinCarFactory = new WulinCarFactory();
        AbstractCarFactory benciCarFactory = new BenciCarFactory();

        AbstractCar wuling = wulinCarFactory.newCar();
        wuling.run();

        AbstractCar benci = benciCarFactory.newCar();
        benci.run();

    }
}

我是五菱，我能飞！
我是奔驰，我可以跑跳着跑！
```

#### 总结

> 1.使用的场景?

- 当一个类不知道它所需要的对象的类时

在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；

- 当一个类希望通过其子类来指定创建对象时

在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，**利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。**

- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

> 2.本质是什么?

- **延迟到子类来选择实现。**
- 工厂方法和简单工厂很类似，简单工厂是在工厂类中`选择实现`。
- 而工厂方法会把这个工作延迟到子类来实现，它是先抽象出一个工厂，然后在实现类（子类）中`选择实现`

> 3.它解决了什么问题?

- 解决了简单工厂模式的缺点，即工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，这样就违背了开闭原则


> 4.它体现了设计模式中什么原则?

- 依赖倒置，要`依赖于抽象，而不是依赖于具体的实现`。
- 开闭原则，对修改关闭，对扩展开放。有新的产品了，不需要对工厂类（具体实现）修改。而是直接重写实现工厂接口，写新的逻辑即可。

> 5.存在的缺陷?

- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
- 一个具体工厂只能创建一种具体产品

> 6.你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- **工厂方法模式和模板方法模式**
- 这两个模式外观类似，都是有一个抽象类，然后由子类来提供一些实现，**但是工厂方法模式的子类专注的是创建产品对象，而模板方法模式的子类专注的是为固定的算法骨架提供某些步骤的实现**。这两个模式可以组合使用，通常在模板方法模式里面，使用工厂方法来创建模板方法需要的对象。

> 7.开源架构中哪些使用了这一模式?



### 5.抽象工厂(Abstract Factory)

#### 介绍

提供一个创建`一系列`相关或相互依赖对象的接口，无需指定它们具体的类；具体工厂负责实现具体产品。

> 一图胜千言

![image-20221019231145843](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221019231145843.png)

#### 实例

> 抽象工厂

```java
public interface AbstractFactory {
  //又能造汽车
    AbstractCar createProductCar();
  //还可以造口罩(Mask)
    AbstractMask createProductMask();
}
```

> 抽象出汽车接口

```java
public interface AbstractCar {
    void run();
}
```

> 抽象出口罩接口

```java
public interface AbstractMask {
    void defense();
}
```

> 分别做抽象产品的实现(汽车和口罩的实现)

```java
//口罩的具体产品
public class N95 implements AbstractMask{
    @Override
    public void defense() {
        System.out.println("我N95防护非常快！");
    }
}

public class N100 implements AbstractMask{
    @Override
    public void defense() {
        System.out.println("我N100防护快的不得了！");
    }
}

//汽车的具体产品
public class BenchiCar implements AbstractCar{
    @Override
    public void run() {
        System.out.println("我是奔驰，我可以跑跳着跑！");
    }
}


public class WulingCar implements AbstractCar{
    @Override
    public void run() {
        System.out.println("我是五菱，我能飞！");
    }
}
```

> 对象工厂

因为工厂实现的是抽象工厂接口,抽象工厂又有多个产品接口,这样具体的工厂是不是就可以创建多个产品了呢?

```java
public class CarFactory implements AbstractFactory{
    @Override
    public AbstractCar createProductCar() {
        return new BenchiCar();
    }

    @Override
    public AbstractMask createProductMask() {
        return new N95();
    }
}

public class MaskFactory implements AbstractFactory{
    @Override
    public AbstractCar createProductCar() {
        return new WulingCar();
    }

    @Override
    public AbstractMask createProductMask() {
        return new N100();
    }
}
```

> 客户端

客户端通过创建工厂就可以完成多种类产品的创建,这就是对象工厂带给我们的好处了

```java
public class Client {
    public static void main(String[] args) {
        CarFactory carFactory = new CarFactory();
        carFactory.createProductCar();
        carFactory.createProductMask();
    }
}
```

#### 总结

> 1.使用场景

- 需要多个系列产品


- 系统需要提供一个产品库，所有产品都以同样的接口出现，客户端不需要依赖具体的实现


- 如果要动态的切换产品簇



> 2.本质是什么?

- 选择产品簇的实现。


- 工厂方法是选择单个产品的实现,抽象工厂是为一个产品簇选择实现的,如果抽象工厂里只定义一个方法，那就是抽象方法模式了


> 3.它解决了什么问题?

将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。

使用者可以直接消费产品而不需要知道生产的细节

> 4.它体现了设计模式中什么原则?

- 更符合开闭原则


- 单一职责



> 5.存在的缺陷?

如果有新产品添加，那么就需要去修改抽象工厂的接口，这样就会抽象工厂类和下面的子类都会受到牵连

> 6.你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

抽象工厂和抽象方法最大的区别是,抽象工厂每个厂都可以创建多种类的产品;工厂方法没个厂只能建立一种产品

> 7.开源架构中哪些使用了这一模式?

未完待续......



### 6.建造者

#### 介绍

创建的东西复杂，还必须暴露给使用者。屏蔽过程而不屏蔽细节.

> 主要作用

在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。

例子:你要买汽车,说出你想要的型号(对象的类型和内容),你就可以直接使用了,不需要知道汽车是怎么组装的

> 一图胜千言

![image-20221020213259003](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221020213259003.png)

#### 实例

> 建造者

```java
public abstract class Builder {

    //第一步：装CPU
    public abstract void builderCPU();

    //第二步: 装主板
    public  abstract void buildMainBoard();

    public abstract void buildHD();

    public abstract Computer getComputer();

}
```

> 具体建造者

```java
public class ConcreteBuilder extends Builder {

    Computer computer = new Computer();

    @Override
    public void builderCPU() {
      compute.....
    }

    @Override
    public void buildMainBoard() {
			compute.....
    }

    @Override
    public void buildHD() {
			compute.....
    }

    @Override
    public Computer getComputer() {
        return computer;
    }

}
```

> 指挥者

```java
public class Director {
    private Builder builder;

    public Director() {
        this.builder = builder;
    }

    //指挥装电脑人员装机
    public void Construct(Builder builder){
        builder.buildHD();
        builder.builderCPU();
        builder.buildMainBoard();
    }

}
```

> 具体的产品

```java
public class Computer {
    void print(){
        System.out.println("我是电脑我能打字");
    }
}
```

> 客户端

```java
public class Client {
    public static void main(String[] args) {
        Director director = new Director();

        Builder concreteBuilder = new ConcreteBuilder();

        director.Construct(concreteBuilder);
        Computer computer = concreteBuilder.getComputer();
        computer.print();

    }
}
```

#### 总结

> 1.使用的场景?

同一个构建过程有着不同的表示时

> 2.本质是什么?

**分离整体构建和部件构造**

构建一个复杂的对象，有`构建过程（完成对象的创建）`和`构建过程中的具体实现（赋值）`。建造者模式可以分离这两个部分。从而使得程序更松散，扩展更容易。

虽然在生成器模式的整体构建算法中，会一步一步引导Builder来构建对象，但这**==并不是说生成器就主要是用来实现分步骤构建对象的==**。`生成器模式的重心还是在于分离整体构建算法和部件构造`，**而分步骤构建对象不过是整体构建算法的一个简单表现，或者说是一个附带产物**。

> 3.它解决了什么问题?

将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。

使用者可以直接消费产品而不需要知道生产的细节

> 4.它体现了设计模式中什么原则?

- 面向接口编程（依赖倒置）

> 5.存在的缺陷?

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 

> 6.你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

1. **生成器模式和工厂方法模式**

这两个模式可以组合使用。

生成器模式的Builder实现中，通常需要选择具体的部件实现，**一个可行的方案就是实现成为工厂方法，通过工厂方法来获取具体的部件对象，然后再进行部件的装配。**

> 7.开源架构中哪些使用了这一模式?

 后续更新...

## 五、结构型模式

`结构性模式`重点关注的是怎样组合`对象/类`

`类结构型模式`关心类的组合，由多个类可以组合成一个更大的（继承）

`对象结构型模式`关心类与对象的组合，通过关联关系**在一个类中定义另一个类的实例对象**

重点掌握蓝色部分

![image-20221021200516006](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021200516006.png)

### 7.适配器

#### 介绍

适配器的作用就像是转接头一样，我的MBP只有typec的口，但是我的外设想连接MBP的话需要USB口。那怎么办呢？

买扩展坞（适配器），它可以打通我的MBP和外设接口不同的限制，让他们能一起合作。

> 一图胜前言

![image-20221021193018233](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021193018233.png)

#### 实例

> 创建**Target接口**
>

```
public interface Target {
 
    //这是源类Adapteee没有的方法
    public void Request(); 
}

```

>  创建**源类（Adaptee）**

```
public class Adaptee {
    
    public void SpecificRequest(){
    }
}
```

> 创建**适配器类（Adapter）**

- 目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()
- 因此适配器补充上这个方法名
- 但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容
- 所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已

```
//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。
public class Adapter extends Adaptee implements Target {

    @Override
    public void Request() {
        this.SpecificRequest();
    }

}
```

> 目标类

```
public class AdapterPattern {

    public static void main(String[] args){

        Target mAdapter = new Adapter()；
        mAdapter.Request（）;
     
    }
}
```

#### 总结

> 1.使用的场景?

- **如果你想要使用一个已经存在的类，但是它的接口不符合你的需求**
- **如果你想创建一个可以复用的类，这个类可能和一些不兼容的类一起工作**
- **如果你想使用一些已经存在的子类，但是不可能对每一个子类都进行适配**

> 2.本质是什么?

**适配器模式的本质：转换匹配，复用功能**

适配器通过转换调用已有的实现，从而能把已有的实现匹配成需要的接口，使之能满足客户端的需要。**也就是说转换匹配是手段，而复用已有的功能才是目的。**	

> 3.它解决了什么问题?

- 如果功能是已经有了的，只是接口不兼容，那么通过适配器模式就可以让这些功能得到更好的复用 

> 4.它体现了设计模式中什么原则?

合成复用（多组合，少继承）

> 5.存在的缺陷?

**过多的使用适配器，会让系统非常零乱，不容易整体进行把握**，明明看到调用的是A接口，其实内部被适配成了B接口来实现，一个系统如果太多这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

> 6.你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- **适配器模式与桥接模式**

**适配器模式是把两个或者多个接口的功能进行转换匹配；而桥接模式是让接口和实现部分相分离，以便它们可以相对独立的变化。**

- **适配器模式与装饰模式**

**适配器模式能模拟实现简单的装饰模式的功能，也就是为已有功能增添功能**。

```csharp
public void adapterMethod(){
      System.out.println("在调用Adaptee的方法之前完成一定的工作");
      //调用Adaptee的相关方法
      adaptee.method();
      System.out.println("在调用Adaptee的方法之后完成一定的工作");
}
```

如上的写法，就相当于在调用Adaptee的被适配方法前后添加了新的功能，这样适配过后，客户端得到的功能就不单纯是Adaptee的被适配方法的功能了。看看是不是类似装饰模式的功能呢？

- **适配器模式和代理模式**

适配器模式可以跟代理模式组合使用，**在实现适配器的时候，可以通过代理来调用Adaptee**，这可以获得更大的灵活性。

- **适配器模式和抽象工厂模式**

在适配器实现的时候，**通常需要得到被适配的对象，如果被适配的是一个接口，那么就可以结合一些可以创造对象实例的设计模式，来得到被适配的对象示例**。比如：抽象工厂模式、单例模式、工厂方法模式等等。

> 7.开源架构中哪些使用了这一模式?

### 8.装饰器

> 饮料接口

```java
public interface Beverage {
    double cost();
}
```

> 具体饮料1

```java
public class DarkRoast implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}    
```

> 具体饮料2

```java
public class HouseBlend implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}   
```

> 装饰器抽象类

不修改具体饮料的情况下，对具体饮料的功能进行增强

```java
public abstract class CondimentDecorator implements Beverage {
    protected Beverage beverage;
}   
```

> 实现装饰器

添加新功能

```java
public class Milk extends CondimentDecorator {

    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}   
```

```java
public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}  
```

> 客户端进行测试

```java
public class Client {
    public static void main(String[] args) {
        Beverage beverage = new HouseBlend();
        beverage = new Mocha(beverage);
        beverage = new Milk(beverage);
        System.out.println(beverage.cost());
    }
}
 
3.0   
```

#### 设计原则

类应该对扩展开放，对修改关闭: 也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。

不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。

### 9.代理模式

#### 介绍

为另一个对象提供一个替身或占位符以控制对这个对象的访问。

![image-20221021221726566](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021221726566.png)

#### 实例

以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。

> 图片接口

```java
public interface Image {
    void showImage();
}

```

> 图片的实现

```java
public class HighResolutionImage implements Image {

    private URL imageURL;
    private long startTime;
    private int height;
    private int width;

    public int getHeight() {
        return height;
    }

    public int getWidth() {
        return width;
    }

    public HighResolutionImage(URL imageURL) {
        this.imageURL = imageURL;
        this.startTime = System.currentTimeMillis();
        this.width = 600;
        this.height = 600;
    }

    public boolean isLoad() {
        // 模拟图片加载，延迟 3s 加载完成
        long endTime = System.currentTimeMillis();
        return endTime - startTime > 3000;
    }

    @Override
    public void showImage() {
        System.out.println("Real Image: " + imageURL);
    }
}

    
```

> 代理

```java
public class ImageProxy implements Image {
    private HighResolutionImage highResolutionImage;

    public ImageProxy(HighResolutionImage highResolutionImage) {
        this.highResolutionImage = highResolutionImage;
    }

    @Override
    public void showImage() {
        while (!highResolutionImage.isLoad()) {
            try {
                System.out.println("Temp Image: " + highResolutionImage.getWidth() + " " + highResolutionImage.getHeight());
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        highResolutionImage.showImage();
    }
}
```

> 客户端

```java
public class ImageViewer {
    public static void main(String[] args) throws Exception {
        String image = "http://image.jpg";
        URL url = new URL(image);
        HighResolutionImage highResolutionImage = new HighResolutionImage(url);
        ImageProxy imageProxy = new ImageProxy(highResolutionImage);
        imageProxy.showImage();
    }
}
```



### 10.外观模式

#### 介绍

它提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

**外观（Facade）模式又叫作门面模式**，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式

比如我们有一个controller要调用一个业务，但是这个业务很复杂，有用到了很多其他的接口

第一种方式是，controller一个个的调用

第二种方式是，写一个大的接口，完成这些业务的调用，controller只需要调用这一个大的接口即可！

![image-20220919120027903](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220919120027903.png)

如上，如果我们要去办理业务，要去到公安局、教育局、社保局等地方。

外观（门面）模式呢就是提供一个门面，这个门面里可以办理各种业务，你只需要来这一个地方就可以了



#### 实例

观看电影需要操作很多电器，使用外观模式实现一键看电影功能。

> 电视系统

```java
public class SubSystem {
    public void turnOnTV() {
        System.out.println("turnOnTV()");
    }

    public void setCD(String cd) {
        System.out.println("setCD( " + cd + " )");
    }

    public void starWatching(){
        System.out.println("starWatching()");
    }
}
```

> 外观

```java
public class Facade {
    private SubSystem subSystem = new SubSystem();

    public void watchMovie() {
        subSystem.turnOnTV();
        subSystem.setCD("a movie");
        subSystem.starWatching();
    }
}
```

> 客户端

```java
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.watchMovie();
    }
}
```

#### 总结

客户对象所需要交互的对象应当尽可能少。



#### 使用场景

- Java的三层开发模式

- 分布式系统的网关



### 11.组合模式

#### 介绍

就是把一组相似的对象当成一个单一的对象，少继承，多引用

这个模式我们天天在用，写后台管理系统的时候经常要写树型的结构，定义实体类的时候直接**自己嵌套自己，这就叫组合模式**

#### 实例

> 菜单类

```java
@Data
public class Menu {

    private Integer id;
    private String name;
    public Menu(Integer id,String name){
        this.id = id;
        this.name = name;
    }

    //组合模式关注点
    private List<Menu> childs = new ArrayList<>();

    //提供添加层级的方法
    void addChildMenu(Menu menu){
        childs.add(menu);
    }

    //层级遍历方法
    void printMenu(){
        System.out.println(name);
        if(childs.size() > 0){
            for (Menu child : childs) {
                child.printMenu();
            }
        }
    }

}
```

> 测试类

```java
package com.atguigu.design.structural.composite;

public class MainTest {

    public static void main(String[] args) {
        Menu root = new Menu(1, "系统管理");
        Menu 角色管理 = new Menu(2, "角色管理");
        root.addChildMenu(角色管理);
        角色管理.addChildMenu(new Menu(6,"固定角色"));
        角色管理.addChildMenu(new Menu(7,"临时授予"));


        Menu 用户管理 = new Menu(3, "用户管理");
        root.addChildMenu(用户管理);


        用户管理.addChildMenu(new Menu(4,"临时用户"));
        用户管理.addChildMenu(new Menu(5,"注册用户"));


        //按照不同层级展示
        root.printMenu();
    }
}
```



#### 使用场景

- 分类结构

- 三级分类
- 组合了别的对象还是组合模式吗？

看你怎么理解了，学设计模式一定不要钻牛角尖，组合模式就是类里面在因引用别的类，这就是组合模式

相似的概念是很广的！

### 12.享元模式

#### 介绍

利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。它让某个类的一个实例能用来提供许多"虚拟实例"。

1、享元返回的是这个本人

2、原型返回的是克隆体

#### 实例

> 享元接口

```java
public interface Flyweight {
    void doOperation(String extrinsicState);
}   
```

> 具体享元类

```java
public class ConcreteFlyweight implements Flyweight {

    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void doOperation(String extrinsicState) {
        System.out.println("Object address: " + System.identityHashCode(this));
        System.out.println("IntrinsicState: " + intrinsicState);
        System.out.println("ExtrinsicState: " + extrinsicState);
    }
}

```

> 享元工厂

```java
public class FlyweightFactory {

    private HashMap<String, Flyweight> flyweights = new HashMap<>();

    Flyweight getFlyweight(String intrinsicState) {
        if (!flyweights.containsKey(intrinsicState)) {
            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
            flyweights.put(intrinsicState, flyweight);
        }
        return flyweights.get(intrinsicState);
    }
}
```

> 客户端

```java
public class Client {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight flyweight1 = factory.getFlyweight("aa");
        Flyweight flyweight2 = factory.getFlyweight("aa");
        flyweight1.doOperation("x");
        flyweight2.doOperation("y");
    }
}
   
```

> 结果如下

```html
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
```

### 13.桥接

#### 介绍

将抽象与实现分离开来，使它们可以独立变化。

> 类图如下

![image-20221021205709789](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021205709789.png)

#### 实例

> 使用多重继承

![image-20221021205802001](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021205802001.png)

```java
public abstract class Phone {
    public abstract void playMusic();
}


public class VivoPhone extends Phone {
    public void playMusic() {
        System.out.println("音乐high起来");
    }
}

public class OppoPhone extends Phone {
    public void playMusic() {
        System.out.println("音乐high起来");
    }
}

public class XiaomiPhone extends Phone {
    public void playMusic() {
        System.out.println("音乐high起来");
    }
}

public class SimpleVivoPhone extends VivoPhone {
    public void playMusic() {
        System.out.println("戴上简单手机壳");
        System.out.println("音乐high起来");
    }
}

public class CuteVivoPhone extends VivoPhone {
    public void playMusic() {
        System.out.println("戴上可爱手机壳");
        System.out.println("音乐high起来");
    }
}

public class SimpleOppoPhone extends OppoPhone {
    public void playMusic() {
        System.out.println("戴上简单手机壳");
        System.out.println("音乐high起来");
    }
}

public class CuteOppoPhone extends OppoPhone{
    public void playMusic() {
        System.out.println("戴上可爱手机壳");
        System.out.println("音乐high起来");
    }
}

public class SimpleXiaomiPhone extends XiaomiPhone {
    public void playMusic() {
        System.out.println("戴上简单手机壳");
        System.out.println("音乐high起来");
    }
}

public class CuteXiaomiPhone extends XiaomiPhone {
    public void playMusic() {
        System.out.println("戴上简单手机壳");
        System.out.println("音乐high起来");
    }
}
```

> 使用桥接模式

![image-20221021205814095](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021205814095.png)

抽象部分：

```csharp
public abstract class Phone {
    protected ShellImplementor shellImplementor;

    public void  setShellImplementor(ShellImplementor shellImplementor){
        this.shellImplementor = shellImplementor;
    }

    public void call(){
        System.out.println("打电话");
    }

    public abstract void playMusic();
}
```

扩展抽象部分：

```java
public class VivoPhone extends Phone {
    public void playMusic() {
        shellImplementor.wearShell();
        System.out.println("音乐High起来");
    }
}

public class OppoPhone extends Phone {
    public void playMusic() {
        shellImplementor.wearShell();
        System.out.println("音乐high起来");
    }
}

public class XiaomiPhone extends Phone {
    public void playMusic() {
        shellImplementor.wearShell();
        System.out.println("音乐high起来");
    }
}
```

将手机壳部分定义为实现部分：

```csharp
public interface ShellImplementor {
    void wearShell();
}
```

具体实现：

```java
public class SimpleShell implements ShellImplementor {
    public void wearShell() {
        System.out.println("戴上简单手机壳");
    }
}

public class CuteShell implements ShellImplementor {
    public void wearShell() {
        System.out.println("戴上可爱手机壳");
    }
}
```

客户端测试：

```cpp
public class Client {
    public static void main(String[] args) {
        Phone phone = new VivoPhone();
        ShellImplementor shell = new SimpleShell();
        phone.setShellImplementor(shell);
        phone.playMusic();
    }
}
```

新增手机型号只需继承自Phone就可以，新增手机壳也只需实现ShellImplementor，而且更换简单，可以用XML配置文件实现，只需修改配置，不需修改源码。

而且如果还要多一个实现，即三重维度，比如手机膜，多重继承会直接炸掉，而桥接模式则相对简洁很多。

#### 总结

分离抽象接口及其实现部分。

> 1.使用的场景?

一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。

> 2.本质是什么?

**桥接模式的本质：分离抽象和实现。**

**桥接模式最重要的工作就是分离抽象部分和实现部分，这是解决问题的关键。**只有把抽象和实现分离开了，才能够让它们可以独立的变化；只有抽象和实现可以独立的变化，系统才会有更好的可扩展性、可维护性。

> 3.它体现了设计模式中什么原则?

开闭原则，合成复用

> 5.存在的缺陷?

- 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。



## 六、行为模式

重点掌握蓝色部分

![image-20221021224457238](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021224457238.png)

### 模板方法

#### 介绍

定义算法框架，并将一些步骤的实现延迟到子类。

通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

![image-20221021225642995](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021225642995.png)

#### 实例

> 饮料的抽象

```java
public abstract class CaffeineBeverage {

    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    abstract void brew();

    abstract void addCondiments();

    void boilWater() {
        System.out.println("boilWater");
    }

    void pourInCup() {
        System.out.println("pourInCup");
    }
}

```

> 饮料的具体实现

```java
public class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Coffee.brew");
    }

    @Override
    void addCondiments() {
        System.out.println("Coffee.addCondiments");
    }
}

```

> 客户端

```java
public class Client {
    public static void main(String[] args) {
        CaffeineBeverage caffeineBeverage = new Coffee();
        caffeineBeverage.prepareRecipe();
        System.out.println("-----------");
        caffeineBeverage = new Tea();
        caffeineBeverage.prepareRecipe();
    }
}
```

#### 总结

上面的实例很清晰，就是定义完抽象类，留一部分方法不去实现它，这样子类继承的时候就可以不改变父类，而且自己可以重新定义这些功能

### 策略模式

#### 介绍

定义一系列算法，封装每个算法，并使它们可以互换。

策略模式可以让算法独立于使用它的客户端

![image-20221021230330299](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021230330299.png)

#### 实例

设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。

> 算法族

**定义小鸭子行为接口**

```java
public interface QuackBehavior {
    void quack();
}
```

**具体实现**

```java
public class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println("quack!");
    }
}

```

**具体实现2**

```java
public class Squeak implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println("squeak!");
    }
}
```

> 鸭子对象

```java
public class Duck {
    private QuackBehavior quackBehavior;

    public void performQuack() {
        if (quackBehavior != null) {
            quackBehavior.quack();
        }
    }

    public void setQuackBehavior(QuackBehavior quackBehavior) {
        this.quackBehavior = quackBehavior;
    }
}

```

> 客户端

动态改变鸭子的叫声

```java
public class Client {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.setQuackBehavior(new Squeak());
        duck.performQuack();
        duck.setQuackBehavior(new Quack());
        duck.performQuack();
    }
}

squeak!
quack!
```

#### 总结

> 本质是什么?

**策略模式的本质：分离算法，选择实现。**

> 它解决了什么问题?

**定义一系列算法**

策略模式的功能就是定义一系列算法，实现让这些算法可以相互替换。

**避免多重条件语句**

根据前面的示例会发现，策略模式的一系列策略算法是平等的，可以互换的，写在一起就是通过if-else结构来组织，如果此时具体的算法实现里面又有条件语句，就构成了多重条件语句，使用策略模式能避免这样的多重条件语句。

**更好的扩展性**

在策略模式中扩展新的策略实现非常容易，只要增加新的策略实现类，然后在选择使用策略的地方选择使用这个新的策略实现就好了。

> 它体现了设计模式中什么原则?

开闭原则

> 存在的缺陷?

**客户必须了解每种策略的不同**

策略模式也有缺点，比如让客户端来选择具体使用哪一个策略，这就可能会让客户需要了解所有的策略，还要了解各种策略的功能和不同，这样才能做出正确的选择，而且这样也暴露了策略的具体实现。

**增加了对象数目**

由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

**只适合扁平的算法结构**

策略模式的一系列算法地位是平等的，是可以相互替换的，事实上构成了一个扁平的算法结构，也就是在一个策略接口下，有多个平等的策略算法，就相当于兄弟算法。而且在运行时刻只有一个算法被使用，这就限制了算法使用的层级，使用的时候不能嵌套使用。

> 你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- **策略模式和状态模式**

这两个模式从模式结构上看是一样的，但是实现的功能是不一样的。

**状态模式是根据状态的变化来选择相应的行为**，不同的状态对应不同的类，每个状态对应的类实现了该状态对应的功能，在实现功能的同时，还会维护状态数据的变化。这些实现状态对应的功能的类之间是不能相互替换的。

**策略模式是根据需要或者是客户端的要求来选择相应的实现类，各个实现类是平等的，是可以相互替换的。**

另外策略模式可以让客户端来选择需要使用的策略算法，而状态模式一般是由上下文，或者是在状态实现类里面来维护具体的状态数据，通常不由客户端来指定状态。

- **策略模式和模板方法模式**

**模板方法重在封装算法骨架，而策略模式重在分离并封装算法实现。**

- **策略模式和享元模式**

策略模式分离并封装出一系列的策略算法对象，这些对象的功能通常都比较单一，很多时候就是为了实现某个算法的功能而存在，因此，针对这一系列的、多个细粒度的对象，可以应用享元模式来节省资源

> 开源架构中哪些使用了这一模式?



### 状态模式

#### 介绍

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类

> 类图

![image-20221021233803530](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021233803530.png)

#### 实例

> 状态

```java
public interface State {
    /**
     * 投入 25 分钱
     */
    void insertQuarter();

    /**
     * 退回 25 分钱
     */
    void ejectQuarter();

    /**
     * 转动曲柄
     */
    void turnCrank();

    /**
     * 发放糖果
     */
    void dispense();
}

```

> 状态的具体实现1

状态的实现类和糖果机器对象进行了组合，生成具体对象的同时，糖果机对象也会被初始化

```java
public class HasQuarterState implements State {

    private GumballMachine gumballMachine;

    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println("You can't insert another quarter");
    }

    @Override
    public void ejectQuarter() {
        System.out.println("Quarter returned");
        gumballMachine.setState(gumballMachine.getNoQuarterState());
    }

    @Override
    public void turnCrank() {
        System.out.println("You turned...");
        gumballMachine.setState(gumballMachine.getSoldState());
    }

    @Override
    public void dispense() {
        System.out.println("No gumball dispensed");
    }
}

```

> 状态的具体实现2

和上面的一样，还是和糖果机组合使用

```java
public class NoQuarterState implements State {

    GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println("You insert a quarter");
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }

    @Override
    public void ejectQuarter() {
        System.out.println("You haven't insert a quarter");
    }

    @Override
    public void turnCrank() {
        System.out.println("You turned, but there's no quarter");
    }

    @Override
    public void dispense() {
        System.out.println("You need to pay first");
    }
}

```

> 糖果机

```java
public class GumballMachine {

    private State soldOutState;
    private State noQuarterState;
    private State hasQuarterState;
    private State soldState;

    private State state;
    private int count = 0;

    public GumballMachine(int numberGumballs) {
        count = numberGumballs;
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);

        if (numberGumballs > 0) {
            state = noQuarterState;
        } else {
            state = soldOutState;
        }
    }

    public void insertQuarter() {
        state.insertQuarter();
    }

    public void ejectQuarter() {
        state.ejectQuarter();
    }

    public void turnCrank() {
        state.turnCrank();
        state.dispense();
    }

    public void setState(State state) {
        this.state = state;
    }

    public void releaseBall() {
        System.out.println("A gumball comes rolling out the slot...");
        if (count != 0) {
            count -= 1;
        }
    }

    public State getSoldOutState() {
        return soldOutState;
    }

    public State getNoQuarterState() {
        return noQuarterState;
    }

    public State getHasQuarterState() {
        return hasQuarterState;
    }

    public State getSoldState() {
        return soldState;
    }

    public int getCount() {
        return count;
    }
}

```

> 客户端测试

```java
public class Client {

    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);

        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();

        gumballMachine.insertQuarter();
        gumballMachine.ejectQuarter();
        gumballMachine.turnCrank();

        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.ejectQuarter();

        gumballMachine.insertQuarter();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
    }
}


You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there's no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven't insert a quarter
You insert a quarter
You can't insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can't insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
```

#### 总结

> 本质是什么?

**`状态模式的本质：根据状态来分离和选择行为。`**

> 它解决了什么问题?

- **简化应用逻辑控制**

`状态模式使用单独的类来封装一个状态的处理`。如果把一个大的程序控制分成很多小块，每块定义一个状态来代表，那么就可以把这些逻辑控制的代码分散到很多单独的状态类当中去，这样就把着眼点从执行状态提高到整个对象的状态，使得代码结构化和意图更清晰，从而简化应用的逻辑控制。

- **更好的分离状态和行为**

`状态模式通过设置所有状态类的公共接口，把状态和状态对应的行为分离开来，把所有与一个特定的状态相关的行为都放入一个对象中`，使得应用程序在控制的时候，只需要关心状态的切换，而不用关心这个状态对应的真正处理。

> 你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- 策略模式和状态模式

这两个模式从模式结构上看是一样的，但是实现的功能是不一样的。

**状态模式是根据状态的变化来选择相应的行为**，不同的状态对应不同的类，每个状态对应的类实现了该状态对应的功能，在实现功能的同时，还会维护状态数据的变化。这些实现状态对应的功能的类之间是不能相互替换的。

**策略模式是根据需要或者是客户端的要求来选择相应的实现类，各个实现类是平等的，是可以相互替换的。**

另外策略模式可以让客户端来选择需要使用的策略算法，而状态模式一般是由上下文，或者是在状态实现类里面来维护具体的状态数据，通常不由客户端来指定状态。



### 中介者模式

#### 介绍

使用中介者模式来集中相关对象之间复杂的沟通和控制方式。

> 类图

![image-20221021235812379](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221021235812379.png)

> 白话文理解中介者模式

![image-20221022000032365](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022000032365.png)

有了主板之后

![image-20221022000111183](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022000111183.png)

这里的主板的作用就像是在类里中介者的作用

#### 实例

> 同事接口

```java
public abstract class Colleague {
    public abstract void onEvent(Mediator mediator);
}
```

> 具体同事

```java
public class Alarm extends Colleague {

    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("alarm");
    }

    public void doAlarm() {
        System.out.println("doAlarm()");
    }
}


public class CoffeePot extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("coffeePot");
    }

    public void doCoffeePot() {
        System.out.println("doCoffeePot()");
    }
}


public class Calender extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("calender");
    }

    public void doCalender() {
        System.out.println("doCalender()");
    }
}

public class Sprinkler extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("sprinkler");
    }

    public void doSprinkler() {
        System.out.println("doSprinkler()");
    }
}
```

> 中介者

```java
public abstract class Mediator {
    public abstract void doEvent(String eventType);
}
```

> 具体中介者

```java
public class ConcreteMediator extends Mediator {
    private Alarm alarm;
    private CoffeePot coffeePot;
    private Calender calender;
    private Sprinkler sprinkler;

    public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
        this.alarm = alarm;
        this.coffeePot = coffeePot;
        this.calender = calender;
        this.sprinkler = sprinkler;
    }

    @Override
    public void doEvent(String eventType) {
        switch (eventType) {
            case "alarm":
                doAlarmEvent();
                break;
            case "coffeePot":
                doCoffeePotEvent();
                break;
            case "calender":
                doCalenderEvent();
                break;
            default:
                doSprinklerEvent();
        }
    }

    public void doAlarmEvent() {
        alarm.doAlarm();
        coffeePot.doCoffeePot();
        calender.doCalender();
        sprinkler.doSprinkler();
    }

    public void doCoffeePotEvent() {
        // ...
    }

    public void doCalenderEvent() {
        // ...
    }

    public void doSprinklerEvent() {
        // ...
    }
}
```

> 客户端测试

```java
public class Client {
    public static void main(String[] args) {
        Alarm alarm = new Alarm();
        CoffeePot coffeePot = new CoffeePot();
        Calender calender = new Calender();
        Sprinkler sprinkler = new Sprinkler();
        Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
        // 闹钟事件到达，调用中介者就可以操作相关对象
        alarm.onEvent(mediator);
    }
}


doAlarm()
doCoffeePot()
doCalender()
doSprinkler()
```



#### 总结

> 本质是什么?

**`中介者模式的本质：封装交互。`**

中介者模式的目的，就是用来封装多个对象的交互，这些交互的处理多在中介者对象里面实现，因此中介对象的复杂程度，就取决于它封装的交互有多复杂了。

`只要是实现封装对象之间的交互功能，就可以应用上中介者模式，而不必过于拘泥于中介者模式本身的结构`。标准的中介者模式限制很多，导致能完全按照标准使用中介者模式的地方并不是很多，而且多集中在界面实现上。`只要本质不变，稍稍变形一下，简化一下，或许能更好的使用中介者模式`。

> 你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- **中介者模式和外观模式**

这两个模式有相似的地方，也存在很大的不同。

`外观模式多用来封装一个子系统内部的多个模块，目的是向子系统外部提供简单易用的接口`，也就是说外观模式封装的是子系统外部和子系统内部模块间的交互；而`中介者模式是提供多个平等的同事对象之间交互关系的封装，一般是用在内部实现上`。

另外，`外观模式是实现单向的交互，是从子系统外部来调用子系统内部，不会反着来，而中介者模式实现的是内部多个模块间多向的交互`。

> 开源架构中哪些使用了这一模式?



### 观察者模式

#### 介绍

在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新。

![image-20221022074944392](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022074944392.png)

#### 实例

> 抽象主播Tiktoker

```java
public abstract class AbstractTikToker {

    //添加粉丝
    abstract void addFans(AbstractFans fans);

    //通知粉丝
    abstract void notifyFans(String msg);
}
```

> 具体主播

```java
public class MMTikToker  extends AbstractTikToker{

    //1、观察者的核心1
    List<AbstractFans> fansList = new ArrayList<>();

    void startSell() {
        System.out.println("阳哥... 开始卖货...源码设计课");
        notifyFans("我开始卖东西了，是源码设计课，只要666");
    }
    void endSell() {
        System.out.println("阳哥... 结束卖货...源码设计课");
        notifyFans("课已经卖完了，记得五星好评...");
    }


    @Override
    void addFans(AbstractFans fans) {
        fansList.add(fans);
    }

    //通知所有观察者
    @Override
    void notifyFans(String msg) {
        //1、所有粉丝拿来通知
        for (AbstractFans fans : fansList) {
            fans.acceptMsg(msg);
        }
    }
}
```

> 抽象粉丝AbstractFans

```java
public abstract class AbstractFans {

    List<AbstractTikToker> tikTokers;//双向观察

    abstract void acceptMsg(String msg);

    void follow(AbstractTikToker tikToker){
        //主播增粉了
        tikToker.addFans(this);
//        for (AbstractTikToker toker : tikTokers) {
//
//        }
    };


}
```

> 具体粉丝

```java
//人类粉丝
public class HumanFans extends AbstractFans {
    @Override
    void acceptMsg(String msg) {
        System.out.println("主播说："+msg);
    }
}



//机器人粉丝
public class RobotFans extends AbstractFans {
    @Override
    void acceptMsg(String msg) {
        System.out.println("呸....");
    }
}
```

> 客户端测试

```java
public class MainTest {

    public static void main(String[] args) {

        MMTikToker lei = new MMTikToker();

        lei.startSell();

        RobotFans fans1 = new RobotFans();
        RobotFans fans2 = new RobotFans();
        RobotFans fans3 = new RobotFans();
        fans1.follow(lei);
        fans2.follow(lei);
        fans3.follow(lei);

        HumanFans humanFans = new HumanFans();
        humanFans.follow(lei);

        System.out.println("=====>");


        lei.endSell();
    }
}
```

#### 总结

> 本质是什么?

**观察者模式的本质：触发联动。**

> 它解决了什么问题?

- **观察者模式实现了观察者和目标之间的抽象耦合**
- **观察者模式支持广播通信**
- **观察者模式实现了动态联动**

> 存在的缺陷?

1. **观察者模式可能会引起无谓的操作**

由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法，如果观察者不需要执行相应处理，那么这次操作就浪费了

> 你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?

- 观察者模式和状态模式是有相似之处的

观察者模式是当目标状态发生改变时，触发并通知观察者，让观察者去执行相应的操作。而状态模式是根据不同的状态，选择不同的实现，这个实现类的主要功能就是针对状态的相应的操作，它不像观察者，观察者本身还有很多其它的功能，接收通知并执行相应处理只是观察者的部分功能。



- 观察者模式和中介者模式

前面的例子中目标都只是简单的通知一下，然后让各个观察者自己去完成更新就结束了。如果观察者和被观察的目标之间的交互关系很复杂，比如：有一个界面，里面有三个下拉列表组件，分别是选择国家、省份/州、具体的城市，很明显这是一个三级联动，当你选择一个国家的时候，省份/州应该相应改变数据，省份/州一改变，具体的城市也需要改变。

这种情况下，很明显需要相关的状态都联动准备好了，然后再一次性的通知观察者，就是界面做更新处理，不会国家改变一下，省份和城市还没有改，就通知界面更新。这种情况就可以使用中介者模式来封装观察者和目标的关系。

> 开源架构中哪些使用了这一模式?

### 备忘录模式

#### 介绍

 当你需要让对象返回之前的状态时(例如, 你的用户请求"撤销"), 你使用备忘录模式。

![image-20221022080724862](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022080724862.png)

#### 实例

以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。

> 计算器接口

```java
/**
 * Originator Interface
 */
public interface Calculator {

    // Create Memento
    PreviousCalculationToCareTaker backupLastCalculation();

    // setMemento
    void restorePreviousCalculation(PreviousCalculationToCareTaker memento);

    int getCalculationResult();

    void setFirstNumber(int firstNumber);

    void setSecondNumber(int secondNumber);
}

```

> 计算器实现

```java
/**
 * Originator Implementation
 */
public class CalculatorImp implements Calculator {

    private int firstNumber;
    private int secondNumber;

    @Override
    public PreviousCalculationToCareTaker backupLastCalculation() {
        // create a memento object used for restoring two numbers
        return new PreviousCalculationImp(firstNumber, secondNumber);
    }

    @Override
    public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
        this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();
        this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();
    }

    @Override
    public int getCalculationResult() {
        // result is adding two numbers
        return firstNumber + secondNumber;
    }

    @Override
    public void setFirstNumber(int firstNumber) {
        this.firstNumber = firstNumber;
    }

    @Override
    public void setSecondNumber(int secondNumber) {
        this.secondNumber = secondNumber;
    }
}
```

> 备忘录接口

```java
/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */
public interface PreviousCalculationToOriginator {
    int getFirstNumber();
    int getSecondNumber();
}

```

> 备忘录实现

```java
/**
 * Memento Object Implementation
 * <p>
 * Note that this object implements both interfaces to Originator and CareTaker
 */
public class PreviousCalculationImp implements PreviousCalculationToCareTaker,
        PreviousCalculationToOriginator {

    private int firstNumber;
    private int secondNumber;

    public PreviousCalculationImp(int firstNumber, int secondNumber) {
        this.firstNumber = firstNumber;
        this.secondNumber = secondNumber;
    }

    @Override
    public int getFirstNumber() {
        return firstNumber;
    }

    @Override
    public int getSecondNumber() {
        return secondNumber;
    }
}
```

> 客户端测试

```java
/**
 * CareTaker object
 */
public class Client {

    public static void main(String[] args) {
        // program starts
        Calculator calculator = new CalculatorImp();

        // assume user enters two numbers
        calculator.setFirstNumber(10);
        calculator.setSecondNumber(100);

        // find result
        System.out.println(calculator.getCalculationResult());

        // Store result of this calculation in case of error
        PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();

        // user enters a number
        calculator.setFirstNumber(17);

        // user enters a wrong second number and calculates result
        calculator.setSecondNumber(-290);

        // calculate result
        System.out.println(calculator.getCalculationResult());

        // user hits CTRL + Z to undo last operation and see last result
        calculator.restorePreviousCalculation(memento);

        // result restored
        System.out.println(calculator.getCalculationResult());
    }
}
110
-273
110
```

#### 总结

> 本质是什么?

备忘录模式的本质：保存和恢复内部状态（对象的属性）。

### 解释器模式

#### 介绍

为语言创建解释器，通常由语言的语法和语法分析来定义。

![image-20221022082448738](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022082448738.png)

不需要掌握，底层源码也很少有用到

### 命令模式

#### 介绍

将"请求"封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作

将命令封装成对象中，以便使用命令来参数化其它对象，或者将命令对象放入队列中进行排队，或者将命令对象的操作记录到日志中，以及支持可撤销的操作。

这个我们天天再用，封装方法就叫命令

![image-20221022082348284](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022082348284.png)

#### 实例

> 抽象命令类

```java
public interface  Command {

    /**
     * 命令的执行方法
     */
    void execute();

}
```

> 具体命令类

```java
public class OnlineCommand implements Command{

    //Dao
    private LeiReceiver receiver = new LeiReceiver();
    @Override
    public void execute() {
        System.out.println("要去上（吹）课（牛）....");
        receiver.online();
    }
}

public class WuHanTravelCommand implements Command{

    private LeiReceiver receiver = new LeiReceiver();

    @Override
    public void execute() {
        System.out.println("我要出（旅）差（游）....");
        receiver.travel();
    }
}
```

> 命令调用者

```java
public class TeacherTongInvoker {
    Command command;

    public void call(){
        //命令
        command.execute();
    }


    public void setCommand(Command command) {
        this.command = command;
    }
}
```

> 命令接受者（执行者）

```java
public class LeiReceiver {

    public void online(){
        System.out.println("leifengyang 在线上直播大厂课......");
    }
    public void travel(){
        System.out.println("leifengyang 出差.....");
    }
}
```

> 客户端测试

```java
public class MainTest {

    public static void main(String[] args) {


//        LeiReceiver leiReceiver = new LeiReceiver();
//        leiReceiver.travel();

        TeacherTongInvoker invoker = new TeacherTongInvoker();
        invoker.setCommand(new OnlineCommand());

        invoker.call();
    }
}
```

### 迭代器模式

#### 介绍

提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示。

所谓聚合是：指一组对象的组合结构，比如：Java中的集合、数组等。





![image-20221022083020169](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022083020169.png)

#### 实例

> 聚合类

```java
public interface Aggregate {
    Iterator createIterator();
}

```

> 具体聚合类

```java
public class ConcreteAggregate implements Aggregate {

    private Integer[] items;

    public ConcreteAggregate() {
        items = new Integer[10];
        for (int i = 0; i < items.length; i++) {
            items[i] = i;
        }
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator<Integer>(items);
    }
}

```

> 迭代器接口

迭代器只有两个方法，一个是有没有下一个，一个是下一个是什么

```java
public interface Iterator<Item> {
    Item next();

    boolean hasNext();
}

```

> 具体迭代器实现

```java
public class ConcreteIterator<Item> implements Iterator {

    private Item[] items;
    private int position = 0;

    public ConcreteIterator(Item[] items) {
        this.items = items;
    }

    @Override
    public Object next() {
        return items[position++];
    }

    @Override
    public boolean hasNext() {
        return position < items.length;
    }
}

```

> 客户端测试

生成聚合对象，调用生成迭代器的方法createIterator生成迭代器

对聚合对象进行遍历

```java
public class Client {
    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        Iterator<Integer> iterator = aggregate.createIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

迭代器模式的本质：控制访问聚合对象中的元素。

### 访问者模式

#### 介绍

当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式

### 简单责任链模式

#### 介绍

通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象

![image-20221022153332579](https://raw.githubusercontent.com/YuyanCai/imagebed/main/image-20221022153332579.png)

#### 实例

> Handler处理器

```java
public abstract class Handler {
    protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }

    protected abstract void handleRequest(Request request);
}

```

> 具体处理器

```java
public class ConcreteHandler1 extends Handler {
    public ConcreteHandler1(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.type1) {
            System.out.println(request.getName() + " is handle by ConcreteHandler1");
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}




//具体处理器2
public class ConcreteHandler2 extends Handler{
    public ConcreteHandler2(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.type2) {
            System.out.println(request.getName() + " is handle by ConcreteHandler2");
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
```

> 请求类

```java
public class Request {
    private RequestType type;
    private String name;

    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }

    public RequestType getType() {
        return type;
    }

    public String getName() {
        return name;
    }
}

```

> 请求类型的枚举

```java
public enum RequestType {
    type1, type2
}
```

> 客户端测试

```java
public class Client {
    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1(null);
        Handler handler2 = new ConcreteHandler2(handler1);
        Request request1 = new Request(RequestType.type1, "request1");
        handler2.handleRequest(request1);
        Request request2 = new Request(RequestType.type2, "request2");
        handler2.handleRequest(request2);
    }
}
```

#### 总结

> 1.使用的场景?



> 2.本质是什么?



> 3.它解决了什么问题?



> 4.它体现了设计模式中什么原则?



> 5.存在的缺陷?



> 6.你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?



> 7.开源架构中哪些使用了这一模式?







## 七、参考文章

[单例模式详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/51854665)

https://www.jianshu.com/p/d0c444275827

https://juejin.cn/post/6844903795017646094##heading-3

https://cloud.tencent.com/developer/article/1394271?from=article.detail.1394179



























##### 
